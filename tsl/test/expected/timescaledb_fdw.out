-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\c :TEST_DBNAME :ROLE_SUPERUSER
-- Cleanup from other potential tests that created this database
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS data_node_1;
SET client_min_messages TO NOTICE;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
SELECT * FROM add_data_node('data_node_1',
                            database => 'data_node_1',
                            password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                            bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                            bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_1"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_1 | localhost | 15432 | data_node_1 | t            | t                | t
(1 row)

-- Set FDW and libpq options to make sure they are validated correctly
ALTER SERVER data_node_1 OPTIONS (ADD use_remote_estimate 'true');
ALTER SERVER data_node_1 OPTIONS (ADD fdw_startup_cost '110.0');
ALTER SERVER data_node_1 OPTIONS (ADD connect_timeout '3');
-- Test a bad option
\set ON_ERROR_STOP 0
ALTER SERVER data_node_1 OPTIONS (ADD invalid_option '3');
ERROR:  invalid option "invalid_option"
\set ON_ERROR_STOP 1
\c data_node_1
SET client_min_messages TO ERROR;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE TABLE test_ft (c0 int, c1 varchar(10));
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE FOREIGN TABLE test_ft (c0 int, c1 varchar(10)) SERVER data_node_1;
SELECT * FROM test_ft;
 c0 | c1 
----+----
(0 rows)

EXPLAIN (COSTS FALSE) INSERT INTO test_ft VALUES (1, 'value1'), (2, 'value2'), (2, 'value1') RETURNING c1, c0;
           QUERY PLAN            
---------------------------------
 Insert on test_ft
   ->  Values Scan on "*VALUES*"
(2 rows)

INSERT INTO test_ft VALUES (1, 'value1'), (2, 'value2'), (2, 'value1') RETURNING c1, c0;
   c1   | c0 
--------+----
 value1 |  1
 value2 |  2
 value1 |  2
(3 rows)

-- Show tuples inserted on remote data node
\c data_node_1
SELECT * FROM test_ft;
 c0 |   c1   
----+--------
  1 | value1
  2 | value2
  2 | value1
(3 rows)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Query from frontend
EXPLAIN (VERBOSE, COSTS FALSE) SELECT * FROM test_ft;
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.test_ft
   Output: c0, c1
   Data node: data_node_1
   Remote SQL: SELECT c0, c1 FROM public.test_ft
(4 rows)

EXPLAIN (VERBOSE, COSTS FALSE) SELECT avg(c0) FROM test_ft GROUP BY c1;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Foreign Scan
   Output: (avg(c0)), c1
   Relations: Aggregate on (public.test_ft)
   Data node: data_node_1
   Remote SQL: SELECT avg(c0), c1 FROM public.test_ft GROUP BY 2
(5 rows)

SELECT * FROM test_ft;
 c0 |   c1   
----+--------
  1 | value1
  2 | value2
  2 | value1
(3 rows)

SELECT avg(c0) FROM test_ft GROUP BY c1;
        avg         
--------------------
 2.0000000000000000
 1.5000000000000000
(2 rows)

-- Update rows
EXPLAIN (VERBOSE, COSTS FALSE)
UPDATE test_ft SET c1 = 'new_test' WHERE c0 = 2
RETURNING c1, c0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Update on public.test_ft
   Output: c1, c0
   Remote SQL: UPDATE public.test_ft SET c1 = $2 WHERE ctid = $1 RETURNING c0, c1
   ->  Foreign Scan on public.test_ft
         Output: c0, 'new_test'::character varying(10), ctid
         Data node: data_node_1
         Remote SQL: SELECT c0, ctid FROM public.test_ft WHERE ((c0 = 2)) FOR UPDATE
(7 rows)

UPDATE test_ft SET c1 = 'new_test' WHERE c0 = 2
RETURNING c1, c0;
    c1    | c0 
----------+----
 new_test |  2
 new_test |  2
(2 rows)

-- Show that the update was applied
SELECT * FROM test_ft;
 c0 |    c1    
----+----------
  1 | value1
  2 | new_test
  2 | new_test
(3 rows)

-- Test deletes
DELETE FROM test_ft WHERE c0 = 1;
-- Show tuples deleted locally and on remote data node
SELECT * FROM test_ft;
 c0 |    c1    
----+----------
  2 | new_test
  2 | new_test
(2 rows)

\c data_node_1
SELECT * FROM test_ft;
 c0 |    c1    
----+----------
  2 | new_test
  2 | new_test
(2 rows)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
ANALYZE VERBOSE test_ft;
INFO:  analyzing "public.test_ft"
INFO:  "test_ft": table contains 2 rows, 2 rows in sample
