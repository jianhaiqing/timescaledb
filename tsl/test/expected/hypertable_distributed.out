-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Need to be super user to create extension and add servers
\c :TEST_DBNAME :ROLE_SUPERUSER;
-- Need explicit password for non-super users to connect
ALTER ROLE :ROLE_DEFAULT_CLUSTER_USER CREATEDB PASSWORD 'pass';
GRANT USAGE ON FOREIGN DATA WRAPPER timescaledb_fdw TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Cleanup from other potential tests that created these databases
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS server_1;
DROP DATABASE IF EXISTS server_2;
DROP DATABASE IF EXISTS server_3;
SET client_min_messages TO NOTICE;
CREATE DATABASE server_1;
CREATE DATABASE server_2;
CREATE DATABASE server_3;
\c server_1
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
\c server_2
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
\c server_3
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
\c :TEST_DBNAME :ROLE_SUPERUSER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Add servers using the TimescaleDB server management API
SELECT * FROM add_server('server_1', database => 'server_1', password => 'pass');
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_1    | localhost | 15432 | server_1 | default_cluster_user | default_cluster_user | t
(1 row)

SELECT * FROM add_server('server_2', database => 'server_2', password => 'pass');
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_2    | localhost | 15432 | server_2 | default_cluster_user | default_cluster_user | t
(1 row)

SELECT * FROM add_server('server_3', database => 'server_3', port => inet_server_port(), password => 'pass');
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_3    | localhost | 15432 | server_3 | default_cluster_user | default_cluster_user | t
(1 row)

-- Create distributed hypertables. Add a trigger and primary key
-- constraint to test how those work
CREATE TABLE disttable(time timestamptz PRIMARY KEY, device int CHECK (device > 0), color int, temp float);
SELECT * FROM create_hypertable('disttable', 'time', replication_factor => 1);
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             1 | public      | disttable  | t
(1 row)

-- An underreplicated table that will has a replication_factor > num_servers
CREATE TABLE underreplicated(time timestamptz, device int, temp float);
SELECT * FROM create_hypertable('underreplicated', 'time', replication_factor => 4);
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name |   table_name    | created 
---------------+-------------+-----------------+---------
             2 | public      | underreplicated | t
(1 row)

SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE OR REPLACE FUNCTION test_trigger()
    RETURNS TRIGGER LANGUAGE PLPGSQL AS
$BODY$
DECLARE
    cnt INTEGER;
BEGIN
    SELECT count(*) INTO cnt FROM hyper;
    RAISE WARNING 'FIRING trigger when: % level: % op: % cnt: % trigger_name %',
        tg_when, tg_level, tg_op, cnt, tg_name;

    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    END IF;
    RETURN NEW;
END
$BODY$;
CREATE TRIGGER _0_test_trigger_insert
    BEFORE INSERT ON disttable
    FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM _timescaledb_catalog.hypertable_server;
 hypertable_id | server_hypertable_id | server_name 
---------------+----------------------+-------------
             1 |                    1 | server_1
             1 |                    1 | server_2
             1 |                    1 | server_3
             2 |                    2 | server_1
             2 |                    2 | server_2
             2 |                    2 | server_3
(6 rows)

SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
(0 rows)

-- The constraints, indexes, and triggers on the hypertable
SELECT * FROM test.show_constraints('disttable');
       Constraint       | Type | Columns  |     Index      |     Expr     | Deferrable | Deferred | Validated 
------------------------+------+----------+----------------+--------------+------------+----------+-----------
 disttable_device_check | c    | {device} | -              | (device > 0) | f          | f        | t
 disttable_pkey         | p    | {time}   | disttable_pkey |              | f          | f        | t
(2 rows)

SELECT * FROM test.show_indexes('disttable');
     Index      | Columns | Expr | Unique | Primary | Exclusion | Tablespace 
----------------+---------+------+--------+---------+-----------+------------
 disttable_pkey | {time}  |      | t      | t       | f         | 
(1 row)

SELECT * FROM test.show_triggers('disttable');
        Trigger         | Type |               Function               
------------------------+------+--------------------------------------
 _0_test_trigger_insert |    7 | test_trigger
 ts_insert_blocker      |    7 | _timescaledb_internal.insert_blocker
(2 rows)

-- Drop a column. This will make the attribute numbers of the
-- hypertable's root relation differ from newly created chunks. It is
-- a way to test that we properly handle attributed conversion between
-- the root table and chunks
ALTER TABLE disttable DROP COLUMN color;
-- Currently no distributed DDL support, so need to manually drop
-- column on datanodes
\c server_1
ALTER TABLE disttable DROP COLUMN color;
\c server_2
ALTER TABLE disttable DROP COLUMN color;
\c server_3
ALTER TABLE disttable DROP COLUMN color;
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- EXPLAIN some inserts to see what plans and explain output for
-- remote inserts look like
EXPLAIN (COSTS FALSE)
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1);
                 QUERY PLAN                 
--------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable disttable
   ->  Insert on disttable
         ->  Custom Scan (ChunkDispatch)
               ->  Result
(5 rows)

EXPLAIN (VERBOSE, COSTS FALSE)
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable public.disttable
   Servers: server_1, server_2, server_3
   Remote SQL: INSERT INTO public.disttable("time", device, temp) VALUES ($1, $2, $3)
   ->  Insert on public.disttable
         ->  Custom Scan (ChunkDispatch)
               Output: 'Sun Jan 01 06:01:00 2017 PST'::timestamp with time zone, 1, NULL::integer, '1.1'::double precision
               ->  Result
                     Output: 'Sun Jan 01 06:01:00 2017 PST'::timestamp with time zone, 1, NULL::integer, '1.1'::double precision
(9 rows)

-- Create some chunks through insertion
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1),
       ('2017-01-01 08:01', 1, 1.2),
       ('2018-01-02 08:01', 2, 1.3),
       ('2019-01-01 09:11', 3, 2.1);
-- Test prepared statement
PREPARE dist_insert (timestamptz, int, float) AS
INSERT INTO disttable VALUES ($1, $2, $3);
EXECUTE dist_insert ('2017-01-01 06:05', 1, 1.4);
-- Show chunks created
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_1_dist_chunk | f       | {"time": [1482969600000000, 1483574400000000]}
        2 |             1 | _timescaledb_internal | _hyper_1_2_dist_chunk | f       | {"time": [1514419200000000, 1515024000000000]}
        3 |             1 | _timescaledb_internal | _hyper_1_3_dist_chunk | f       | {"time": [1545868800000000, 1546473600000000]}
(3 rows)

-- Show that there are assigned server_chunk_id:s in chunk server mappings
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
(3 rows)

-- Show that chunks are created on remote servers
\c server_1
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_1_dist_chunk | r       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4
(3 rows)

\c server_2
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_2_dist_chunk | r       | {"time": [1514419200000000, 1515024000000000]}
(1 row)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3
(1 row)

\c server_3
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_3_dist_chunk | r       | {"time": [1545868800000000, 1546473600000000]}
(1 row)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Show what some queries would look like on the frontend
EXPLAIN (VERBOSE, COSTS FALSE)
SELECT * FROM disttable;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Append
   ->  Foreign Scan on _timescaledb_internal._hyper_1_1_dist_chunk
         Output: _hyper_1_1_dist_chunk."time", _hyper_1_1_dist_chunk.device, _hyper_1_1_dist_chunk.temp
         Remote SQL: SELECT "time", device, temp FROM _timescaledb_internal._hyper_1_1_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_1_2_dist_chunk
         Output: _hyper_1_2_dist_chunk."time", _hyper_1_2_dist_chunk.device, _hyper_1_2_dist_chunk.temp
         Remote SQL: SELECT "time", device, temp FROM _timescaledb_internal._hyper_1_2_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_1_3_dist_chunk
         Output: _hyper_1_3_dist_chunk."time", _hyper_1_3_dist_chunk.device, _hyper_1_3_dist_chunk.temp
         Remote SQL: SELECT "time", device, temp FROM _timescaledb_internal._hyper_1_3_dist_chunk
(10 rows)

EXPLAIN (VERBOSE, COSTS FALSE)
SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable GROUP BY 1, 2
ORDER BY 1;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (time_bucket('@ 3 hours'::interval, _hyper_1_1_dist_chunk."time")), _hyper_1_1_dist_chunk.device, avg(_hyper_1_1_dist_chunk.temp)
   Group Key: (time_bucket('@ 3 hours'::interval, _hyper_1_1_dist_chunk."time")), _hyper_1_1_dist_chunk.device
   ->  Sort
         Output: (time_bucket('@ 3 hours'::interval, _hyper_1_1_dist_chunk."time")), _hyper_1_1_dist_chunk.device, _hyper_1_1_dist_chunk.temp
         Sort Key: (time_bucket('@ 3 hours'::interval, _hyper_1_1_dist_chunk."time")), _hyper_1_1_dist_chunk.device
         ->  Append
               ->  Foreign Scan on _timescaledb_internal._hyper_1_1_dist_chunk
                     Output: time_bucket('@ 3 hours'::interval, _hyper_1_1_dist_chunk."time"), _hyper_1_1_dist_chunk.device, _hyper_1_1_dist_chunk.temp
                     Remote SQL: SELECT "time", device, temp FROM _timescaledb_internal._hyper_1_1_dist_chunk
               ->  Foreign Scan on _timescaledb_internal._hyper_1_2_dist_chunk
                     Output: time_bucket('@ 3 hours'::interval, _hyper_1_2_dist_chunk."time"), _hyper_1_2_dist_chunk.device, _hyper_1_2_dist_chunk.temp
                     Remote SQL: SELECT "time", device, temp FROM _timescaledb_internal._hyper_1_2_dist_chunk
               ->  Foreign Scan on _timescaledb_internal._hyper_1_3_dist_chunk
                     Output: time_bucket('@ 3 hours'::interval, _hyper_1_3_dist_chunk."time"), _hyper_1_3_dist_chunk.device, _hyper_1_3_dist_chunk.temp
                     Remote SQL: SELECT "time", device, temp FROM _timescaledb_internal._hyper_1_3_dist_chunk
(16 rows)

-- Execute some queries on the frontend and return the results
SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1
(5 rows)

SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable
GROUP BY 1, 2
ORDER BY 1;
             time             | device | avg_temp 
------------------------------+--------+----------
 Sun Jan 01 04:00:00 2017 PST |      1 |     1.25
 Sun Jan 01 07:00:00 2017 PST |      1 |      1.2
 Tue Jan 02 07:00:00 2018 PST |      2 |      1.3
 Tue Jan 01 07:00:00 2019 PST |      3 |      2.1
(4 rows)

SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable GROUP BY 1, 2
HAVING avg(temp) > 1.2
ORDER BY 1;
             time             | device | avg_temp 
------------------------------+--------+----------
 Sun Jan 01 04:00:00 2017 PST |      1 |     1.25
 Tue Jan 02 07:00:00 2018 PST |      2 |      1.3
 Tue Jan 01 07:00:00 2019 PST |      3 |      2.1
(3 rows)

SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable
WHERE temp > 2
GROUP BY 1, 2
HAVING avg(temp) > 1.2
ORDER BY 1;
             time             | device | avg_temp 
------------------------------+--------+----------
 Tue Jan 01 07:00:00 2019 PST |      3 |      2.1
(1 row)

-- The constraints, indexes, and triggers on foreign chunks. Only
-- check constraints should recurse to foreign chunks (although they
-- aren't enforced on a foreign table)
SELECT st."Child" as chunk_relid, test.show_constraints((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |                                                                                   show_constraints                                                                                   
---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (constraint_2,c,{time},-,"((""time"" >= 'Wed Dec 27 16:00:00 2017 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 03 16:00:00 2018 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (constraint_3,c,{time},-,"((""time"" >= 'Wed Dec 26 16:00:00 2018 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 02 16:00:00 2019 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
(6 rows)

SELECT st."Child" as chunk_relid, test.show_indexes((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_indexes 
-------------+--------------
(0 rows)

SELECT st."Child" as chunk_relid, test.show_triggers((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_triggers 
-------------+---------------
(0 rows)

-- Check that the chunks are assigned servers
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
(3 rows)

-- Adding a new trigger should not recurse to foreign chunks
CREATE TRIGGER _1_test_trigger_insert
    AFTER INSERT ON disttable
    FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT st."Child" as chunk_relid, test.show_triggers((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_triggers 
-------------+---------------
(0 rows)

-- Check that we can create indexes on distributed hypertables and
-- that they don't recurse to foreign chunks
CREATE INDEX ON disttable (time, device);
SELECT * FROM test.show_indexes('disttable');
           Index           |    Columns    | Expr | Unique | Primary | Exclusion | Tablespace 
---------------------------+---------------+------+--------+---------+-----------+------------
 disttable_pkey            | {time}        |      | t      | t       | f         | 
 disttable_time_device_idx | {time,device} |      | f      | f       | f         | 
(2 rows)

SELECT st."Child" as chunk_relid, test.show_indexes((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_indexes 
-------------+--------------
(0 rows)

-- No index mappings should exist either
SELECT * FROM _timescaledb_catalog.chunk_index;
 chunk_id | index_name | hypertable_id | hypertable_index_name 
----------+------------+---------------+-----------------------
(0 rows)

-- Check that creating columns work
ALTER TABLE disttable ADD COLUMN "Color" int;
-- Currently no distributed DDL support, so need to manually add
-- column on datanodes
\c server_1
ALTER TABLE disttable ADD COLUMN "Color" int;
\c server_2
ALTER TABLE disttable ADD COLUMN "Color" int;
\c server_3
ALTER TABLE disttable ADD COLUMN "Color" int;
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
SELECT * FROM test.show_columns('disttable');
 Column |           Type           | NotNull 
--------+--------------------------+---------
 time   | timestamp with time zone | t
 device | integer                  | f
 temp   | double precision         | f
 Color  | integer                  | f
(4 rows)

SELECT st."Child" as chunk_relid, test.show_columns((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |            show_columns             
---------------------------------------------+-------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (device,integer,f)
 _timescaledb_internal._hyper_1_1_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_1_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (device,integer,f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (device,integer,f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (Color,integer,f)
(12 rows)

-- Adding a new unique constraint should not recurse to foreign
-- chunks, but a check constraint should
ALTER TABLE disttable ADD CONSTRAINT disttable_color_unique UNIQUE (time, "Color");
ALTER TABLE disttable ADD CONSTRAINT disttable_temp_non_negative CHECK (temp > 0.0);
SELECT st."Child" as chunk_relid, test.show_constraints((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |                                                                                   show_constraints                                                                                   
---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (constraint_2,c,{time},-,"((""time"" >= 'Wed Dec 27 16:00:00 2017 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 03 16:00:00 2018 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (constraint_3,c,{time},-,"((""time"" >= 'Wed Dec 26 16:00:00 2018 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 02 16:00:00 2019 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
(9 rows)

SELECT cc.*
FROM (SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
      FROM show_chunks('disttable')) c,
      _timescaledb_catalog.chunk_constraint cc
WHERE c.chunk_id = cc.chunk_id;
 chunk_id | dimension_slice_id | constraint_name | hypertable_constraint_name 
----------+--------------------+-----------------+----------------------------
        1 |                  1 | constraint_1    | 
        2 |                  2 | constraint_2    | 
        3 |                  3 | constraint_3    | 
(3 rows)

-- Test INSERTS with RETURNING. Since we previously dropped a column
-- on the hypertable, this also tests that we handle conversion of the
-- attribute numbers in the RETURNING clause, since they now differ
-- between the hypertable root relation and the chunk currently
-- RETURNING from.
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-02 06:09', 4, 1, 9.8)
RETURNING time, "Color", temp;
             time             | Color | temp 
------------------------------+-------+------
 Sat Sep 02 06:09:00 2017 PDT |     1 |  9.8
(1 row)

-- On conflict
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-02 06:09', 6, 2, 10.5)
ON CONFLICT DO NOTHING;
-- Show new row and that conflicting row is not inserted
\c server_1
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4 |      
(3 rows)

\c server_2
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |      
 Sat Sep 02 06:09:00 2017 PDT |      4 |  9.8 |     1
(2 rows)

\c server_3
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1 |      
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\set ON_ERROR_STOP 0
-- ON CONFLICT only works with DO NOTHING
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-09 08:13', 7, 3, 27.5)
ON CONFLICT (time) DO UPDATE SET temp = 3.2;
ERROR:  unexpected ON CONFLICT specification: 2
\set ON_ERROR_STOP 1
-- Test updates
UPDATE disttable SET device = 4 WHERE device = 3;
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4 |      
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |      
 Tue Jan 01 09:11:00 2019 PST |      4 |  2.1 |      
 Sat Sep 02 06:09:00 2017 PDT |      4 |  9.8 |     1
(6 rows)

WITH devices AS (
     SELECT DISTINCT device FROM disttable ORDER BY device
)
UPDATE disttable SET device = 2 WHERE device = (SELECT device FROM devices LIMIT 1);
\set ON_ERROR_STOP 0
-- Updates referencing non-existing column
UPDATE disttable SET device = 4 WHERE no_such_column = 2;
ERROR:  column "no_such_column" does not exist at character 39
UPDATE disttable SET no_such_column = 4 WHERE device = 2;
ERROR:  column "no_such_column" of relation "disttable" does not exist at character 22
-- Update to system column
UPDATE disttable SET tableoid = 4 WHERE device = 2;
ERROR:  cannot assign to system column "tableoid" at character 22
\set ON_ERROR_STOP 1
-- Test deletes (no rows deleted)
DELETE FROM disttable WHERE device = 3
RETURNING *;
 time | device | temp | Color 
------+--------+------+-------
(0 rows)

-- Test deletes (rows deleted)
DELETE FROM disttable WHERE device = 4
RETURNING *;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Tue Jan 01 09:11:00 2019 PST |      4 |  2.1 |      
 Sat Sep 02 06:09:00 2017 PDT |      4 |  9.8 |     1
(2 rows)

-- Query to show that rows are deleted
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      2 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      2 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      2 |  1.4 |      
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |      
(4 rows)

-- Ensure rows are deleted on the servers
\c server_1
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      2 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      2 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      2 |  1.4 |      
(3 rows)

\c server_2
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |      
(1 row)

\c server_3
SELECT * FROM disttable;
 time | device | temp | Color 
------+--------+------+-------
(0 rows)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Test underreplicated chunk warning
INSERT INTO underreplicated VALUES ('2017-01-01 06:01', 1, 1.1),
                                   ('2017-01-02 07:01', 2, 3.5);
WARNING:  under-replicated chunk 5, lacks 1 server(s)
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
        4 |               2 | server_2
        5 |               2 | server_1
        5 |               3 | server_2
        5 |               2 | server_3
(7 rows)

SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        5 |             2 | _timescaledb_internal | _hyper_2_5_dist_chunk | f       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

-- Show chunk server mappings
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
        4 |               2 | server_2
        5 |               2 | server_1
        5 |               3 | server_2
        5 |               2 | server_3
(7 rows)

-- Show that chunks are created on remote servers and that all
-- servers/chunks have the same data due to replication
\c server_1
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        2 |             2 | _timescaledb_internal | _hyper_2_5_dist_chunk | r       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |  3.5
(2 rows)

\c server_2
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        3 |             2 | _timescaledb_internal | _hyper_2_5_dist_chunk | r       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |  3.5
(2 rows)

\c server_3
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        2 |             2 | _timescaledb_internal | _hyper_2_5_dist_chunk | r       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |  3.5
(2 rows)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
UPDATE underreplicated SET temp = 2.0 WHERE device = 2
RETURNING time, temp, device;
             time             | temp | device 
------------------------------+------+--------
 Mon Jan 02 07:01:00 2017 PST |    2 |      2
(1 row)

SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(2 rows)

-- Show that all replica chunks are updated
\c server_1
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(2 rows)

\c server_2
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(2 rows)

\c server_3
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(2 rows)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
DELETE FROM underreplicated WHERE device = 2
RETURNING *;
             time             | device | temp 
------------------------------+--------+------
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(1 row)

-- Ensure deletes across all servers
\c server_1
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
(1 row)

\c server_2
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
(1 row)

\c server_3
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Test hypertable creation fails on distributed error
\c server_3
CREATE TABLE remotetable(time timestamptz PRIMARY KEY, id int, cost float);
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\set ON_ERROR_STOP 0
CREATE TABLE remotetable(time timestamptz PRIMARY KEY, device int CHECK (device > 0), color int, temp float);
SELECT * FROM create_hypertable('remotetable', 'time', replication_factor => 1);
ERROR:  remote connection error: relation "remotetable" already exists
\set ON_ERROR_STOP 1
SELECT * FROM timescaledb_information.hypertable
ORDER BY table_schema, table_name;
 table_schema |   table_name    |     table_owner      | num_dimensions | num_chunks | table_size | index_size | toast_size | total_size 
--------------+-----------------+----------------------+----------------+------------+------------+------------+------------+------------
 public       | disttable       | default_cluster_user |              1 |          4 | 0 bytes    | 0 bytes    |            | 0 bytes
 public       | underreplicated | default_cluster_user |              1 |          1 | 0 bytes    | 0 bytes    |            | 0 bytes
(2 rows)

-- Test distributed hypertable creation with many parameters
\c server_1
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
\c server_2
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
\c server_3
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\c :TEST_DBNAME :ROLE_SUPERUSER
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE TABLE "Table\\Schema"."Param_Table"("time Col %#^#@$#" timestamptz, __region text, reading float);
SELECT * FROM create_hypertable('"Table\\Schema"."Param_Table"', 'time Col %#^#@$#', partitioning_column => '__region', number_partitions  => 4,
associated_schema_name => 'T3sTSch', associated_table_prefix => 'test*pre_', chunk_time_interval => interval '1 week',
create_default_indexes => FALSE, if_not_exists => TRUE, migrate_data => TRUE, replication_factor => 2,
servers => '{ "server_2", "server_3" }');
NOTICE:  adding not-null constraint to column "time Col %#^#@$#"
 hypertable_id |  schema_name  | table_name  | created 
---------------+---------------+-------------+---------
             4 | Table\\Schema | Param_Table | t
(1 row)

-- Test assign_server
SET ROLE :ROLE_SUPERUSER;
CREATE OR REPLACE FUNCTION assign_server(
    hypertable REGCLASS,
    server     NAME
)
RETURNS void
AS :TSL_MODULE_PATHNAME, 'tsl_test_assign_server' LANGUAGE C;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
SELECT * FROM _timescaledb_catalog.hypertable_server;
 hypertable_id | server_hypertable_id | server_name 
---------------+----------------------+-------------
             1 |                    1 | server_1
             1 |                    1 | server_2
             1 |                    1 | server_3
             2 |                    2 | server_1
             2 |                    2 | server_2
             2 |                    2 | server_3
             4 |                    3 | server_2
             4 |                    3 | server_3
(8 rows)

SELECT * FROM assign_server('"Table\\Schema"."Param_Table"', 'server_1');
 assign_server 
---------------
 
(1 row)

SELECT * FROM _timescaledb_catalog.hypertable_server;
 hypertable_id | server_hypertable_id | server_name 
---------------+----------------------+-------------
             1 |                    1 | server_1
             1 |                    1 | server_2
             1 |                    1 | server_3
             2 |                    2 | server_1
             2 |                    2 | server_2
             2 |                    2 | server_3
             4 |                    3 | server_2
             4 |                    3 | server_3
             4 |                    3 | server_1
(9 rows)

-- Verify hypertables on all servers
SELECT * FROM _timescaledb_catalog.hypertable;
 id |  schema_name  |   table_name    | associated_schema_name | associated_table_prefix | num_dimensions | chunk_sizing_func_schema |  chunk_sizing_func_name  | chunk_target_size | compressed | compressed_hypertable_id | replication_factor 
----+---------------+-----------------+------------------------+-------------------------+----------------+--------------------------+--------------------------+-------------------+------------+--------------------------+--------------------
  1 | public        | disttable       | _timescaledb_internal  | _hyper_1                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                  1
  2 | public        | underreplicated | _timescaledb_internal  | _hyper_2                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                  4
  4 | Table\\Schema | Param_Table     | T3sTSch                | test*pre_               |              2 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                  2
(3 rows)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  4 |             4 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  5 |             4 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(4 rows)

SELECT * FROM test.show_triggers('"Table\\Schema"."Param_Table"');
      Trigger      | Type |               Function               
-------------------+------+--------------------------------------
 ts_insert_blocker |    7 | _timescaledb_internal.insert_blocker
(1 row)

\c server_1
SELECT * FROM _timescaledb_catalog.hypertable;
 id |  schema_name  |   table_name    | associated_schema_name | associated_table_prefix | num_dimensions | chunk_sizing_func_schema |  chunk_sizing_func_name  | chunk_target_size | compressed | compressed_hypertable_id | replication_factor 
----+---------------+-----------------+------------------------+-------------------------+----------------+--------------------------+--------------------------+-------------------+------------+--------------------------+--------------------
  1 | public        | disttable       | _timescaledb_internal  | _hyper_1                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  2 | public        | underreplicated | _timescaledb_internal  | _hyper_2                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  3 | Table\\Schema | Param_Table     | T3sTSch                | test*pre_               |              2 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
(3 rows)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  3 |             3 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  4 |             3 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(4 rows)

SELECT t.tgname, t.tgtype, t.tgfoid::regproc
FROM pg_trigger t, pg_class c WHERE c.relname = 'Param_Table' AND t.tgrelid = c.oid;
      tgname       | tgtype |                tgfoid                
-------------------+--------+--------------------------------------
 ts_insert_blocker |      7 | _timescaledb_internal.insert_blocker
(1 row)

\c server_2
SELECT * FROM _timescaledb_catalog.hypertable;
 id |  schema_name  |   table_name    | associated_schema_name | associated_table_prefix | num_dimensions | chunk_sizing_func_schema |  chunk_sizing_func_name  | chunk_target_size | compressed | compressed_hypertable_id | replication_factor 
----+---------------+-----------------+------------------------+-------------------------+----------------+--------------------------+--------------------------+-------------------+------------+--------------------------+--------------------
  1 | public        | disttable       | _timescaledb_internal  | _hyper_1                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  2 | public        | underreplicated | _timescaledb_internal  | _hyper_2                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  3 | Table\\Schema | Param_Table     | T3sTSch                | test*pre_               |              2 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
(3 rows)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  3 |             3 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  4 |             3 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(4 rows)

SELECT t.tgname, t.tgtype, t.tgfoid::regproc
FROM pg_trigger t, pg_class c WHERE c.relname = 'Param_Table' AND t.tgrelid = c.oid;
      tgname       | tgtype |                tgfoid                
-------------------+--------+--------------------------------------
 ts_insert_blocker |      7 | _timescaledb_internal.insert_blocker
(1 row)

\c server_3
SELECT * FROM _timescaledb_catalog.hypertable;
 id |  schema_name  |   table_name    | associated_schema_name | associated_table_prefix | num_dimensions | chunk_sizing_func_schema |  chunk_sizing_func_name  | chunk_target_size | compressed | compressed_hypertable_id | replication_factor 
----+---------------+-----------------+------------------------+-------------------------+----------------+--------------------------+--------------------------+-------------------+------------+--------------------------+--------------------
  1 | public        | disttable       | _timescaledb_internal  | _hyper_1                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  2 | public        | underreplicated | _timescaledb_internal  | _hyper_2                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  3 | Table\\Schema | Param_Table     | T3sTSch                | test*pre_               |              2 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
(3 rows)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  3 |             3 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  4 |             3 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(4 rows)

SELECT t.tgname, t.tgtype, t.tgfoid::regproc
FROM pg_trigger t, pg_class c WHERE c.relname = 'Param_Table' AND t.tgrelid = c.oid;
      tgname       | tgtype |                tgfoid                
-------------------+--------+--------------------------------------
 ts_insert_blocker |      7 | _timescaledb_internal.insert_blocker
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Test multi-dimensional hypertable (note that add_dimension is not currently propagated to backends)
CREATE TABLE dimented_table (time timestamptz, column1 int, column2 timestamptz, column3 int);
SELECT * FROM create_hypertable('dimented_table', 'time', partitioning_column => 'column1', number_partitions  => 4, replication_factor => 1, servers => '{ "server_1" }');
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name |   table_name   | created 
---------------+-------------+----------------+---------
             5 | public      | dimented_table | t
(1 row)

SELECT * FROM add_dimension('dimented_table', 'column2', chunk_time_interval => interval '1 week');
NOTICE:  adding not-null constraint to column "column2"
 dimension_id | schema_name |   table_name   | column_name | created 
--------------+-------------+----------------+-------------+---------
            8 | public      | dimented_table | column2     | t
(1 row)

SELECT * FROM add_dimension('dimented_table', 'column3', 4, partitioning_func => '_timescaledb_internal.get_partition_for_key');
 dimension_id | schema_name |   table_name   | column_name | created 
--------------+-------------+----------------+-------------+---------
            9 | public      | dimented_table | column3     | t
(1 row)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema |   partitioning_func   | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+-----------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  4 |             4 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  5 |             4 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  6 |             5 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  7 |             5 | column1          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  8 |             5 | column2          | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  9 |             5 | column3          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_for_key |                 |                         | 
(8 rows)

SELECT * FROM assign_server('dimented_table', 'server_2');
 assign_server 
---------------
 
(1 row)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema |   partitioning_func   | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+-----------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  4 |             4 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  5 |             4 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  6 |             5 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  7 |             5 | column1          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  8 |             5 | column2          | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  9 |             5 | column3          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_for_key |                 |                         | 
(8 rows)

\c server_1
-- Note that this didn't get the add_dimension
SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  3 |             3 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  4 |             3 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
  5 |             4 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  6 |             4 | column1          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(6 rows)

\c server_2
SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema |   partitioning_func   | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+-----------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  3 |             3 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  4 |             3 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  5 |             4 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  6 |             4 | column1          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  7 |             4 | column2          | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  8 |             4 | column3          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_for_key |                 |                         | 
(8 rows)

