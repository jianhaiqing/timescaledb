-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Need to be super user to create extension and add data nodes
\c :TEST_DBNAME :ROLE_SUPERUSER;
\ir include/remote_exec.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
CREATE SCHEMA IF NOT EXISTS test;
psql:include/remote_exec.sql:5: NOTICE:  schema "test" already exists, skipping
GRANT USAGE ON SCHEMA test TO PUBLIC;
CREATE OR REPLACE FUNCTION test.remote_exec(srv_name name[], command text)
RETURNS VOID
AS :TSL_MODULE_PATHNAME, 'ts_remote_exec'
LANGUAGE C;
-- Support for execute_sql_and_filter_data_node_name_on_error()
\unset ECHO
psql:include/filter_exec.sql:5: NOTICE:  schema "test" already exists, skipping
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Cleanup from other potential tests that created these databases
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS data_node_1;
DROP DATABASE IF EXISTS data_node_2;
DROP DATABASE IF EXISTS data_node_3;
SET client_min_messages TO NOTICE;
-- Add data nodes using the TimescaleDB node management API
SELECT * FROM add_data_node('data_node_1',
                            database => 'data_node_1',
                            bootstrap_user => :'ROLE_CLUSTER_SUPERUSER');
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_1 | localhost | 15432 | data_node_1 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_2',
                            database => 'data_node_2',
                            bootstrap_user => :'ROLE_CLUSTER_SUPERUSER');
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_2 | localhost | 15432 | data_node_2 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_3',
                            database => 'data_node_3',
                            bootstrap_user => :'ROLE_CLUSTER_SUPERUSER');
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_3 | localhost | 15432 | data_node_3 | t            | t                | t
(1 row)

-- Verify lack of tables
SELECT * FROM timescaledb_information.data_node;
  node_name  |        owner         |                    options                     | node_up | num_dist_tables | num_dist_chunks | total_dist_size 
-------------+----------------------+------------------------------------------------+---------+-----------------+-----------------+-----------------
 data_node_3 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_3} | t       |               0 |                 | 
 data_node_1 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_1} | t       |               0 |                 | 
 data_node_2 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_2} | t       |               0 |                 | 
(3 rows)

\set ON_ERROR_STOP 0
-- Test that one cannot directly create TimescaleDB foreign tables
CREATE FOREIGN TABLE foreign_table (time timestamptz, device int, temp float) SERVER data_node_1;
ERROR:  timescaledb foreign tables must be chunks
\set ON_ERROR_STOP 1
-- Create distributed hypertables. Add a trigger and primary key
-- constraint to test how those work
CREATE TABLE disttable(time timestamptz, device int CHECK (device > 0), color int, temp float, PRIMARY KEY (time,device));
-- Test setting num_partitions lower than the number of servers
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device', 1);
WARNING:  the number of partitions in dimension "device" is too low to make use of all attached data nodes
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             1 | public      | disttable  | t
(1 row)

-- Increase the number of partitions. Expect warning since still too low
SELECT * FROM set_number_partitions('disttable', 2);
WARNING:  the number of partitions in dimension "device" is too low to make use of all attached data nodes
 set_number_partitions 
-----------------------
 
(1 row)

-- Set number of partitions equal to the number of servers should not
-- raise a warning.
SELECT * FROM set_number_partitions('disttable', 3, 'device');
 set_number_partitions 
-----------------------
 
(1 row)

-- Show the number of slices
SELECT h.table_name, d.column_name, d.num_slices
FROM _timescaledb_catalog.hypertable h, _timescaledb_catalog.dimension d
WHERE h.id = d.hypertable_id
AND h.table_name = 'disttable';
 table_name | column_name | num_slices 
------------+-------------+------------
 disttable  | device      |          3
 disttable  | time        |           
(2 rows)

-- This table tests both 1-dimensional tables and under-replication
-- (replication_factor > num_data_nodes).
CREATE TABLE underreplicated(time timestamptz, device int, temp float);
SELECT * FROM create_hypertable('underreplicated', 'time', replication_factor => 4);
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name |   table_name    | created 
---------------+-------------+-----------------+---------
             2 | public      | underreplicated | t
(1 row)

SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE OR REPLACE FUNCTION test_trigger()
    RETURNS TRIGGER LANGUAGE PLPGSQL AS
$BODY$
DECLARE
    cnt INTEGER;
BEGIN
    SELECT count(*) INTO cnt FROM hyper;
    RAISE WARNING 'FIRING trigger when: % level: % op: % cnt: % trigger_name %',
        tg_when, tg_level, tg_op, cnt, tg_name;

    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    END IF;
    RETURN NEW;
END
$BODY$;
CREATE TRIGGER _0_test_trigger_insert
    BEFORE INSERT ON disttable
    FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             1 |                  1 | data_node_1 | f
             1 |                  1 | data_node_2 | f
             1 |                  1 | data_node_3 | f
             2 |                  2 | data_node_1 | f
             2 |                  2 | data_node_2 | f
             2 |                  2 | data_node_3 | f
(6 rows)

SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id | node_name 
----------+---------------+-----------
(0 rows)

-- The constraints, indexes, and triggers on the hypertable
SELECT * FROM test.show_constraints('disttable');
       Constraint       | Type |    Columns    |     Index      |     Expr     | Deferrable | Deferred | Validated 
------------------------+------+---------------+----------------+--------------+------------+----------+-----------
 disttable_device_check | c    | {device}      | -              | (device > 0) | f          | f        | t
 disttable_pkey         | p    | {time,device} | disttable_pkey |              | f          | f        | t
(2 rows)

SELECT * FROM test.show_indexes('disttable');
           Index           |    Columns    | Expr | Unique | Primary | Exclusion | Tablespace 
---------------------------+---------------+------+--------+---------+-----------+------------
 disttable_device_time_idx | {device,time} |      | f      | f       | f         | 
 disttable_pkey            | {time,device} |      | t      | t       | f         | 
 disttable_time_idx        | {time}        |      | f      | f       | f         | 
(3 rows)

SELECT * FROM test.show_triggers('disttable');
        Trigger         | Type |               Function               
------------------------+------+--------------------------------------
 _0_test_trigger_insert |    7 | test_trigger
 ts_insert_blocker      |    7 | _timescaledb_internal.insert_blocker
(2 rows)

-- Drop a column. This will make the attribute numbers of the
-- hypertable's root relation differ from newly created chunks. It is
-- a way to test that we properly handle attributed conversion between
-- the root table and chunks
ALTER TABLE disttable DROP COLUMN color;
-- EXPLAIN some inserts to see what plans and explain output for
-- remote inserts look like
EXPLAIN (COSTS FALSE)
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1);
                  QUERY PLAN                   
-----------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable disttable
   ->  Insert on disttable
         ->  Custom Scan (DataNodeDispatch)
               Batch size: 1000
               ->  Custom Scan (ChunkDispatch)
                     ->  Result
(7 rows)

EXPLAIN (VERBOSE, COSTS FALSE)
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1);
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable public.disttable
   Data nodes: data_node_1, data_node_2, data_node_3
   ->  Insert on public.disttable
         ->  Custom Scan (DataNodeDispatch)
               Output: 'Sun Jan 01 06:01:00 2017 PST'::timestamp with time zone, 1, NULL::integer, '1.1'::double precision
               Batch size: 1000
               Remote SQL: INSERT INTO public.disttable("time", device, temp) VALUES ($1, $2, $3), ..., ($2998, $2999, $3000)
               ->  Custom Scan (ChunkDispatch)
                     Output: 'Sun Jan 01 06:01:00 2017 PST'::timestamp with time zone, 1, NULL::integer, '1.1'::double precision
                     ->  Result
                           Output: 'Sun Jan 01 06:01:00 2017 PST'::timestamp with time zone, 1, NULL::integer, '1.1'::double precision
(12 rows)

-- Create some chunks through insertion
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1),
       ('2017-01-01 09:11', 3, 2.1),
       ('2017-01-01 08:01', 1, 1.2),
       ('2017-01-02 08:01', 2, 1.3),
       ('2018-07-02 08:01', 87, 1.6),
       ('2018-07-01 06:01', 13, 1.4),
       ('2018-07-01 09:11', 90, 2.7),
       ('2018-07-01 08:01', 29, 1.5);
\set ON_ERROR_STOP 0
-- VACUUM currently not supported. A VACCUM cannot run in a
-- transaction block so we need to distribute the command to data
-- nodes using "raw" connections.
VACUUM ANALYZE disttable;
VACUUM FULL disttable;
ERROR:  operation not supported on distributed hypertable
VACUUM disttable;
ERROR:  operation not supported on distributed hypertable
\set ON_ERROR_STOP 1
-- Test ANALYZE. First show no statistics
SELECT relname, relkind, reltuples, relpages
FROM pg_class
WHERE oid = 'disttable'::regclass;
  relname  | relkind | reltuples | relpages 
-----------+---------+-----------+----------
 disttable | r       |         0 |        0
(1 row)

SELECT relname, relkind, reltuples, relpages
FROM pg_class cl, (SELECT show_chunks AS chunk FROM show_chunks('disttable')) ch
WHERE cl.oid = ch.chunk::regclass;
        relname        | relkind | reltuples | relpages 
-----------------------+---------+-----------+----------
 _hyper_1_1_dist_chunk | f       |         0 |        0
 _hyper_1_2_dist_chunk | f       |         0 |        0
 _hyper_1_3_dist_chunk | f       |         0 |        0
 _hyper_1_4_dist_chunk | f       |         0 |        0
 _hyper_1_5_dist_chunk | f       |         0 |        0
 _hyper_1_6_dist_chunk | f       |         0 |        0
(6 rows)

ANALYZE disttable;
-- Show updated statistics
SELECT relname, relkind, reltuples, relpages
FROM pg_class
WHERE oid = 'disttable'::regclass;
  relname  | relkind | reltuples | relpages 
-----------+---------+-----------+----------
 disttable | r       |         0 |        0
(1 row)

SELECT relname, relkind, reltuples, relpages
FROM pg_class cl, (SELECT show_chunks AS chunk FROM show_chunks('disttable')) ch
WHERE cl.oid = ch.chunk::regclass;
        relname        | relkind | reltuples | relpages 
-----------------------+---------+-----------+----------
 _hyper_1_1_dist_chunk | f       |         2 |        1
 _hyper_1_2_dist_chunk | f       |         1 |        1
 _hyper_1_3_dist_chunk | f       |         1 |        1
 _hyper_1_4_dist_chunk | f       |         1 |        1
 _hyper_1_5_dist_chunk | f       |         1 |        1
 _hyper_1_6_dist_chunk | f       |         2 |        1
(6 rows)

-- Test prepared statement
PREPARE dist_insert (timestamptz, int, float) AS
INSERT INTO disttable VALUES ($1, $2, $3);
EXECUTE dist_insert ('2017-01-01 06:05', 1, 1.4);
-- Show chunks created
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                                           slices                                            
----------+---------------+-----------------------+-----------------------+---------+---------------------------------------------------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_1_dist_chunk | f       | {"time": [1482969600000000, 1483574400000000], "device": [-9223372036854775808, 715827882]}
        2 |             1 | _timescaledb_internal | _hyper_1_2_dist_chunk | f       | {"time": [1482969600000000, 1483574400000000], "device": [1431655764, 9223372036854775807]}
        3 |             1 | _timescaledb_internal | _hyper_1_3_dist_chunk | f       | {"time": [1482969600000000, 1483574400000000], "device": [715827882, 1431655764]}
        4 |             1 | _timescaledb_internal | _hyper_1_4_dist_chunk | f       | {"time": [1530144000000000, 1530748800000000], "device": [-9223372036854775808, 715827882]}
        5 |             1 | _timescaledb_internal | _hyper_1_5_dist_chunk | f       | {"time": [1530144000000000, 1530748800000000], "device": [715827882, 1431655764]}
        6 |             1 | _timescaledb_internal | _hyper_1_6_dist_chunk | f       | {"time": [1530144000000000, 1530748800000000], "device": [1431655764, 9223372036854775807]}
(6 rows)

-- Show that there are assigned node_chunk_id:s in chunk data node mappings
SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id |  node_name  
----------+---------------+-------------
        1 |             1 | data_node_1
        2 |             1 | data_node_3
        3 |             1 | data_node_2
        4 |             2 | data_node_1
        5 |             2 | data_node_2
        6 |             2 | data_node_3
(6 rows)

-- Show that chunks are created on data nodes and that each data node
-- has their own unique slice in the space (device) dimension.
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
$$);
NOTICE:  [data_node_1]: 
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable')
NOTICE:  [data_node_1]:
chunk_id|hypertable_id|schema_name          |table_name           |relkind|slices                                                                                     
--------+-------------+---------------------+---------------------+-------+-------------------------------------------------------------------------------------------
       1|            1|_timescaledb_internal|_hyper_1_1_dist_chunk|r      |{"time": [1482969600000000, 1483574400000000], "device": [-9223372036854775808, 715827882]}
       2|            1|_timescaledb_internal|_hyper_1_4_dist_chunk|r      |{"time": [1530144000000000, 1530748800000000], "device": [-9223372036854775808, 715827882]}
(2 rows)


NOTICE:  [data_node_2]: 
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable')
NOTICE:  [data_node_2]:
chunk_id|hypertable_id|schema_name          |table_name           |relkind|slices                                                                           
--------+-------------+---------------------+---------------------+-------+---------------------------------------------------------------------------------
       1|            1|_timescaledb_internal|_hyper_1_3_dist_chunk|r      |{"time": [1482969600000000, 1483574400000000], "device": [715827882, 1431655764]}
       2|            1|_timescaledb_internal|_hyper_1_5_dist_chunk|r      |{"time": [1530144000000000, 1530748800000000], "device": [715827882, 1431655764]}
(2 rows)


NOTICE:  [data_node_3]: 
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable')
NOTICE:  [data_node_3]:
chunk_id|hypertable_id|schema_name          |table_name           |relkind|slices                                                                                     
--------+-------------+---------------------+---------------------+-------+-------------------------------------------------------------------------------------------
       1|            1|_timescaledb_internal|_hyper_1_2_dist_chunk|r      |{"time": [1482969600000000, 1483574400000000], "device": [1431655764, 9223372036854775807]}
       2|            1|_timescaledb_internal|_hyper_1_6_dist_chunk|r      |{"time": [1530144000000000, 1530748800000000], "device": [1431655764, 9223372036854775807]}
(2 rows)


 remote_exec 
-------------
 
(1 row)

SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT * FROM disttable;
$$);
NOTICE:  [data_node_1]: 
SELECT * FROM disttable
NOTICE:  [data_node_1]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
Sun Jan 01 08:01:00 2017 PST|     1| 1.2
Sun Jan 01 06:05:00 2017 PST|     1| 1.4
Mon Jul 02 08:01:00 2018 PDT|    87| 1.6
(4 rows)


NOTICE:  [data_node_2]: 
SELECT * FROM disttable
NOTICE:  [data_node_2]:
time                        |device|temp
----------------------------+------+----
Mon Jan 02 08:01:00 2017 PST|     2| 1.3
Sun Jul 01 06:01:00 2018 PDT|    13| 1.4
(2 rows)


NOTICE:  [data_node_3]: 
SELECT * FROM disttable
NOTICE:  [data_node_3]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 09:11:00 2017 PST|     3| 2.1
Sun Jul 01 09:11:00 2018 PDT|    90| 2.7
Sun Jul 01 08:01:00 2018 PDT|    29| 1.5
(3 rows)


 remote_exec 
-------------
 
(1 row)

SELECT * FROM timescaledb_information.data_node;
  node_name  |        owner         |                    options                     | node_up | num_dist_tables | num_dist_chunks | total_dist_size 
-------------+----------------------+------------------------------------------------+---------+-----------------+-----------------+-----------------
 data_node_3 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_3} | t       |               2 |               2 | 112 kB
 data_node_1 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_1} | t       |               2 |               2 | 112 kB
 data_node_2 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_2} | t       |               2 |               2 | 112 kB
(3 rows)

SELECT * FROM hypertable_data_node_relation_size('disttable');
  node_name  | num_chunks | table_size | index_size | toast_size | total_size 
-------------+------------+------------+------------+------------+------------
 data_node_3 |          2 | 16 kB      | 96 kB      |            | 112 kB
 data_node_1 |          2 | 16 kB      | 96 kB      |            | 112 kB
 data_node_2 |          2 | 16 kB      | 96 kB      |            | 112 kB
(3 rows)

-- Show what some queries would look like on the frontend
EXPLAIN (VERBOSE, COSTS FALSE)
SELECT * FROM disttable;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Append
   ->  Custom Scan (DataNodeScan) on public.disttable
         Output: disttable."time", disttable.device, disttable.temp
         Data node: data_node_1
         Chunks: _hyper_1_1_dist_chunk, _hyper_1_4_dist_chunk
         Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1, 2])
   ->  Custom Scan (DataNodeScan) on public.disttable disttable_1
         Output: disttable_1."time", disttable_1.device, disttable_1.temp
         Data node: data_node_2
         Chunks: _hyper_1_3_dist_chunk, _hyper_1_5_dist_chunk
         Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1, 2])
   ->  Custom Scan (DataNodeScan) on public.disttable disttable_2
         Output: disttable_2."time", disttable_2.device, disttable_2.temp
         Data node: data_node_3
         Chunks: _hyper_1_2_dist_chunk, _hyper_1_6_dist_chunk
         Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1, 2])
(16 rows)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4
 Mon Jul 02 08:01:00 2018 PDT |     87 |  1.6
 Mon Jan 02 08:01:00 2017 PST |      2 |  1.3
 Sun Jul 01 06:01:00 2018 PDT |     13 |  1.4
 Sun Jan 01 09:11:00 2017 PST |      3 |  2.1
 Sun Jul 01 09:11:00 2018 PDT |     90 |  2.7
 Sun Jul 01 08:01:00 2018 PDT |     29 |  1.5
(9 rows)

EXPLAIN (VERBOSE, COSTS FALSE)
SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable GROUP BY 1, 2
ORDER BY 1;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (time_bucket('@ 3 hours'::interval, disttable."time")), disttable.device, avg(disttable.temp)
   Group Key: (time_bucket('@ 3 hours'::interval, disttable."time")), disttable.device
   ->  Merge Append
         Sort Key: (time_bucket('@ 3 hours'::interval, disttable."time")), disttable.device
         ->  Custom Scan (DataNodeScan) on public.disttable
               Output: time_bucket('@ 3 hours'::interval, disttable."time"), disttable.device, disttable.temp
               Data node: data_node_1
               Chunks: _hyper_1_1_dist_chunk, _hyper_1_4_dist_chunk
               Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1, 2]) ORDER BY public.time_bucket('03:00:00'::interval, "time") ASC NULLS LAST, device ASC NULLS LAST
         ->  Custom Scan (DataNodeScan) on public.disttable disttable_1
               Output: time_bucket('@ 3 hours'::interval, disttable_1."time"), disttable_1.device, disttable_1.temp
               Data node: data_node_2
               Chunks: _hyper_1_3_dist_chunk, _hyper_1_5_dist_chunk
               Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1, 2]) ORDER BY public.time_bucket('03:00:00'::interval, "time") ASC NULLS LAST, device ASC NULLS LAST
         ->  Custom Scan (DataNodeScan) on public.disttable disttable_2
               Output: time_bucket('@ 3 hours'::interval, disttable_2."time"), disttable_2.device, disttable_2.temp
               Data node: data_node_3
               Chunks: _hyper_1_2_dist_chunk, _hyper_1_6_dist_chunk
               Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1, 2]) ORDER BY public.time_bucket('03:00:00'::interval, "time") ASC NULLS LAST, device ASC NULLS LAST
(20 rows)

-- Execute some queries on the frontend and return the results
SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4
 Mon Jul 02 08:01:00 2018 PDT |     87 |  1.6
 Mon Jan 02 08:01:00 2017 PST |      2 |  1.3
 Sun Jul 01 06:01:00 2018 PDT |     13 |  1.4
 Sun Jan 01 09:11:00 2017 PST |      3 |  2.1
 Sun Jul 01 09:11:00 2018 PDT |     90 |  2.7
 Sun Jul 01 08:01:00 2018 PDT |     29 |  1.5
(9 rows)

SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable
GROUP BY 1, 2
ORDER BY 1;
             time             | device | avg_temp 
------------------------------+--------+----------
 Sun Jan 01 04:00:00 2017 PST |      1 |     1.25
 Sun Jan 01 07:00:00 2017 PST |      1 |      1.2
 Sun Jan 01 07:00:00 2017 PST |      3 |      2.1
 Mon Jan 02 07:00:00 2017 PST |      2 |      1.3
 Sun Jul 01 05:00:00 2018 PDT |     13 |      1.4
 Sun Jul 01 08:00:00 2018 PDT |     29 |      1.5
 Sun Jul 01 08:00:00 2018 PDT |     90 |      2.7
 Mon Jul 02 08:00:00 2018 PDT |     87 |      1.6
(8 rows)

SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable GROUP BY 1, 2
HAVING avg(temp) > 1.2
ORDER BY 1;
             time             | device | avg_temp 
------------------------------+--------+----------
 Sun Jan 01 04:00:00 2017 PST |      1 |     1.25
 Sun Jan 01 07:00:00 2017 PST |      3 |      2.1
 Mon Jan 02 07:00:00 2017 PST |      2 |      1.3
 Sun Jul 01 05:00:00 2018 PDT |     13 |      1.4
 Sun Jul 01 08:00:00 2018 PDT |     29 |      1.5
 Sun Jul 01 08:00:00 2018 PDT |     90 |      2.7
 Mon Jul 02 08:00:00 2018 PDT |     87 |      1.6
(7 rows)

SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable
WHERE temp > 2
GROUP BY 1, 2
HAVING avg(temp) > 1.2
ORDER BY 1;
             time             | device | avg_temp 
------------------------------+--------+----------
 Sun Jan 01 07:00:00 2017 PST |      3 |      2.1
 Sun Jul 01 08:00:00 2018 PDT |     90 |      2.7
(2 rows)

-- The constraints, indexes, and triggers on foreign chunks. Only
-- check constraints should recurse to foreign chunks (although they
-- aren't enforced on a foreign table)
SELECT st."Child" as chunk_relid, test.show_constraints((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |                                                                                   show_constraints                                                                                   
---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (constraint_2,c,{device},-,"(_timescaledb_internal.get_partition_hash(device) < 715827882)",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (constraint_3,c,{device},-,"(_timescaledb_internal.get_partition_hash(device) >= 1431655764)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (constraint_4,c,{device},-,"((_timescaledb_internal.get_partition_hash(device) >= 715827882) AND (_timescaledb_internal.get_partition_hash(device) < 1431655764))",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_4_dist_chunk | (constraint_2,c,{device},-,"(_timescaledb_internal.get_partition_hash(device) < 715827882)",f,f,t)
 _timescaledb_internal._hyper_1_4_dist_chunk | (constraint_5,c,{time},-,"((""time"" >= 'Wed Jun 27 17:00:00 2018 PDT'::timestamp with time zone) AND (""time"" < 'Wed Jul 04 17:00:00 2018 PDT'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_4_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_5_dist_chunk | (constraint_4,c,{device},-,"((_timescaledb_internal.get_partition_hash(device) >= 715827882) AND (_timescaledb_internal.get_partition_hash(device) < 1431655764))",f,f,t)
 _timescaledb_internal._hyper_1_5_dist_chunk | (constraint_5,c,{time},-,"((""time"" >= 'Wed Jun 27 17:00:00 2018 PDT'::timestamp with time zone) AND (""time"" < 'Wed Jul 04 17:00:00 2018 PDT'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_5_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_6_dist_chunk | (constraint_3,c,{device},-,"(_timescaledb_internal.get_partition_hash(device) >= 1431655764)",f,f,t)
 _timescaledb_internal._hyper_1_6_dist_chunk | (constraint_5,c,{time},-,"((""time"" >= 'Wed Jun 27 17:00:00 2018 PDT'::timestamp with time zone) AND (""time"" < 'Wed Jul 04 17:00:00 2018 PDT'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_6_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
(18 rows)

SELECT st."Child" as chunk_relid, test.show_indexes((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_indexes 
-------------+--------------
(0 rows)

SELECT st."Child" as chunk_relid, test.show_triggers((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_triggers 
-------------+---------------
(0 rows)

-- Check that the chunks are assigned data nodes
SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id |  node_name  
----------+---------------+-------------
        1 |             1 | data_node_1
        2 |             1 | data_node_3
        3 |             1 | data_node_2
        4 |             2 | data_node_1
        5 |             2 | data_node_2
        6 |             2 | data_node_3
(6 rows)

-- Adding a new trigger should not recurse to foreign chunks
CREATE TRIGGER _1_test_trigger_insert
    AFTER INSERT ON disttable
    FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT st."Child" as chunk_relid, test.show_triggers((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_triggers 
-------------+---------------
(0 rows)

-- Check that we can create indexes on distributed hypertables and
-- that they don't recurse to foreign chunks
CREATE INDEX ON disttable (time, device);
SELECT * FROM test.show_indexes('disttable');
           Index           |    Columns    | Expr | Unique | Primary | Exclusion | Tablespace 
---------------------------+---------------+------+--------+---------+-----------+------------
 disttable_device_time_idx | {device,time} |      | f      | f       | f         | 
 disttable_pkey            | {time,device} |      | t      | t       | f         | 
 disttable_time_device_idx | {time,device} |      | f      | f       | f         | 
 disttable_time_idx        | {time}        |      | f      | f       | f         | 
(4 rows)

SELECT st."Child" as chunk_relid, test.show_indexes((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_indexes 
-------------+--------------
(0 rows)

-- No index mappings should exist either
SELECT * FROM _timescaledb_catalog.chunk_index;
 chunk_id | index_name | hypertable_id | hypertable_index_name 
----------+------------+---------------+-----------------------
(0 rows)

-- Check that creating columns work
ALTER TABLE disttable ADD COLUMN "Color" int;
SELECT * FROM test.show_columns('disttable');
 Column |           Type           | NotNull 
--------+--------------------------+---------
 time   | timestamp with time zone | t
 device | integer                  | t
 temp   | double precision         | f
 Color  | integer                  | f
(4 rows)

SELECT st."Child" as chunk_relid, test.show_columns((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |            show_columns             
---------------------------------------------+-------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (device,integer,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_1_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (device,integer,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (device,integer,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_4_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_4_dist_chunk | (device,integer,t)
 _timescaledb_internal._hyper_1_4_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_4_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_5_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_5_dist_chunk | (device,integer,t)
 _timescaledb_internal._hyper_1_5_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_5_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_6_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_6_dist_chunk | (device,integer,t)
 _timescaledb_internal._hyper_1_6_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_6_dist_chunk | (Color,integer,f)
(24 rows)

-- Adding a new unique constraint should not recurse to foreign
-- chunks, but a check constraint should
ALTER TABLE disttable ADD CONSTRAINT disttable_color_unique UNIQUE (time, device, "Color");
ALTER TABLE disttable ADD CONSTRAINT disttable_temp_non_negative CHECK (temp > 0.0);
SELECT st."Child" as chunk_relid, test.show_constraints((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |                                                                                   show_constraints                                                                                   
---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (constraint_2,c,{device},-,"(_timescaledb_internal.get_partition_hash(device) < 715827882)",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (constraint_3,c,{device},-,"(_timescaledb_internal.get_partition_hash(device) >= 1431655764)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (constraint_4,c,{device},-,"((_timescaledb_internal.get_partition_hash(device) >= 715827882) AND (_timescaledb_internal.get_partition_hash(device) < 1431655764))",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_4_dist_chunk | (constraint_2,c,{device},-,"(_timescaledb_internal.get_partition_hash(device) < 715827882)",f,f,t)
 _timescaledb_internal._hyper_1_4_dist_chunk | (constraint_5,c,{time},-,"((""time"" >= 'Wed Jun 27 17:00:00 2018 PDT'::timestamp with time zone) AND (""time"" < 'Wed Jul 04 17:00:00 2018 PDT'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_4_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_4_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_5_dist_chunk | (constraint_4,c,{device},-,"((_timescaledb_internal.get_partition_hash(device) >= 715827882) AND (_timescaledb_internal.get_partition_hash(device) < 1431655764))",f,f,t)
 _timescaledb_internal._hyper_1_5_dist_chunk | (constraint_5,c,{time},-,"((""time"" >= 'Wed Jun 27 17:00:00 2018 PDT'::timestamp with time zone) AND (""time"" < 'Wed Jul 04 17:00:00 2018 PDT'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_5_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_5_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_6_dist_chunk | (constraint_3,c,{device},-,"(_timescaledb_internal.get_partition_hash(device) >= 1431655764)",f,f,t)
 _timescaledb_internal._hyper_1_6_dist_chunk | (constraint_5,c,{time},-,"((""time"" >= 'Wed Jun 27 17:00:00 2018 PDT'::timestamp with time zone) AND (""time"" < 'Wed Jul 04 17:00:00 2018 PDT'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_6_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_6_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
(24 rows)

SELECT cc.*
FROM (SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
      FROM show_chunks('disttable')) c,
      _timescaledb_catalog.chunk_constraint cc
WHERE c.chunk_id = cc.chunk_id;
 chunk_id | dimension_slice_id | constraint_name | hypertable_constraint_name 
----------+--------------------+-----------------+----------------------------
        1 |                  2 | constraint_2    | 
        1 |                  1 | constraint_1    | 
        2 |                  3 | constraint_3    | 
        2 |                  1 | constraint_1    | 
        3 |                  4 | constraint_4    | 
        3 |                  1 | constraint_1    | 
        4 |                  2 | constraint_2    | 
        4 |                  5 | constraint_5    | 
        5 |                  4 | constraint_4    | 
        5 |                  5 | constraint_5    | 
        6 |                  3 | constraint_3    | 
        6 |                  5 | constraint_5    | 
(12 rows)

-- Show contents after re-adding column
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4 |      
 Mon Jul 02 08:01:00 2018 PDT |     87 |  1.6 |      
 Mon Jan 02 08:01:00 2017 PST |      2 |  1.3 |      
 Sun Jul 01 06:01:00 2018 PDT |     13 |  1.4 |      
 Sun Jan 01 09:11:00 2017 PST |      3 |  2.1 |      
 Sun Jul 01 09:11:00 2018 PDT |     90 |  2.7 |      
 Sun Jul 01 08:01:00 2018 PDT |     29 |  1.5 |      
(9 rows)

-- Test INSERTS with RETURNING. Since we previously dropped a column
-- on the hypertable, this also tests that we handle conversion of the
-- attribute numbers in the RETURNING clause, since they now differ
-- between the hypertable root relation and the chunk currently
-- RETURNING from.
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-02 06:09', 4, 1, 9.8)
RETURNING time, "Color", temp;
             time             | Color | temp 
------------------------------+-------+------
 Sat Sep 02 06:09:00 2017 PDT |     1 |  9.8
(1 row)

INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-03 06:18', 9, 3, 8.7)
RETURNING 1;
 ?column? 
----------
        1
(1 row)

-- On conflict
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-02 06:09', 6, 2, 10.5)
ON CONFLICT DO NOTHING;
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
$$);
NOTICE:  [data_node_1]: 
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable')
NOTICE:  [data_node_1]:
chunk_id|hypertable_id|schema_name          |table_name           |relkind|slices                                                                                     
--------+-------------+---------------------+---------------------+-------+-------------------------------------------------------------------------------------------
       1|            1|_timescaledb_internal|_hyper_1_1_dist_chunk|r      |{"time": [1482969600000000, 1483574400000000], "device": [-9223372036854775808, 715827882]}
       2|            1|_timescaledb_internal|_hyper_1_4_dist_chunk|r      |{"time": [1530144000000000, 1530748800000000], "device": [-9223372036854775808, 715827882]}
       3|            1|_timescaledb_internal|_hyper_1_9_dist_chunk|r      |{"time": [1504137600000000, 1504742400000000], "device": [-9223372036854775808, 715827882]}
(3 rows)


NOTICE:  [data_node_2]: 
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable')
NOTICE:  [data_node_2]:
chunk_id|hypertable_id|schema_name          |table_name           |relkind|slices                                                                           
--------+-------------+---------------------+---------------------+-------+---------------------------------------------------------------------------------
       1|            1|_timescaledb_internal|_hyper_1_3_dist_chunk|r      |{"time": [1482969600000000, 1483574400000000], "device": [715827882, 1431655764]}
       2|            1|_timescaledb_internal|_hyper_1_5_dist_chunk|r      |{"time": [1530144000000000, 1530748800000000], "device": [715827882, 1431655764]}
       3|            1|_timescaledb_internal|_hyper_1_7_dist_chunk|r      |{"time": [1504137600000000, 1504742400000000], "device": [715827882, 1431655764]}
(3 rows)


NOTICE:  [data_node_3]: 
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable')
NOTICE:  [data_node_3]:
chunk_id|hypertable_id|schema_name          |table_name           |relkind|slices                                                                                     
--------+-------------+---------------------+---------------------+-------+-------------------------------------------------------------------------------------------
       1|            1|_timescaledb_internal|_hyper_1_2_dist_chunk|r      |{"time": [1482969600000000, 1483574400000000], "device": [1431655764, 9223372036854775807]}
       2|            1|_timescaledb_internal|_hyper_1_6_dist_chunk|r      |{"time": [1530144000000000, 1530748800000000], "device": [1431655764, 9223372036854775807]}
       3|            1|_timescaledb_internal|_hyper_1_8_dist_chunk|r      |{"time": [1504137600000000, 1504742400000000], "device": [1431655764, 9223372036854775807]}
(3 rows)


 remote_exec 
-------------
 
(1 row)

-- Show new row and that conflicting row is not inserted
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT * FROM disttable;
$$);
NOTICE:  [data_node_1]: 
SELECT * FROM disttable
NOTICE:  [data_node_1]:
time                        |device|temp|Color
----------------------------+------+----+-----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1|     
Sun Jan 01 08:01:00 2017 PST|     1| 1.2|     
Sun Jan 01 06:05:00 2017 PST|     1| 1.4|     
Mon Jul 02 08:01:00 2018 PDT|    87| 1.6|     
Sat Sep 02 06:09:00 2017 PDT|     6|10.5|    2
(5 rows)


NOTICE:  [data_node_2]: 
SELECT * FROM disttable
NOTICE:  [data_node_2]:
time                        |device|temp|Color
----------------------------+------+----+-----
Mon Jan 02 08:01:00 2017 PST|     2| 1.3|     
Sun Jul 01 06:01:00 2018 PDT|    13| 1.4|     
Sat Sep 02 06:09:00 2017 PDT|     4| 9.8|    1
(3 rows)


NOTICE:  [data_node_3]: 
SELECT * FROM disttable
NOTICE:  [data_node_3]:
time                        |device|temp|Color
----------------------------+------+----+-----
Sun Jan 01 09:11:00 2017 PST|     3| 2.1|     
Sun Jul 01 09:11:00 2018 PDT|    90| 2.7|     
Sun Jul 01 08:01:00 2018 PDT|    29| 1.5|     
Sun Sep 03 06:18:00 2017 PDT|     9| 8.7|    3
(4 rows)


 remote_exec 
-------------
 
(1 row)

\set ON_ERROR_STOP 0
-- ON CONFLICT only works with DO NOTHING
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-09 08:13', 7, 3, 27.5)
ON CONFLICT (time) DO UPDATE SET temp = 3.2;
ERROR:  unexpected ON CONFLICT specification: 2
-- Test that an INSERT that would create a chunk does not work on a
-- data node
SELECT * FROM test.remote_exec('{ data_node_1 }',
$$
    INSERT INTO disttable VALUES ('2019-01-02 12:34', 1, 2, 9.3)
$$);
NOTICE:  [data_node_1]: 
    INSERT INTO disttable VALUES ('2019-01-02 12:34', 1, 2, 9.3)

ERROR:  [data_node_1]: cannot create chunk on distributed hypertable member
\set ON_ERROR_STOP 1
-- However, INSERTs on a data node that does not create a chunk works.
SELECT * FROM test.remote_exec('{ data_node_1 }',
$$
    INSERT INTO disttable VALUES ('2017-09-03 06:09', 1, 2, 9.3)
$$);
NOTICE:  [data_node_1]: 
    INSERT INTO disttable VALUES ('2017-09-03 06:09', 1, 2, 9.3)

 remote_exec 
-------------
 
(1 row)

-- Test updates
UPDATE disttable SET "Color" = 4 WHERE "Color" = 3;
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4 |      
 Mon Jul 02 08:01:00 2018 PDT |     87 |  1.6 |      
 Sat Sep 02 06:09:00 2017 PDT |      6 | 10.5 |     2
 Sun Sep 03 06:09:00 2017 PDT |      1 |    2 |     9
 Mon Jan 02 08:01:00 2017 PST |      2 |  1.3 |      
 Sun Jul 01 06:01:00 2018 PDT |     13 |  1.4 |      
 Sat Sep 02 06:09:00 2017 PDT |      4 |  9.8 |     1
 Sun Jan 01 09:11:00 2017 PST |      3 |  2.1 |      
 Sun Jul 01 09:11:00 2018 PDT |     90 |  2.7 |      
 Sun Jul 01 08:01:00 2018 PDT |     29 |  1.5 |      
 Sun Sep 03 06:18:00 2017 PDT |      9 |  8.7 |     4
(13 rows)

WITH devices AS (
     SELECT DISTINCT device FROM disttable ORDER BY device
)
UPDATE disttable SET "Color" = 2 WHERE device = (SELECT device FROM devices LIMIT 1);
\set ON_ERROR_STOP 0
-- Updates referencing non-existing column
UPDATE disttable SET device = 4 WHERE no_such_column = 2;
ERROR:  column "no_such_column" does not exist at character 39
UPDATE disttable SET no_such_column = 4 WHERE device = 2;
ERROR:  column "no_such_column" of relation "disttable" does not exist at character 22
-- Update to system column
UPDATE disttable SET tableoid = 4 WHERE device = 2;
ERROR:  cannot assign to system column "tableoid" at character 22
\set ON_ERROR_STOP 1
-- Test deletes (no rows deleted)
DELETE FROM disttable WHERE device = 3
RETURNING *;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 09:11:00 2017 PST |      3 |  2.1 |      
(1 row)

-- Test deletes (rows deleted)
DELETE FROM disttable WHERE device = 4
RETURNING *;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sat Sep 02 06:09:00 2017 PDT |      4 |  9.8 |     1
(1 row)

-- Query to show that rows are deleted
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |     2
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |     2
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4 |     2
 Mon Jul 02 08:01:00 2018 PDT |     87 |  1.6 |      
 Sat Sep 02 06:09:00 2017 PDT |      6 | 10.5 |     2
 Sun Sep 03 06:09:00 2017 PDT |      1 |    2 |     2
 Mon Jan 02 08:01:00 2017 PST |      2 |  1.3 |      
 Sun Jul 01 06:01:00 2018 PDT |     13 |  1.4 |      
 Sun Jul 01 09:11:00 2018 PDT |     90 |  2.7 |      
 Sun Jul 01 08:01:00 2018 PDT |     29 |  1.5 |      
 Sun Sep 03 06:18:00 2017 PDT |      9 |  8.7 |     4
(11 rows)

-- Ensure rows are deleted on the data nodes
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT * FROM disttable;
$$);
NOTICE:  [data_node_1]: 
SELECT * FROM disttable
NOTICE:  [data_node_1]:
time                        |device|temp|Color
----------------------------+------+----+-----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1|    2
Sun Jan 01 08:01:00 2017 PST|     1| 1.2|    2
Sun Jan 01 06:05:00 2017 PST|     1| 1.4|    2
Mon Jul 02 08:01:00 2018 PDT|    87| 1.6|     
Sat Sep 02 06:09:00 2017 PDT|     6|10.5|    2
Sun Sep 03 06:09:00 2017 PDT|     1|   2|    2
(6 rows)


NOTICE:  [data_node_2]: 
SELECT * FROM disttable
NOTICE:  [data_node_2]:
time                        |device|temp|Color
----------------------------+------+----+-----
Mon Jan 02 08:01:00 2017 PST|     2| 1.3|     
Sun Jul 01 06:01:00 2018 PDT|    13| 1.4|     
(2 rows)


NOTICE:  [data_node_3]: 
SELECT * FROM disttable
NOTICE:  [data_node_3]:
time                        |device|temp|Color
----------------------------+------+----+-----
Sun Jul 01 09:11:00 2018 PDT|    90| 2.7|     
Sun Jul 01 08:01:00 2018 PDT|    29| 1.5|     
Sun Sep 03 06:18:00 2017 PDT|     9| 8.7|    4
(3 rows)


 remote_exec 
-------------
 
(1 row)

-- Test TRUNCATE
TRUNCATE disttable;
-- No data should remain
SELECT * FROM disttable;
 time | device | temp | Color 
------+--------+------+-------
(0 rows)

-- Metadata and tables cleaned up
SELECT * FROM _timescaledb_catalog.chunk;
 id | hypertable_id | schema_name | table_name | compressed_chunk_id | dropped 
----+---------------+-------------+------------+---------------------+---------
(0 rows)

SELECT * FROM show_chunks('disttable');
 show_chunks 
-------------
(0 rows)

-- Also cleaned up remotely
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT * FROM _timescaledb_catalog.chunk;
SELECT * FROM show_chunks('disttable');
SELECT * FROM disttable;
$$);
NOTICE:  [data_node_1]: 
SELECT * FROM _timescaledb_catalog.chunk
NOTICE:  [data_node_1]:
id|hypertable_id|schema_name|table_name|compressed_chunk_id|dropped
--+-------------+-----------+----------+-------------------+-------
(0 rows)


NOTICE:  [data_node_1]: 
SELECT * FROM show_chunks('disttable')
NOTICE:  [data_node_1]:
show_chunks
-----------
(0 rows)


NOTICE:  [data_node_1]: 
SELECT * FROM disttable
NOTICE:  [data_node_1]:
time|device|temp|Color
----+------+----+-----
(0 rows)


NOTICE:  [data_node_2]: 
SELECT * FROM _timescaledb_catalog.chunk
NOTICE:  [data_node_2]:
id|hypertable_id|schema_name|table_name|compressed_chunk_id|dropped
--+-------------+-----------+----------+-------------------+-------
(0 rows)


NOTICE:  [data_node_2]: 
SELECT * FROM show_chunks('disttable')
NOTICE:  [data_node_2]:
show_chunks
-----------
(0 rows)


NOTICE:  [data_node_2]: 
SELECT * FROM disttable
NOTICE:  [data_node_2]:
time|device|temp|Color
----+------+----+-----
(0 rows)


NOTICE:  [data_node_3]: 
SELECT * FROM _timescaledb_catalog.chunk
NOTICE:  [data_node_3]:
id|hypertable_id|schema_name|table_name|compressed_chunk_id|dropped
--+-------------+-----------+----------+-------------------+-------
(0 rows)


NOTICE:  [data_node_3]: 
SELECT * FROM show_chunks('disttable')
NOTICE:  [data_node_3]:
show_chunks
-----------
(0 rows)


NOTICE:  [data_node_3]: 
SELECT * FROM disttable
NOTICE:  [data_node_3]:
time|device|temp|Color
----+------+----+-----
(0 rows)


 remote_exec 
-------------
 
(1 row)

-- The hypertable view also shows no chunks and no data
SELECT * FROM timescaledb_information.hypertable;
 table_schema |   table_name    |     table_owner      | num_dimensions | num_chunks | table_size | index_size | toast_size | total_size | distributed 
--------------+-----------------+----------------------+----------------+------------+------------+------------+------------+------------+-------------
 public       | disttable       | default_cluster_user |              2 |          0 |            |            |            |            | t
 public       | underreplicated | default_cluster_user |              1 |          0 |            |            |            |            | t
(2 rows)

-- Test underreplicated chunk warning
INSERT INTO underreplicated VALUES ('2017-01-01 06:01', 1, 1.1),
                                   ('2017-01-02 07:01', 2, 3.5);
WARNING:  new chunks for hypertable "underreplicated" will be under-replicated due to insufficient available data nodes, lacks 1 data node(s)
SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id |  node_name  
----------+---------------+-------------
       10 |             4 | data_node_1
       10 |             4 | data_node_2
       10 |             4 | data_node_3
(3 rows)

SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
 chunk_id | hypertable_id |      schema_name      |       table_name       | relkind |                     slices                     
----------+---------------+-----------------------+------------------------+---------+------------------------------------------------
       10 |             2 | _timescaledb_internal | _hyper_2_10_dist_chunk | f       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

-- Show chunk data node mappings
SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id |  node_name  
----------+---------------+-------------
       10 |             4 | data_node_1
       10 |             4 | data_node_2
       10 |             4 | data_node_3
(3 rows)

-- Show that chunks are created on remote data nodes and that all
-- data nodes/chunks have the same data due to replication
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
$$);
NOTICE:  [data_node_1]: 
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated')
NOTICE:  [data_node_1]:
chunk_id|hypertable_id|schema_name          |table_name            |relkind|slices                                        
--------+-------------+---------------------+----------------------+-------+----------------------------------------------
       4|            2|_timescaledb_internal|_hyper_2_10_dist_chunk|r      |{"time": [1482969600000000, 1483574400000000]}
(1 row)


NOTICE:  [data_node_2]: 
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated')
NOTICE:  [data_node_2]:
chunk_id|hypertable_id|schema_name          |table_name            |relkind|slices                                        
--------+-------------+---------------------+----------------------+-------+----------------------------------------------
       4|            2|_timescaledb_internal|_hyper_2_10_dist_chunk|r      |{"time": [1482969600000000, 1483574400000000]}
(1 row)


NOTICE:  [data_node_3]: 
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated')
NOTICE:  [data_node_3]:
chunk_id|hypertable_id|schema_name          |table_name            |relkind|slices                                        
--------+-------------+---------------------+----------------------+-------+----------------------------------------------
       4|            2|_timescaledb_internal|_hyper_2_10_dist_chunk|r      |{"time": [1482969600000000, 1483574400000000]}
(1 row)


 remote_exec 
-------------
 
(1 row)

SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT * FROM underreplicated;
$$);
NOTICE:  [data_node_1]: 
SELECT * FROM underreplicated
NOTICE:  [data_node_1]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
Mon Jan 02 07:01:00 2017 PST|     2| 3.5
(2 rows)


NOTICE:  [data_node_2]: 
SELECT * FROM underreplicated
NOTICE:  [data_node_2]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
Mon Jan 02 07:01:00 2017 PST|     2| 3.5
(2 rows)


NOTICE:  [data_node_3]: 
SELECT * FROM underreplicated
NOTICE:  [data_node_3]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
Mon Jan 02 07:01:00 2017 PST|     2| 3.5
(2 rows)


 remote_exec 
-------------
 
(1 row)

-- Test updates
UPDATE underreplicated SET temp = 2.0 WHERE device = 2
RETURNING time, temp, device;
             time             | temp | device 
------------------------------+------+--------
 Mon Jan 02 07:01:00 2017 PST |    2 |      2
(1 row)

SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(2 rows)

-- Show that all replica chunks are updated
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT * FROM underreplicated;
$$);
NOTICE:  [data_node_1]: 
SELECT * FROM underreplicated
NOTICE:  [data_node_1]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
Mon Jan 02 07:01:00 2017 PST|     2|   2
(2 rows)


NOTICE:  [data_node_2]: 
SELECT * FROM underreplicated
NOTICE:  [data_node_2]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
Mon Jan 02 07:01:00 2017 PST|     2|   2
(2 rows)


NOTICE:  [data_node_3]: 
SELECT * FROM underreplicated
NOTICE:  [data_node_3]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
Mon Jan 02 07:01:00 2017 PST|     2|   2
(2 rows)


 remote_exec 
-------------
 
(1 row)

DELETE FROM underreplicated WHERE device = 2
RETURNING *;
             time             | device | temp 
------------------------------+--------+------
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(1 row)

-- Ensure deletes across all data nodes
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT * FROM underreplicated;
$$);
NOTICE:  [data_node_1]: 
SELECT * FROM underreplicated
NOTICE:  [data_node_1]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
(1 row)


NOTICE:  [data_node_2]: 
SELECT * FROM underreplicated
NOTICE:  [data_node_2]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
(1 row)


NOTICE:  [data_node_3]: 
SELECT * FROM underreplicated
NOTICE:  [data_node_3]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
(1 row)


 remote_exec 
-------------
 
(1 row)

-- Test hypertable creation fails on distributed error
SELECT * FROM test.remote_exec('{ data_node_3 }', $$
CREATE TABLE remotetable(time timestamptz PRIMARY KEY, id int, cost float);
SELECT * FROM underreplicated;
$$);
NOTICE:  [data_node_3]: 
CREATE TABLE remotetable(time timestamptz PRIMARY KEY, id int, cost float)
NOTICE:  [data_node_3]: 
SELECT * FROM underreplicated
NOTICE:  [data_node_3]:
time                        |device|temp
----------------------------+------+----
Sun Jan 01 06:01:00 2017 PST|     1| 1.1
(1 row)


 remote_exec 
-------------
 
(1 row)

\set ON_ERROR_STOP 0
CREATE TABLE remotetable(time timestamptz PRIMARY KEY, device int CHECK (device > 0), color int, temp float);
SELECT * FROM create_hypertable('remotetable', 'time', replication_factor => 1);
ERROR:  [data_node_3]: relation "remotetable" already exists
-- Test distributed_hypertable creation fails with replication factor 0
CREATE TABLE remotetable2(time timestamptz PRIMARY KEY, device int CHECK (device > 0), color int, temp float);
SELECT * FROM create_distributed_hypertable('remotetable2', 'time', replication_factor => 0);
ERROR:  invalid replication_factor
\set ON_ERROR_STOP 1
SELECT * FROM timescaledb_information.hypertable
ORDER BY table_schema, table_name;
 table_schema |   table_name    |     table_owner      | num_dimensions | num_chunks | table_size | index_size | toast_size | total_size | distributed 
--------------+-----------------+----------------------+----------------+------------+------------+------------+------------+------------+-------------
 public       | disttable       | default_cluster_user |              2 |          0 |            |            |            |            | t
 public       | underreplicated | default_cluster_user |              1 |          1 | 24 kB      | 48 kB      |            | 72 kB      | t
(2 rows)

-- Test distributed hypertable creation with many parameters
\c data_node_1
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
\c data_node_2
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
\c data_node_3
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\c :TEST_DBNAME :ROLE_SUPERUSER
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE TABLE "Table\\Schema"."Param_Table"("time Col %#^#@$#" timestamptz, __region text, reading float);
SELECT * FROM create_distributed_hypertable('"Table\\Schema"."Param_Table"', 'time Col %#^#@$#', partitioning_column => '__region',
associated_schema_name => 'T3sTSch', associated_table_prefix => 'test*pre_', chunk_time_interval => interval '1 week',
create_default_indexes => FALSE, if_not_exists => TRUE, migrate_data => TRUE, replication_factor => 2,
data_nodes => '{ "data_node_3" }');
NOTICE:  adding not-null constraint to column "time Col %#^#@$#"
 hypertable_id |  schema_name  | table_name  | created 
---------------+---------------+-------------+---------
             4 | Table\\Schema | Param_Table | t
(1 row)

-- Test attach_data_node. First show dimensions and currently attached
-- servers.  The number of slices in the space dimension should equal
-- the number of servers since we didn't explicitly specify
-- number_partitions
SELECT h.table_name, d.column_name, d.num_slices
FROM _timescaledb_catalog.hypertable h, _timescaledb_catalog.dimension d
WHERE h.id = d.hypertable_id
AND h.table_name = 'Param_Table'
ORDER BY 1, 2, 3;
 table_name  |   column_name    | num_slices 
-------------+------------------+------------
 Param_Table | __region         |          1
 Param_Table | time Col %#^#@$# |           
(2 rows)

SELECT h.table_name, hdn.node_name
FROM _timescaledb_catalog.hypertable h, _timescaledb_catalog.hypertable_data_node hdn
WHERE h.id = hdn.hypertable_id
AND h.table_name = 'Param_Table'
ORDER BY 1, 2;
 table_name  |  node_name  
-------------+-------------
 Param_Table | data_node_3
(1 row)

SELECT * FROM attach_data_node('data_node_1', '"Table\\Schema"."Param_Table"');
NOTICE:  the number of partitions in dimension "__region" was increased to 2
 hypertable_id | node_hypertable_id |  node_name  
---------------+--------------------+-------------
             4 |                  3 | data_node_1
(1 row)

-- Show updated metadata after attach
SELECT h.table_name, d.column_name, d.num_slices
FROM _timescaledb_catalog.hypertable h, _timescaledb_catalog.dimension d
WHERE h.id = d.hypertable_id
AND h.table_name = 'Param_Table'
ORDER BY 1, 2, 3;
 table_name  |   column_name    | num_slices 
-------------+------------------+------------
 Param_Table | __region         |          2
 Param_Table | time Col %#^#@$# |           
(2 rows)

SELECT h.table_name, hdn.node_name
FROM _timescaledb_catalog.hypertable h, _timescaledb_catalog.hypertable_data_node hdn
WHERE h.id = hdn.hypertable_id
AND h.table_name = 'Param_Table'
ORDER BY 1, 2;
 table_name  |  node_name  
-------------+-------------
 Param_Table | data_node_1
 Param_Table | data_node_3
(2 rows)

-- Attach another data node but do not auto-repartition, i.e.,
-- increase the number of slices.
SELECT * FROM attach_data_node('data_node_2', '"Table\\Schema"."Param_Table"', repartition => false);
WARNING:  the number of partitions in dimension "__region" is too low to make use of all attached data nodes
 hypertable_id | node_hypertable_id |  node_name  
---------------+--------------------+-------------
             4 |                  3 | data_node_2
(1 row)

-- Number of slices should not be increased
SELECT h.table_name, d.column_name, d.num_slices
FROM _timescaledb_catalog.hypertable h, _timescaledb_catalog.dimension d
WHERE h.id = d.hypertable_id
AND h.table_name = 'Param_Table'
ORDER BY 1, 2, 3;
 table_name  |   column_name    | num_slices 
-------------+------------------+------------
 Param_Table | __region         |          2
 Param_Table | time Col %#^#@$# |           
(2 rows)

-- Manually increase the number of partitions
SELECT * FROM set_number_partitions('"Table\\Schema"."Param_Table"', 4);
 set_number_partitions 
-----------------------
 
(1 row)

-- Verify hypertables on all data nodes
SELECT * FROM _timescaledb_catalog.hypertable;
 id |  schema_name  |   table_name    | associated_schema_name | associated_table_prefix | num_dimensions | chunk_sizing_func_schema |  chunk_sizing_func_name  | chunk_target_size | compressed | compressed_hypertable_id | replication_factor 
----+---------------+-----------------+------------------------+-------------------------+----------------+--------------------------+--------------------------+-------------------+------------+--------------------------+--------------------
  1 | public        | disttable       | _timescaledb_internal  | _hyper_1                |              2 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                  1
  2 | public        | underreplicated | _timescaledb_internal  | _hyper_2                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                  4
  4 | Table\\Schema | Param_Table     | T3sTSch                | test*pre_               |              2 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                  2
(3 rows)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             1 | device           | integer                  | f       |          3 | _timescaledb_internal    | get_partition_hash |                 |                         | 
  3 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  5 |             4 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  6 |             4 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(5 rows)

SELECT * FROM test.show_triggers('"Table\\Schema"."Param_Table"');
      Trigger      | Type |               Function               
-------------------+------+--------------------------------------
 ts_insert_blocker |    7 | _timescaledb_internal.insert_blocker
(1 row)

SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT * FROM _timescaledb_catalog.hypertable;
SELECT * FROM _timescaledb_catalog.dimension;
SELECT t.tgname, t.tgtype, t.tgfoid::regproc
FROM pg_trigger t, pg_class c WHERE c.relname = 'Param_Table' AND t.tgrelid = c.oid;
$$);
NOTICE:  [data_node_1]: 
SELECT * FROM _timescaledb_catalog.hypertable
NOTICE:  [data_node_1]:
id|schema_name  |table_name     |associated_schema_name|associated_table_prefix|num_dimensions|chunk_sizing_func_schema|chunk_sizing_func_name  |chunk_target_size|compressed|compressed_hypertable_id|replication_factor
--+-------------+---------------+----------------------+-----------------------+--------------+------------------------+------------------------+-----------------+----------+------------------------+------------------
 1|public       |disttable      |_timescaledb_internal |_hyper_1               |             2|_timescaledb_internal   |calculate_chunk_interval|                0|f         |                        |                -1
 2|public       |underreplicated|_timescaledb_internal |_hyper_2               |             1|_timescaledb_internal   |calculate_chunk_interval|                0|f         |                        |                -1
 3|Table\\Schema|Param_Table    |T3sTSch               |test*pre_              |             2|_timescaledb_internal   |calculate_chunk_interval|                0|f         |                        |                -1
(3 rows)


NOTICE:  [data_node_1]: 
SELECT * FROM _timescaledb_catalog.dimension
NOTICE:  [data_node_1]:
id|hypertable_id|column_name     |column_type             |aligned|num_slices|partitioning_func_schema|partitioning_func |interval_length|integer_now_func_schema|integer_now_func
--+-------------+----------------+------------------------+-------+----------+------------------------+------------------+---------------+-----------------------+----------------
 1|            1|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 2|            1|device          |integer                 |f      |         1|_timescaledb_internal   |get_partition_hash|               |                       |                
 3|            2|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 4|            3|time Col %#^#@$#|timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 5|            3|__region        |text                    |f      |         1|_timescaledb_internal   |get_partition_hash|               |                       |                
(5 rows)


NOTICE:  [data_node_1]: 
SELECT t.tgname, t.tgtype, t.tgfoid::regproc
FROM pg_trigger t, pg_class c WHERE c.relname = 'Param_Table' AND t.tgrelid = c.oid
NOTICE:  [data_node_1]:
tgname           |tgtype|tgfoid                              
-----------------+------+------------------------------------
ts_insert_blocker|     7|_timescaledb_internal.insert_blocker
(1 row)


NOTICE:  [data_node_2]: 
SELECT * FROM _timescaledb_catalog.hypertable
NOTICE:  [data_node_2]:
id|schema_name  |table_name     |associated_schema_name|associated_table_prefix|num_dimensions|chunk_sizing_func_schema|chunk_sizing_func_name  |chunk_target_size|compressed|compressed_hypertable_id|replication_factor
--+-------------+---------------+----------------------+-----------------------+--------------+------------------------+------------------------+-----------------+----------+------------------------+------------------
 1|public       |disttable      |_timescaledb_internal |_hyper_1               |             2|_timescaledb_internal   |calculate_chunk_interval|                0|f         |                        |                -1
 2|public       |underreplicated|_timescaledb_internal |_hyper_2               |             1|_timescaledb_internal   |calculate_chunk_interval|                0|f         |                        |                -1
 3|Table\\Schema|Param_Table    |T3sTSch               |test*pre_              |             2|_timescaledb_internal   |calculate_chunk_interval|                0|f         |                        |                -1
(3 rows)


NOTICE:  [data_node_2]: 
SELECT * FROM _timescaledb_catalog.dimension
NOTICE:  [data_node_2]:
id|hypertable_id|column_name     |column_type             |aligned|num_slices|partitioning_func_schema|partitioning_func |interval_length|integer_now_func_schema|integer_now_func
--+-------------+----------------+------------------------+-------+----------+------------------------+------------------+---------------+-----------------------+----------------
 1|            1|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 2|            1|device          |integer                 |f      |         1|_timescaledb_internal   |get_partition_hash|               |                       |                
 3|            2|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 4|            3|time Col %#^#@$#|timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 5|            3|__region        |text                    |f      |         2|_timescaledb_internal   |get_partition_hash|               |                       |                
(5 rows)


NOTICE:  [data_node_2]: 
SELECT t.tgname, t.tgtype, t.tgfoid::regproc
FROM pg_trigger t, pg_class c WHERE c.relname = 'Param_Table' AND t.tgrelid = c.oid
NOTICE:  [data_node_2]:
tgname           |tgtype|tgfoid                              
-----------------+------+------------------------------------
ts_insert_blocker|     7|_timescaledb_internal.insert_blocker
(1 row)


NOTICE:  [data_node_3]: 
SELECT * FROM _timescaledb_catalog.hypertable
NOTICE:  [data_node_3]:
id|schema_name  |table_name     |associated_schema_name|associated_table_prefix|num_dimensions|chunk_sizing_func_schema|chunk_sizing_func_name  |chunk_target_size|compressed|compressed_hypertable_id|replication_factor
--+-------------+---------------+----------------------+-----------------------+--------------+------------------------+------------------------+-----------------+----------+------------------------+------------------
 1|public       |disttable      |_timescaledb_internal |_hyper_1               |             2|_timescaledb_internal   |calculate_chunk_interval|                0|f         |                        |                -1
 2|public       |underreplicated|_timescaledb_internal |_hyper_2               |             1|_timescaledb_internal   |calculate_chunk_interval|                0|f         |                        |                -1
 3|Table\\Schema|Param_Table    |T3sTSch               |test*pre_              |             2|_timescaledb_internal   |calculate_chunk_interval|                0|f         |                        |                -1
(3 rows)


NOTICE:  [data_node_3]: 
SELECT * FROM _timescaledb_catalog.dimension
NOTICE:  [data_node_3]:
id|hypertable_id|column_name     |column_type             |aligned|num_slices|partitioning_func_schema|partitioning_func |interval_length|integer_now_func_schema|integer_now_func
--+-------------+----------------+------------------------+-------+----------+------------------------+------------------+---------------+-----------------------+----------------
 1|            1|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 2|            1|device          |integer                 |f      |         1|_timescaledb_internal   |get_partition_hash|               |                       |                
 3|            2|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 4|            3|time Col %#^#@$#|timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 5|            3|__region        |text                    |f      |         1|_timescaledb_internal   |get_partition_hash|               |                       |                
(5 rows)


NOTICE:  [data_node_3]: 
SELECT t.tgname, t.tgtype, t.tgfoid::regproc
FROM pg_trigger t, pg_class c WHERE c.relname = 'Param_Table' AND t.tgrelid = c.oid
NOTICE:  [data_node_3]:
tgname           |tgtype|tgfoid                              
-----------------+------+------------------------------------
ts_insert_blocker|     7|_timescaledb_internal.insert_blocker
(1 row)


 remote_exec 
-------------
 
(1 row)

-- Test multi-dimensional hypertable (note that add_dimension is not currently propagated to backends)
CREATE TABLE dimented_table (time timestamptz, column1 int, column2 timestamptz, column3 int);
SELECT * FROM create_distributed_hypertable('dimented_table', 'time', partitioning_column => 'column1', number_partitions  => 4, replication_factor => 1, data_nodes => '{ "data_node_1" }');
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name |   table_name   | created 
---------------+-------------+----------------+---------
             5 | public      | dimented_table | t
(1 row)

SELECT * FROM add_dimension('dimented_table', 'column2', chunk_time_interval => interval '1 week');
NOTICE:  adding not-null constraint to column "column2"
 dimension_id | schema_name |   table_name   | column_name | created 
--------------+-------------+----------------+-------------+---------
            9 | public      | dimented_table | column2     | t
(1 row)

SELECT * FROM add_dimension('dimented_table', 'column3', 4, partitioning_func => '_timescaledb_internal.get_partition_for_key');
 dimension_id | schema_name |   table_name   | column_name | created 
--------------+-------------+----------------+-------------+---------
           10 | public      | dimented_table | column3     | t
(1 row)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema |   partitioning_func   | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+-----------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  2 |             1 | device           | integer                  | f       |          3 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  3 |             2 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  5 |             4 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  6 |             4 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  7 |             5 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  8 |             5 | column1          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  9 |             5 | column2          | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
 10 |             5 | column3          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_for_key |                 |                         | 
(9 rows)

SELECT * FROM attach_data_node('data_node_2', 'dimented_table');
 hypertable_id | node_hypertable_id |  node_name  
---------------+--------------------+-------------
             5 |                  4 | data_node_2
(1 row)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema |   partitioning_func   | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+-----------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  2 |             1 | device           | integer                  | f       |          3 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  3 |             2 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  5 |             4 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  6 |             4 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  7 |             5 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  8 |             5 | column1          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  9 |             5 | column2          | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
 10 |             5 | column3          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_for_key |                 |                         | 
(9 rows)

-- Note that this didn't get the add_dimension
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT * FROM _timescaledb_catalog.dimension;
$$);
NOTICE:  [data_node_1]: 
SELECT * FROM _timescaledb_catalog.dimension
NOTICE:  [data_node_1]:
id|hypertable_id|column_name     |column_type             |aligned|num_slices|partitioning_func_schema|partitioning_func |interval_length|integer_now_func_schema|integer_now_func
--+-------------+----------------+------------------------+-------+----------+------------------------+------------------+---------------+-----------------------+----------------
 1|            1|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 2|            1|device          |integer                 |f      |         1|_timescaledb_internal   |get_partition_hash|               |                       |                
 3|            2|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 4|            3|time Col %#^#@$#|timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 5|            3|__region        |text                    |f      |         1|_timescaledb_internal   |get_partition_hash|               |                       |                
 6|            4|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 7|            4|column1         |integer                 |f      |         4|_timescaledb_internal   |get_partition_hash|               |                       |                
(7 rows)


NOTICE:  [data_node_2]: 
SELECT * FROM _timescaledb_catalog.dimension
NOTICE:  [data_node_2]:
id|hypertable_id|column_name     |column_type             |aligned|num_slices|partitioning_func_schema|partitioning_func    |interval_length|integer_now_func_schema|integer_now_func
--+-------------+----------------+------------------------+-------+----------+------------------------+---------------------+---------------+-----------------------+----------------
 1|            1|time            |timestamp with time zone|t      |          |                        |                     |   604800000000|                       |                
 2|            1|device          |integer                 |f      |         1|_timescaledb_internal   |get_partition_hash   |               |                       |                
 3|            2|time            |timestamp with time zone|t      |          |                        |                     |   604800000000|                       |                
 4|            3|time Col %#^#@$#|timestamp with time zone|t      |          |                        |                     |   604800000000|                       |                
 5|            3|__region        |text                    |f      |         2|_timescaledb_internal   |get_partition_hash   |               |                       |                
 6|            4|time            |timestamp with time zone|t      |          |                        |                     |   604800000000|                       |                
 7|            4|column1         |integer                 |f      |         4|_timescaledb_internal   |get_partition_hash   |               |                       |                
 8|            4|column2         |timestamp with time zone|t      |          |                        |                     |   604800000000|                       |                
 9|            4|column3         |integer                 |f      |         4|_timescaledb_internal   |get_partition_for_key|               |                       |                
(9 rows)


NOTICE:  [data_node_3]: 
SELECT * FROM _timescaledb_catalog.dimension
NOTICE:  [data_node_3]:
id|hypertable_id|column_name     |column_type             |aligned|num_slices|partitioning_func_schema|partitioning_func |interval_length|integer_now_func_schema|integer_now_func
--+-------------+----------------+------------------------+-------+----------+------------------------+------------------+---------------+-----------------------+----------------
 1|            1|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 2|            1|device          |integer                 |f      |         1|_timescaledb_internal   |get_partition_hash|               |                       |                
 3|            2|time            |timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 4|            3|time Col %#^#@$#|timestamp with time zone|t      |          |                        |                  |   604800000000|                       |                
 5|            3|__region        |text                    |f      |         1|_timescaledb_internal   |get_partition_hash|               |                       |                
(5 rows)


 remote_exec 
-------------
 
(1 row)

--test per-data node queries
-- Create some chunks through insertion
CREATE TABLE disttable_replicated(time timestamptz PRIMARY KEY, device int CHECK (device > 0), temp float, "Color" int);
SELECT * FROM create_hypertable('disttable_replicated', 'time', replication_factor => 2);
 hypertable_id | schema_name |      table_name      | created 
---------------+-------------+----------------------+---------
             6 | public      | disttable_replicated | t
(1 row)

INSERT INTO disttable_replicated VALUES
       ('2017-01-01 06:01', 1, 1.1, 1),
       ('2017-01-01 08:01', 1, 1.2, 2),
       ('2018-01-02 08:01', 2, 1.3, 3),
       ('2019-01-01 09:11', 3, 2.1, 4),
       ('2020-01-01 06:01', 5, 1.1, 10),
       ('2020-01-01 08:01', 6, 1.2, 11),
       ('2021-01-02 08:01', 7, 1.3, 12),
       ('2022-01-01 09:11', 8, 2.1, 13);
SELECT * FROM disttable_replicated;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |     1
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |     2
 Wed Jan 01 06:01:00 2020 PST |      5 |  1.1 |    10
 Wed Jan 01 08:01:00 2020 PST |      6 |  1.2 |    11
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |     3
 Sat Jan 02 08:01:00 2021 PST |      7 |  1.3 |    12
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1 |     4
 Sat Jan 01 09:11:00 2022 PST |      8 |  2.1 |    13
(8 rows)

EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE, TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated;
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=8 loops=1)
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated (actual rows=4 loops=1)
         Output: disttable_replicated."time", disttable_replicated.device, disttable_replicated.temp, disttable_replicated."Color"
         Data node: data_node_1
         Chunks: _hyper_6_11_dist_chunk, _hyper_6_14_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[5, 7])
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated disttable_replicated_1 (actual rows=2 loops=1)
         Output: disttable_replicated_1."time", disttable_replicated_1.device, disttable_replicated_1.temp, disttable_replicated_1."Color"
         Data node: data_node_2
         Chunks: _hyper_6_12_dist_chunk, _hyper_6_15_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[6, 8])
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated disttable_replicated_2 (actual rows=2 loops=1)
         Output: disttable_replicated_2."time", disttable_replicated_2.device, disttable_replicated_2.temp, disttable_replicated_2."Color"
         Data node: data_node_3
         Chunks: _hyper_6_13_dist_chunk, _hyper_6_16_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[6, 8])
(16 rows)

--guc disables the optimization
SET timescaledb.enable_per_data_node_queries = FALSE;
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE, TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=8 loops=1)
   ->  Foreign Scan on _timescaledb_internal._hyper_6_11_dist_chunk (actual rows=2 loops=1)
         Output: _hyper_6_11_dist_chunk."time", _hyper_6_11_dist_chunk.device, _hyper_6_11_dist_chunk.temp, _hyper_6_11_dist_chunk."Color"
         Data node: data_node_1
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_11_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_6_12_dist_chunk (actual rows=1 loops=1)
         Output: _hyper_6_12_dist_chunk."time", _hyper_6_12_dist_chunk.device, _hyper_6_12_dist_chunk.temp, _hyper_6_12_dist_chunk."Color"
         Data node: data_node_2
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_12_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_6_13_dist_chunk (actual rows=1 loops=1)
         Output: _hyper_6_13_dist_chunk."time", _hyper_6_13_dist_chunk.device, _hyper_6_13_dist_chunk.temp, _hyper_6_13_dist_chunk."Color"
         Data node: data_node_3
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_13_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_6_14_dist_chunk (actual rows=2 loops=1)
         Output: _hyper_6_14_dist_chunk."time", _hyper_6_14_dist_chunk.device, _hyper_6_14_dist_chunk.temp, _hyper_6_14_dist_chunk."Color"
         Data node: data_node_1
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_14_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_6_15_dist_chunk (actual rows=1 loops=1)
         Output: _hyper_6_15_dist_chunk."time", _hyper_6_15_dist_chunk.device, _hyper_6_15_dist_chunk.temp, _hyper_6_15_dist_chunk."Color"
         Data node: data_node_2
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_15_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_6_16_dist_chunk (actual rows=1 loops=1)
         Output: _hyper_6_16_dist_chunk."time", _hyper_6_16_dist_chunk.device, _hyper_6_16_dist_chunk.temp, _hyper_6_16_dist_chunk."Color"
         Data node: data_node_3
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_16_dist_chunk
(25 rows)

SET timescaledb.enable_per_data_node_queries = TRUE;
--test WHERE clause
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE, TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated WHERE temp > 2.0;
                                                                                              QUERY PLAN                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=2 loops=1)
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated (actual rows=0 loops=1)
         Output: disttable_replicated."time", disttable_replicated.device, disttable_replicated.temp, disttable_replicated."Color"
         Data node: data_node_1
         Chunks: _hyper_6_11_dist_chunk, _hyper_6_14_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[5, 7]) AND ((temp > 2::double precision))
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated disttable_replicated_1 (actual rows=0 loops=1)
         Output: disttable_replicated_1."time", disttable_replicated_1.device, disttable_replicated_1.temp, disttable_replicated_1."Color"
         Data node: data_node_2
         Chunks: _hyper_6_12_dist_chunk, _hyper_6_15_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[6, 8]) AND ((temp > 2::double precision))
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated disttable_replicated_2 (actual rows=2 loops=1)
         Output: disttable_replicated_2."time", disttable_replicated_2.device, disttable_replicated_2.temp, disttable_replicated_2."Color"
         Data node: data_node_3
         Chunks: _hyper_6_13_dist_chunk, _hyper_6_16_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[6, 8]) AND ((temp > 2::double precision))
(16 rows)

--test OR
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE, TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated WHERE temp > 2.0 or "Color" = 11;
                                                                                                        QUERY PLAN                                                                                                         
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=3 loops=1)
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated (actual rows=1 loops=1)
         Output: disttable_replicated."time", disttable_replicated.device, disttable_replicated.temp, disttable_replicated."Color"
         Data node: data_node_1
         Chunks: _hyper_6_11_dist_chunk, _hyper_6_14_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[5, 7]) AND (((temp > 2::double precision) OR ("Color" = 11)))
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated disttable_replicated_1 (actual rows=0 loops=1)
         Output: disttable_replicated_1."time", disttable_replicated_1.device, disttable_replicated_1.temp, disttable_replicated_1."Color"
         Data node: data_node_2
         Chunks: _hyper_6_12_dist_chunk, _hyper_6_15_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[6, 8]) AND (((temp > 2::double precision) OR ("Color" = 11)))
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated disttable_replicated_2 (actual rows=2 loops=1)
         Output: disttable_replicated_2."time", disttable_replicated_2.device, disttable_replicated_2.temp, disttable_replicated_2."Color"
         Data node: data_node_3
         Chunks: _hyper_6_13_dist_chunk, _hyper_6_16_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[6, 8]) AND (((temp > 2::double precision) OR ("Color" = 11)))
(16 rows)

--test some chunks excluded
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE,  TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated WHERE time < '2018-01-01 09:11';
                                                                                                             QUERY PLAN                                                                                                              
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=2 loops=1)
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated (actual rows=2 loops=1)
         Output: disttable_replicated."time", disttable_replicated.device, disttable_replicated.temp, disttable_replicated."Color"
         Data node: data_node_1
         Chunks: _hyper_6_11_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[5]) AND (("time" < '2018-01-01 09:11:00-08'::timestamp with time zone))
   ->  Custom Scan (DataNodeScan) on public.disttable_replicated disttable_replicated_1 (actual rows=0 loops=1)
         Output: disttable_replicated_1."time", disttable_replicated_1.device, disttable_replicated_1.temp, disttable_replicated_1."Color"
         Data node: data_node_2
         Chunks: _hyper_6_12_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[6]) AND (("time" < '2018-01-01 09:11:00-08'::timestamp with time zone))
(11 rows)

--test all chunks excluded
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE,  TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated WHERE time < '2002-01-01 09:11';
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Result (actual rows=0 loops=1)
   Output: disttable_replicated."time", disttable_replicated.device, disttable_replicated.temp, disttable_replicated."Color"
   One-Time Filter: false
(3 rows)

--test cte
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE,  TIMING FALSE, SUMMARY FALSE)
WITH cte AS (
    SELECT * FROM disttable_replicated
)
SELECT * FROM cte;
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CTE Scan on cte (actual rows=8 loops=1)
   Output: cte."time", cte.device, cte.temp, cte."Color"
   CTE cte
     ->  Append (actual rows=8 loops=1)
           ->  Custom Scan (DataNodeScan) on public.disttable_replicated (actual rows=4 loops=1)
                 Output: disttable_replicated."time", disttable_replicated.device, disttable_replicated.temp, disttable_replicated."Color"
                 Data node: data_node_1
                 Chunks: _hyper_6_11_dist_chunk, _hyper_6_14_dist_chunk
                 Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[5, 7])
           ->  Custom Scan (DataNodeScan) on public.disttable_replicated disttable_replicated_1 (actual rows=2 loops=1)
                 Output: disttable_replicated_1."time", disttable_replicated_1.device, disttable_replicated_1.temp, disttable_replicated_1."Color"
                 Data node: data_node_2
                 Chunks: _hyper_6_12_dist_chunk, _hyper_6_15_dist_chunk
                 Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[6, 8])
           ->  Custom Scan (DataNodeScan) on public.disttable_replicated disttable_replicated_2 (actual rows=2 loops=1)
                 Output: disttable_replicated_2."time", disttable_replicated_2.device, disttable_replicated_2.temp, disttable_replicated_2."Color"
                 Data node: data_node_3
                 Chunks: _hyper_6_13_dist_chunk, _hyper_6_16_dist_chunk
                 Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[6, 8])
(19 rows)

--queries that involve updates/inserts are not optimized
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE,  TIMING FALSE, SUMMARY FALSE)
WITH devices AS (
     SELECT DISTINCT device FROM disttable_replicated ORDER BY device
)
UPDATE disttable_replicated SET device = 2 WHERE device = (SELECT device FROM devices LIMIT 1);
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Update on public.disttable_replicated (actual rows=0 loops=1)
   Update on public.disttable_replicated
   Foreign Update on _timescaledb_internal._hyper_6_11_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_11_dist_chunk SET device = $2 WHERE ctid = $1
   Foreign Update on _timescaledb_internal._hyper_6_12_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_12_dist_chunk SET device = $2 WHERE ctid = $1
   Foreign Update on _timescaledb_internal._hyper_6_13_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_13_dist_chunk SET device = $2 WHERE ctid = $1
   Foreign Update on _timescaledb_internal._hyper_6_14_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_14_dist_chunk SET device = $2 WHERE ctid = $1
   Foreign Update on _timescaledb_internal._hyper_6_15_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_15_dist_chunk SET device = $2 WHERE ctid = $1
   Foreign Update on _timescaledb_internal._hyper_6_16_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_16_dist_chunk SET device = $2 WHERE ctid = $1
   CTE devices
     ->  Sort (actual rows=1 loops=1)
           Output: disttable_replicated_1.device
           Sort Key: disttable_replicated_1.device
           Sort Method: quicksort 
           ->  HashAggregate (actual rows=7 loops=1)
                 Output: disttable_replicated_1.device
                 Group Key: disttable_replicated_1.device
                 ->  Append (actual rows=8 loops=1)
                       ->  Seq Scan on public.disttable_replicated disttable_replicated_1 (actual rows=0 loops=1)
                             Output: disttable_replicated_1.device
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_11_dist_chunk _hyper_6_11_dist_chunk_1 (actual rows=2 loops=1)
                             Output: _hyper_6_11_dist_chunk_1.device
                             Data node: data_node_1
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_11_dist_chunk ORDER BY device ASC NULLS LAST
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_12_dist_chunk _hyper_6_12_dist_chunk_1 (actual rows=1 loops=1)
                             Output: _hyper_6_12_dist_chunk_1.device
                             Data node: data_node_2
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_12_dist_chunk ORDER BY device ASC NULLS LAST
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_13_dist_chunk _hyper_6_13_dist_chunk_1 (actual rows=1 loops=1)
                             Output: _hyper_6_13_dist_chunk_1.device
                             Data node: data_node_3
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_13_dist_chunk ORDER BY device ASC NULLS LAST
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_14_dist_chunk _hyper_6_14_dist_chunk_1 (actual rows=2 loops=1)
                             Output: _hyper_6_14_dist_chunk_1.device
                             Data node: data_node_1
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_14_dist_chunk ORDER BY device ASC NULLS LAST
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_15_dist_chunk _hyper_6_15_dist_chunk_1 (actual rows=1 loops=1)
                             Output: _hyper_6_15_dist_chunk_1.device
                             Data node: data_node_2
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_15_dist_chunk ORDER BY device ASC NULLS LAST
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_16_dist_chunk _hyper_6_16_dist_chunk_1 (actual rows=1 loops=1)
                             Output: _hyper_6_16_dist_chunk_1.device
                             Data node: data_node_3
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_16_dist_chunk ORDER BY device ASC NULLS LAST
   InitPlan 2 (returns $1)
     ->  Limit (actual rows=1 loops=1)
           Output: devices.device
           ->  CTE Scan on devices (actual rows=1 loops=1)
                 Output: devices.device
   ->  Seq Scan on public.disttable_replicated (actual rows=0 loops=1)
         Output: disttable_replicated."time", 2, disttable_replicated.temp, disttable_replicated."Color", disttable_replicated.ctid
         Filter: (disttable_replicated.device = $1)
   ->  Foreign Scan on _timescaledb_internal._hyper_6_11_dist_chunk (actual rows=2 loops=1)
         Output: _hyper_6_11_dist_chunk."time", 2, _hyper_6_11_dist_chunk.temp, _hyper_6_11_dist_chunk."Color", _hyper_6_11_dist_chunk.ctid
         Data node: data_node_1
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_11_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
   ->  Foreign Scan on _timescaledb_internal._hyper_6_12_dist_chunk (actual rows=0 loops=1)
         Output: _hyper_6_12_dist_chunk."time", 2, _hyper_6_12_dist_chunk.temp, _hyper_6_12_dist_chunk."Color", _hyper_6_12_dist_chunk.ctid
         Data node: data_node_2
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_12_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
   ->  Foreign Scan on _timescaledb_internal._hyper_6_13_dist_chunk (actual rows=0 loops=1)
         Output: _hyper_6_13_dist_chunk."time", 2, _hyper_6_13_dist_chunk.temp, _hyper_6_13_dist_chunk."Color", _hyper_6_13_dist_chunk.ctid
         Data node: data_node_3
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_13_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
   ->  Foreign Scan on _timescaledb_internal._hyper_6_14_dist_chunk (actual rows=0 loops=1)
         Output: _hyper_6_14_dist_chunk."time", 2, _hyper_6_14_dist_chunk.temp, _hyper_6_14_dist_chunk."Color", _hyper_6_14_dist_chunk.ctid
         Data node: data_node_1
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_14_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
   ->  Foreign Scan on _timescaledb_internal._hyper_6_15_dist_chunk (actual rows=0 loops=1)
         Output: _hyper_6_15_dist_chunk."time", 2, _hyper_6_15_dist_chunk.temp, _hyper_6_15_dist_chunk."Color", _hyper_6_15_dist_chunk.ctid
         Data node: data_node_2
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_15_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
   ->  Foreign Scan on _timescaledb_internal._hyper_6_16_dist_chunk (actual rows=0 loops=1)
         Output: _hyper_6_16_dist_chunk."time", 2, _hyper_6_16_dist_chunk.temp, _hyper_6_16_dist_chunk."Color", _hyper_6_16_dist_chunk.ctid
         Data node: data_node_3
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_16_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
(81 rows)

-- Test inserts with smaller batch size and more tuples to reach full
-- batch
SET timescaledb.max_insert_batch_size=4;
CREATE TABLE twodim (time timestamptz DEFAULT '2019-02-10 10:11', "Color" int DEFAULT 11 CHECK ("Color" > 0), temp float DEFAULT 22.1);
-- Create a replicated table to ensure we handle that case correctly
-- with batching
SELECT * FROM create_hypertable('twodim', 'time', 'Color', 3, replication_factor => 2, data_nodes => '{ "data_node_1", "data_node_2", "data_node_3" }');
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             7 | public      | twodim     | t
(1 row)

SELECT * FROM twodim
ORDER BY time;
 time | Color | temp 
------+-------+------
(0 rows)

-- INSERT enough data to stretch across multiple batches per
-- data node. Also return a system column. Although we write tuples to
-- multiple data nodes, the returned tuple should only be the ones in the
-- original insert statement (without the replica tuples).
WITH result AS (
     INSERT INTO twodim VALUES
       ('2017-02-01 06:01', 1, 1.1),
       ('2017-02-01 08:01', 1, 1.2),
       ('2018-02-02 08:01', 2, 1.3),
       ('2019-02-01 09:11', 3, 2.1),
       ('2019-02-02 09:11', 3, 2.1),
       ('2019-02-02 10:01', 5, 1.2),
       ('2019-02-03 11:11', 6, 3.5),
       ('2019-02-04 08:21', 4, 6.6),
       ('2019-02-04 10:11', 7, 7.4),
       ('2019-02-04 12:11', 8, 2.1),
       ('2019-02-05 13:31', 8, 6.3),
       ('2019-02-06 02:11', 5, 1.8),
       ('2019-02-06 01:13', 7, 7.9),
       ('2019-02-06 19:24', 9, 5.9),
       ('2019-02-07 18:44', 5, 9.7),
       ('2019-02-07 20:24', 6, NULL),
       ('2019-02-07 09:33', 7, 9.5),
       ('2019-02-08 08:54', 1, 7.3),
       ('2019-02-08 18:14', 4, 8.2),
       ('2019-02-09 19:23', 8, 9.1)
     RETURNING tableoid = 'twodim'::regclass AS is_tableoid, time, temp, "Color"
) SELECT * FROM result ORDER BY time;
 is_tableoid |             time             | temp | Color 
-------------+------------------------------+------+-------
 t           | Wed Feb 01 06:01:00 2017 PST |  1.1 |     1
 t           | Wed Feb 01 08:01:00 2017 PST |  1.2 |     1
 t           | Fri Feb 02 08:01:00 2018 PST |  1.3 |     2
 t           | Fri Feb 01 09:11:00 2019 PST |  2.1 |     3
 t           | Sat Feb 02 09:11:00 2019 PST |  2.1 |     3
 t           | Sat Feb 02 10:01:00 2019 PST |  1.2 |     5
 t           | Sun Feb 03 11:11:00 2019 PST |  3.5 |     6
 t           | Mon Feb 04 08:21:00 2019 PST |  6.6 |     4
 t           | Mon Feb 04 10:11:00 2019 PST |  7.4 |     7
 t           | Mon Feb 04 12:11:00 2019 PST |  2.1 |     8
 t           | Tue Feb 05 13:31:00 2019 PST |  6.3 |     8
 t           | Wed Feb 06 01:13:00 2019 PST |  7.9 |     7
 t           | Wed Feb 06 02:11:00 2019 PST |  1.8 |     5
 t           | Wed Feb 06 19:24:00 2019 PST |  5.9 |     9
 t           | Thu Feb 07 09:33:00 2019 PST |  9.5 |     7
 t           | Thu Feb 07 18:44:00 2019 PST |  9.7 |     5
 t           | Thu Feb 07 20:24:00 2019 PST |      |     6
 t           | Fri Feb 08 08:54:00 2019 PST |  7.3 |     1
 t           | Fri Feb 08 18:14:00 2019 PST |  8.2 |     4
 t           | Sat Feb 09 19:23:00 2019 PST |  9.1 |     8
(20 rows)

-- Test insert with default values and a batch size of 1.
SET timescaledb.max_insert_batch_size=1;
EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF)
INSERT INTO twodim DEFAULT VALUES;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable public.twodim
   Data nodes: data_node_1, data_node_2, data_node_3
   ->  Insert on public.twodim
         ->  Custom Scan (DataNodeDispatch)
               Output: 'Sun Feb 10 10:11:00 2019 PST'::timestamp with time zone, 11, '22.1'::double precision
               Batch size: 1
               Remote SQL: INSERT INTO public.twodim("time", "Color", temp) VALUES ($1, $2, $3)
               ->  Custom Scan (ChunkDispatch)
                     Output: 'Sun Feb 10 10:11:00 2019 PST'::timestamp with time zone, 11, '22.1'::double precision
                     ->  Result
                           Output: 'Sun Feb 10 10:11:00 2019 PST'::timestamp with time zone, 11, '22.1'::double precision
(12 rows)

INSERT INTO twodim DEFAULT VALUES;
-- Reset the batch size
SET timescaledb.max_insert_batch_size=4;
-- Constraint violation error check
--
-- Execute and filter mentioned data node name in the error message.
\set ON_ERROR_STOP 0
SELECT test.execute_sql_and_filter_data_node_name_on_error($$ INSERT INTO twodim VALUES ('2019-02-10 17:54', 0, 10.2) $$);
ERROR:  [data_node_x]: new row for relation "_hyper_7_22_dist_chunk" violates check constraint "twodim_Color_check"
\set ON_ERROR_STOP 1
-- Disable batching, reverting to FDW tuple-by-tuple inserts.
-- First EXPLAIN with batching turned on.
EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF)
INSERT INTO twodim VALUES
       ('2019-02-10 16:23', 5, 7.1),
       ('2019-02-10 17:11', 7, 3.2);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable public.twodim
   Data nodes: data_node_1, data_node_2, data_node_3
   ->  Insert on public.twodim
         ->  Custom Scan (DataNodeDispatch)
               Output: "*VALUES*".column1, "*VALUES*".column2, "*VALUES*".column3
               Batch size: 4
               Remote SQL: INSERT INTO public.twodim("time", "Color", temp) VALUES ($1, $2, $3), ..., ($10, $11, $12)
               ->  Custom Scan (ChunkDispatch)
                     Output: "*VALUES*".column1, "*VALUES*".column2, "*VALUES*".column3
                     ->  Values Scan on "*VALUES*"
                           Output: "*VALUES*".column1, "*VALUES*".column2, "*VALUES*".column3
(12 rows)

SET timescaledb.max_insert_batch_size=0;
-- Compare without batching
EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF)
INSERT INTO twodim VALUES
       ('2019-02-10 16:23', 5, 7.1),
       ('2019-02-10 17:11', 7, 3.2);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable public.twodim
   Data nodes: data_node_1, data_node_2, data_node_3
   Remote SQL: INSERT INTO public.twodim("time", "Color", temp) VALUES ($1, $2, $3)
   ->  Insert on public.twodim
         ->  Custom Scan (ChunkDispatch)
               Output: "*VALUES*".column1, "*VALUES*".column2, "*VALUES*".column3
               ->  Values Scan on "*VALUES*"
                     Output: "*VALUES*".column1, "*VALUES*".column2, "*VALUES*".column3
(9 rows)

-- Insert without batching
INSERT INTO twodim VALUES
       ('2019-02-10 16:23', 5, 7.1),
       ('2019-02-10 17:11', 7, 3.2);
-- Check results
SELECT * FROM twodim
ORDER BY time;
             time             | Color | temp 
------------------------------+-------+------
 Wed Feb 01 06:01:00 2017 PST |     1 |  1.1
 Wed Feb 01 08:01:00 2017 PST |     1 |  1.2
 Fri Feb 02 08:01:00 2018 PST |     2 |  1.3
 Fri Feb 01 09:11:00 2019 PST |     3 |  2.1
 Sat Feb 02 09:11:00 2019 PST |     3 |  2.1
 Sat Feb 02 10:01:00 2019 PST |     5 |  1.2
 Sun Feb 03 11:11:00 2019 PST |     6 |  3.5
 Mon Feb 04 08:21:00 2019 PST |     4 |  6.6
 Mon Feb 04 10:11:00 2019 PST |     7 |  7.4
 Mon Feb 04 12:11:00 2019 PST |     8 |  2.1
 Tue Feb 05 13:31:00 2019 PST |     8 |  6.3
 Wed Feb 06 01:13:00 2019 PST |     7 |  7.9
 Wed Feb 06 02:11:00 2019 PST |     5 |  1.8
 Wed Feb 06 19:24:00 2019 PST |     9 |  5.9
 Thu Feb 07 09:33:00 2019 PST |     7 |  9.5
 Thu Feb 07 18:44:00 2019 PST |     5 |  9.7
 Thu Feb 07 20:24:00 2019 PST |     6 |     
 Fri Feb 08 08:54:00 2019 PST |     1 |  7.3
 Fri Feb 08 18:14:00 2019 PST |     4 |  8.2
 Sat Feb 09 19:23:00 2019 PST |     8 |  9.1
 Sun Feb 10 10:11:00 2019 PST |    11 | 22.1
 Sun Feb 10 16:23:00 2019 PST |     5 |  7.1
 Sun Feb 10 17:11:00 2019 PST |     7 |  3.2
(23 rows)

SELECT count(*) FROM twodim;
 count 
-------
    23
(1 row)

-- Show distribution across data nodes
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT * FROM twodim
ORDER BY time;
SELECT count(*) FROM twodim;
$$);
NOTICE:  [data_node_1]: 
SELECT * FROM twodim
ORDER BY time
NOTICE:  [data_node_1]:
time                        |Color|temp
----------------------------+-----+----
Wed Feb 01 06:01:00 2017 PST|    1| 1.1
Wed Feb 01 08:01:00 2017 PST|    1| 1.2
Fri Feb 01 09:11:00 2019 PST|    3| 2.1
Sat Feb 02 09:11:00 2019 PST|    3| 2.1
Sun Feb 03 11:11:00 2019 PST|    6| 3.5
Mon Feb 04 12:11:00 2019 PST|    8| 2.1
Tue Feb 05 13:31:00 2019 PST|    8| 6.3
Wed Feb 06 19:24:00 2019 PST|    9| 5.9
Thu Feb 07 20:24:00 2019 PST|    6|    
Fri Feb 08 08:54:00 2019 PST|    1| 7.3
Sat Feb 09 19:23:00 2019 PST|    8| 9.1
Sun Feb 10 10:11:00 2019 PST|   11|22.1
(12 rows)


NOTICE:  [data_node_1]: 
SELECT count(*) FROM twodim
NOTICE:  [data_node_1]:
count
-----
   12
(1 row)


NOTICE:  [data_node_2]: 
SELECT * FROM twodim
ORDER BY time
NOTICE:  [data_node_2]:
time                        |Color|temp
----------------------------+-----+----
Wed Feb 01 06:01:00 2017 PST|    1| 1.1
Wed Feb 01 08:01:00 2017 PST|    1| 1.2
Fri Feb 02 08:01:00 2018 PST|    2| 1.3
Sat Feb 02 10:01:00 2019 PST|    5| 1.2
Sun Feb 03 11:11:00 2019 PST|    6| 3.5
Mon Feb 04 08:21:00 2019 PST|    4| 6.6
Mon Feb 04 10:11:00 2019 PST|    7| 7.4
Mon Feb 04 12:11:00 2019 PST|    8| 2.1
Tue Feb 05 13:31:00 2019 PST|    8| 6.3
Wed Feb 06 01:13:00 2019 PST|    7| 7.9
Wed Feb 06 02:11:00 2019 PST|    5| 1.8
Thu Feb 07 09:33:00 2019 PST|    7| 9.5
Thu Feb 07 18:44:00 2019 PST|    5| 9.7
Thu Feb 07 20:24:00 2019 PST|    6|    
Fri Feb 08 08:54:00 2019 PST|    1| 7.3
Fri Feb 08 18:14:00 2019 PST|    4| 8.2
Sat Feb 09 19:23:00 2019 PST|    8| 9.1
Sun Feb 10 16:23:00 2019 PST|    5| 7.1
Sun Feb 10 17:11:00 2019 PST|    7| 3.2
(19 rows)


NOTICE:  [data_node_2]: 
SELECT count(*) FROM twodim
NOTICE:  [data_node_2]:
count
-----
   19
(1 row)


NOTICE:  [data_node_3]: 
SELECT * FROM twodim
ORDER BY time
NOTICE:  [data_node_3]:
time                        |Color|temp
----------------------------+-----+----
Fri Feb 02 08:01:00 2018 PST|    2| 1.3
Fri Feb 01 09:11:00 2019 PST|    3| 2.1
Sat Feb 02 09:11:00 2019 PST|    3| 2.1
Sat Feb 02 10:01:00 2019 PST|    5| 1.2
Mon Feb 04 08:21:00 2019 PST|    4| 6.6
Mon Feb 04 10:11:00 2019 PST|    7| 7.4
Wed Feb 06 01:13:00 2019 PST|    7| 7.9
Wed Feb 06 02:11:00 2019 PST|    5| 1.8
Wed Feb 06 19:24:00 2019 PST|    9| 5.9
Thu Feb 07 09:33:00 2019 PST|    7| 9.5
Thu Feb 07 18:44:00 2019 PST|    5| 9.7
Fri Feb 08 18:14:00 2019 PST|    4| 8.2
Sun Feb 10 10:11:00 2019 PST|   11|22.1
Sun Feb 10 16:23:00 2019 PST|    5| 7.1
Sun Feb 10 17:11:00 2019 PST|    7| 3.2
(15 rows)


NOTICE:  [data_node_3]: 
SELECT count(*) FROM twodim
NOTICE:  [data_node_3]:
count
-----
   15
(1 row)


 remote_exec 
-------------
 
(1 row)

-- Distributed table with custom type that has no binary output
CREATE TABLE disttable_with_ct(time timestamptz, txn_id rxid, val float, info text);
SELECT * FROM create_hypertable('disttable_with_ct', 'time', replication_factor => 2);
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name |    table_name     | created 
---------------+-------------+-------------------+---------
             8 | public      | disttable_with_ct | t
(1 row)

-- Insert data with custom type
INSERT INTO disttable_with_ct VALUES
    ('2019-01-01 01:01', 'ts-1-10-20-30', 1.1, 'a'),
    ('2019-01-01 01:02', 'ts-1-11-20-30', 2.0, repeat('abc', 1000000)); -- TOAST
-- Test queries on distributed table with custom type
SELECT time, txn_id, val, substring(info for 20) FROM disttable_with_ct;
             time             |    txn_id     | val |      substring       
------------------------------+---------------+-----+----------------------
 Tue Jan 01 01:01:00 2019 PST | ts-1-10-20-30 | 1.1 | a
 Tue Jan 01 01:02:00 2019 PST | ts-1-11-20-30 |   2 | abcabcabcabcabcabcab
(2 rows)

SET timescaledb.enable_connection_binary_data=false;
SELECT time, txn_id, val, substring(info for 20) FROM disttable_with_ct;
             time             |    txn_id     | val |      substring       
------------------------------+---------------+-----+----------------------
 Tue Jan 01 01:01:00 2019 PST | ts-1-10-20-30 | 1.1 | a
 Tue Jan 01 01:02:00 2019 PST | ts-1-11-20-30 |   2 | abcabcabcabcabcabcab
(2 rows)

-- Test DELETE with replication
DELETE FROM disttable_with_ct WHERE info = 'a';
-- Check if row is gone
SELECT time, txn_id, val, substring(info for 20) FROM disttable_with_ct;
             time             |    txn_id     | val |      substring       
------------------------------+---------------+-----+----------------------
 Tue Jan 01 01:02:00 2019 PST | ts-1-11-20-30 |   2 | abcabcabcabcabcabcab
(1 row)

-- Connect to data nodes to see if data is gone
SELECT * FROM test.remote_exec('{ data_node_1, data_node_2, data_node_3 }', $$
SELECT time, txn_id, val, substring(info for 20) FROM disttable_with_ct;
$$);
NOTICE:  [data_node_1]: 
SELECT time, txn_id, val, substring(info for 20) FROM disttable_with_ct
NOTICE:  [data_node_1]:
time                        |txn_id       |val|substring           
----------------------------+-------------+---+--------------------
Tue Jan 01 01:02:00 2019 PST|ts-1-11-20-30|  2|abcabcabcabcabcabcab
(1 row)


NOTICE:  [data_node_2]: 
SELECT time, txn_id, val, substring(info for 20) FROM disttable_with_ct
NOTICE:  [data_node_2]:
time                        |txn_id       |val|substring           
----------------------------+-------------+---+--------------------
Tue Jan 01 01:02:00 2019 PST|ts-1-11-20-30|  2|abcabcabcabcabcabcab
(1 row)


NOTICE:  [data_node_3]: 
SELECT time, txn_id, val, substring(info for 20) FROM disttable_with_ct
NOTICE:  [data_node_3]:
time|txn_id|val|substring
----+------+---+---------
(0 rows)


 remote_exec 
-------------
 
(1 row)

