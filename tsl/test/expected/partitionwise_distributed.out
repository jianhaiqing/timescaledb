-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Need to be super user to create extension and add servers
\c :TEST_DBNAME :ROLE_SUPERUSER;
\ir include/remote_exec.sql
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
CREATE SCHEMA IF NOT EXISTS test;
psql:include/remote_exec.sql:5: NOTICE:  schema "test" already exists, skipping
GRANT USAGE ON SCHEMA test TO PUBLIC;
CREATE OR REPLACE FUNCTION test.remote_exec(srv_name name[], command text)
RETURNS VOID
AS :TSL_MODULE_PATHNAME, 'ts_remote_exec'
LANGUAGE C;
CREATE EXTENSION IF NOT EXISTS postgres_fdw;
-- Need explicit password for non-super users to connect
ALTER ROLE :ROLE_DEFAULT_CLUSTER_USER CREATEDB PASSWORD 'pass';
GRANT USAGE ON FOREIGN DATA WRAPPER timescaledb_fdw TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT USAGE ON FOREIGN DATA WRAPPER postgres_fdw TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Cleanup from other potential tests that created these databases
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS server_1;
DROP DATABASE IF EXISTS server_2;
SET client_min_messages TO NOTICE;
CREATE DATABASE server_1;
CREATE DATABASE server_2;
-- Creating extension is only possible as super-user
\c server_1 :ROLE_SUPERUSER
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
\c server_2 :ROLE_SUPERUSER
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
SELECT inet_server_port() AS "port" \gset
CREATE SERVER IF NOT EXISTS server_pg1 FOREIGN DATA WRAPPER postgres_fdw
OPTIONS (host 'localhost', dbname 'server_1', port :'port');
CREATE SERVER IF NOT EXISTS server_pg2 FOREIGN DATA WRAPPER postgres_fdw
OPTIONS (host 'localhost', dbname 'server_2', port :'port');
CREATE USER MAPPING IF NOT EXISTS FOR :ROLE_DEFAULT_CLUSTER_USER server server_pg1
OPTIONS (user :'ROLE_DEFAULT_CLUSTER_USER', password 'pass');
CREATE USER MAPPING IF NOT EXISTS FOR :ROLE_DEFAULT_CLUSTER_USER server server_pg2
OPTIONS (user :'ROLE_DEFAULT_CLUSTER_USER', password 'pass');
-- Create a 2-dimensional partitioned table for comparision
CREATE TABLE pg2dim (time timestamptz, device int, temp float) PARTITION BY HASH (device);
CREATE TABLE pg2dim_h1 PARTITION OF pg2dim FOR VALUES WITH (MODULUS 2, REMAINDER 0) PARTITION BY RANGE(time);
CREATE TABLE pg2dim_h2 PARTITION OF pg2dim FOR VALUES WITH (MODULUS 2, REMAINDER 1) PARTITION BY RANGE(time);
CREATE FOREIGN TABLE pg2dim_h1_t1 PARTITION OF pg2dim_h1 FOR VALUES FROM ('2018-01-18 00:00') TO ('2018-04-18 00:00') SERVER server_pg1;
CREATE FOREIGN TABLE pg2dim_h1_t2 PARTITION OF pg2dim_h1 FOR VALUES FROM ('2018-04-18 00:00') TO ('2018-07-18 00:00') SERVER server_pg1;
CREATE FOREIGN TABLE pg2dim_h2_t1 PARTITION OF pg2dim_h2 FOR VALUES FROM ('2018-01-18 00:00') TO ('2018-04-18 00:00') SERVER server_pg2;
CREATE FOREIGN TABLE pg2dim_h2_t2 PARTITION OF pg2dim_h2 FOR VALUES FROM ('2018-04-18 00:00') TO ('2018-07-18 00:00') SERVER server_pg2;
-- Create these partitioned tables on the servers
SELECT * FROM test.remote_exec('{ server_pg1, server_pg2 }', $$
CREATE TABLE pg2dim (time timestamptz, device int, temp float) PARTITION BY HASH (device);
CREATE TABLE pg2dim_h1 PARTITION OF pg2dim FOR VALUES WITH (MODULUS 2, REMAINDER 0) PARTITION BY RANGE(time);
CREATE TABLE pg2dim_h2 PARTITION OF pg2dim FOR VALUES WITH (MODULUS 2, REMAINDER 1) PARTITION BY RANGE(time);
CREATE TABLE pg2dim_h1_t1 PARTITION OF pg2dim_h1 FOR VALUES FROM ('2018-01-18 00:00') TO ('2018-04-18 00:00');
CREATE TABLE pg2dim_h1_t2 PARTITION OF pg2dim_h1 FOR VALUES FROM ('2018-04-18 00:00') TO ('2018-07-18 00:00');
CREATE TABLE pg2dim_h2_t1 PARTITION OF pg2dim_h2 FOR VALUES FROM ('2018-01-18 00:00') TO ('2018-04-18 00:00');
CREATE TABLE pg2dim_h2_t2 PARTITION OF pg2dim_h2 FOR VALUES FROM ('2018-04-18 00:00') TO ('2018-07-18 00:00');
$$);
NOTICE:  [server_pg1]: 
CREATE TABLE pg2dim (time timestamptz, device int, temp float) PARTITION BY HASH (device)
NOTICE:  [server_pg1]: 
CREATE TABLE pg2dim_h1 PARTITION OF pg2dim FOR VALUES WITH (MODULUS 2, REMAINDER 0) PARTITION BY RANGE(time)
NOTICE:  [server_pg1]: 
CREATE TABLE pg2dim_h2 PARTITION OF pg2dim FOR VALUES WITH (MODULUS 2, REMAINDER 1) PARTITION BY RANGE(time)
NOTICE:  [server_pg1]: 
CREATE TABLE pg2dim_h1_t1 PARTITION OF pg2dim_h1 FOR VALUES FROM ('2018-01-18 00:00') TO ('2018-04-18 00:00')
NOTICE:  [server_pg1]: 
CREATE TABLE pg2dim_h1_t2 PARTITION OF pg2dim_h1 FOR VALUES FROM ('2018-04-18 00:00') TO ('2018-07-18 00:00')
NOTICE:  [server_pg1]: 
CREATE TABLE pg2dim_h2_t1 PARTITION OF pg2dim_h2 FOR VALUES FROM ('2018-01-18 00:00') TO ('2018-04-18 00:00')
NOTICE:  [server_pg1]: 
CREATE TABLE pg2dim_h2_t2 PARTITION OF pg2dim_h2 FOR VALUES FROM ('2018-04-18 00:00') TO ('2018-07-18 00:00')
NOTICE:  [server_pg2]: 
CREATE TABLE pg2dim (time timestamptz, device int, temp float) PARTITION BY HASH (device)
NOTICE:  [server_pg2]: 
CREATE TABLE pg2dim_h1 PARTITION OF pg2dim FOR VALUES WITH (MODULUS 2, REMAINDER 0) PARTITION BY RANGE(time)
NOTICE:  [server_pg2]: 
CREATE TABLE pg2dim_h2 PARTITION OF pg2dim FOR VALUES WITH (MODULUS 2, REMAINDER 1) PARTITION BY RANGE(time)
NOTICE:  [server_pg2]: 
CREATE TABLE pg2dim_h1_t1 PARTITION OF pg2dim_h1 FOR VALUES FROM ('2018-01-18 00:00') TO ('2018-04-18 00:00')
NOTICE:  [server_pg2]: 
CREATE TABLE pg2dim_h1_t2 PARTITION OF pg2dim_h1 FOR VALUES FROM ('2018-04-18 00:00') TO ('2018-07-18 00:00')
NOTICE:  [server_pg2]: 
CREATE TABLE pg2dim_h2_t1 PARTITION OF pg2dim_h2 FOR VALUES FROM ('2018-01-18 00:00') TO ('2018-04-18 00:00')
NOTICE:  [server_pg2]: 
CREATE TABLE pg2dim_h2_t2 PARTITION OF pg2dim_h2 FOR VALUES FROM ('2018-04-18 00:00') TO ('2018-07-18 00:00')
 remote_exec 
-------------
 
(1 row)

-- Add servers using the TimescaleDB server management AP
SELECT * FROM add_server('server_1', database => 'server_1', password => 'pass', if_not_exists => true);
NOTICE:  remote server database "server_1" already exists, skipping
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_1    | localhost | 15432 | server_1 | default_cluster_user | default_cluster_user | t
(1 row)

SELECT * FROM add_server('server_2', database => 'server_2', password => 'pass', if_not_exists => true);
NOTICE:  remote server database "server_2" already exists, skipping
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_2    | localhost | 15432 | server_2 | default_cluster_user | default_cluster_user | t
(1 row)

CREATE TABLE hyper (time timestamptz, device int, temp float);
SELECT * FROM create_hypertable('hyper', 'time', 'device', 2, replication_factor => 1, chunk_time_interval => '3 months'::interval);
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             1 | public      | hyper      | t
(1 row)

INSERT INTO hyper VALUES
       ('2018-01-19 13:01', 1, 2.3),
       ('2018-01-20 15:05', 1, 5.3),
       ('2018-02-21 13:01', 3, 1.5),
       ('2018-02-28 15:05', 1, 5.6),
       ('2018-02-19 13:02', 3, 3.1),
       ('2018-02-19 13:02', 3, 6.7),
       ('2018-04-19 13:01', 1, 7.6),
       ('2018-04-20 15:08', 3, 8.4),
       ('2018-05-19 13:01', 1, 5.1),
       ('2018-05-20 15:08', 1, 9.4),
       ('2018-05-30 13:02', 3, 9.0);
INSERT INTO pg2dim VALUES
       ('2018-01-19 13:01', 1, 2.3),
       ('2018-01-20 15:05', 1, 5.3),
       ('2018-02-21 13:01', 3, 1.5),
       ('2018-02-28 15:05', 1, 5.6),
       ('2018-02-19 13:02', 3, 3.1),
       ('2018-02-19 13:02', 3, 6.7),
       ('2018-04-19 13:01', 1, 7.6),
       ('2018-04-20 15:08', 3, 8.4),
       ('2018-05-19 13:01', 1, 5.1),
       ('2018-05-20 15:08', 1, 9.4),
       ('2018-05-30 13:02', 3, 9.0);
SELECT * FROM test.show_subtables('hyper');
                    Child                    | Tablespace 
---------------------------------------------+------------
 _timescaledb_internal._hyper_1_1_dist_chunk | 
 _timescaledb_internal._hyper_1_2_dist_chunk | 
 _timescaledb_internal._hyper_1_3_dist_chunk | 
 _timescaledb_internal._hyper_1_4_dist_chunk | 
(4 rows)

SELECT * FROM pg2dim_h1_t1;
             time             | device | temp 
------------------------------+--------+------
 Fri Jan 19 13:01:00 2018 PST |      1 |  2.3
 Sat Jan 20 15:05:00 2018 PST |      1 |  5.3
 Wed Feb 28 15:05:00 2018 PST |      1 |  5.6
(3 rows)

SELECT * FROM pg2dim_h1_t2;
             time             | device | temp 
------------------------------+--------+------
 Thu Apr 19 13:01:00 2018 PDT |      1 |  7.6
 Sat May 19 13:01:00 2018 PDT |      1 |  5.1
 Sun May 20 15:08:00 2018 PDT |      1 |  9.4
(3 rows)

SELECT * FROM pg2dim_h2_t1;
             time             | device | temp 
------------------------------+--------+------
 Wed Feb 21 13:01:00 2018 PST |      3 |  1.5
 Mon Feb 19 13:02:00 2018 PST |      3 |  3.1
 Mon Feb 19 13:02:00 2018 PST |      3 |  6.7
(3 rows)

SELECT * FROM pg2dim_h2_t2;
             time             | device | temp 
------------------------------+--------+------
 Fri Apr 20 15:08:00 2018 PDT |      3 |  8.4
 Wed May 30 13:02:00 2018 PDT |      3 |    9
(2 rows)

SELECT * FROM  _timescaledb_internal._hyper_1_1_dist_chunk;
             time             | device | temp 
------------------------------+--------+------
 Fri Jan 19 13:01:00 2018 PST |      1 |  2.3
 Sat Jan 20 15:05:00 2018 PST |      1 |  5.3
 Wed Feb 28 15:05:00 2018 PST |      1 |  5.6
(3 rows)

SELECT * FROM  _timescaledb_internal._hyper_1_2_dist_chunk;
             time             | device | temp 
------------------------------+--------+------
 Wed Feb 21 13:01:00 2018 PST |      3 |  1.5
 Mon Feb 19 13:02:00 2018 PST |      3 |  3.1
 Mon Feb 19 13:02:00 2018 PST |      3 |  6.7
(3 rows)

SELECT * FROM  _timescaledb_internal._hyper_1_3_dist_chunk;
             time             | device | temp 
------------------------------+--------+------
 Thu Apr 19 13:01:00 2018 PDT |      1 |  7.6
 Sat May 19 13:01:00 2018 PDT |      1 |  5.1
 Sun May 20 15:08:00 2018 PDT |      1 |  9.4
(3 rows)

SELECT * FROM  _timescaledb_internal._hyper_1_4_dist_chunk;
             time             | device | temp 
------------------------------+--------+------
 Fri Apr 20 15:08:00 2018 PDT |      3 |  8.4
 Wed May 30 13:02:00 2018 PDT |      3 |    9
(2 rows)

---------------------------------------------------------------------
-- PARTIAL partitionwise - Not all partition keys are covered by GROUP
-- BY
---------------------------------------------------------------------
SET enable_partitionwise_aggregate = OFF;
EXPLAIN (VERBOSE, COSTS OFF)
SELECT device, avg(temp)
FROM pg2dim
GROUP BY 1
ORDER BY 1;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Sort
   Output: pg2dim_h1_t1.device, (avg(pg2dim_h1_t1.temp))
   Sort Key: pg2dim_h1_t1.device
   ->  HashAggregate
         Output: pg2dim_h1_t1.device, avg(pg2dim_h1_t1.temp)
         Group Key: pg2dim_h1_t1.device
         ->  Append
               ->  Foreign Scan on public.pg2dim_h1_t1
                     Output: pg2dim_h1_t1.device, pg2dim_h1_t1.temp
                     Remote SQL: SELECT device, temp FROM public.pg2dim_h1_t1
               ->  Foreign Scan on public.pg2dim_h1_t2
                     Output: pg2dim_h1_t2.device, pg2dim_h1_t2.temp
                     Remote SQL: SELECT device, temp FROM public.pg2dim_h1_t2
               ->  Foreign Scan on public.pg2dim_h2_t1
                     Output: pg2dim_h2_t1.device, pg2dim_h2_t1.temp
                     Remote SQL: SELECT device, temp FROM public.pg2dim_h2_t1
               ->  Foreign Scan on public.pg2dim_h2_t2
                     Output: pg2dim_h2_t2.device, pg2dim_h2_t2.temp
                     Remote SQL: SELECT device, temp FROM public.pg2dim_h2_t2
(19 rows)

SELECT device, avg(temp)
FROM pg2dim
GROUP BY 1
ORDER BY 1;
 device |       avg        
--------+------------------
      1 | 5.88333333333333
      3 |             5.74
(2 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT device, avg(temp)
FROM hyper
GROUP BY 1
ORDER BY 1;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: hyper.device, (avg(hyper.temp))
   Sort Key: hyper.device
   ->  HashAggregate
         Output: hyper.device, avg(hyper.temp)
         Group Key: hyper.device
         ->  Append
               ->  Foreign Scan
                     Output: hyper.device, hyper.temp
                     Server: server_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
                     Remote SQL: SELECT device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY device ASC NULLS LAST
               ->  Foreign Scan
                     Output: hyper.device, hyper.temp
                     Server: server_2
                     Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY device ASC NULLS LAST
(17 rows)

-- Show result
SELECT device, avg(temp)
FROM hyper
GROUP BY 1
ORDER BY 1;
 device |       avg        
--------+------------------
      1 | 5.88333333333333
      3 |             5.74
(2 rows)

SET enable_partitionwise_aggregate = ON;
EXPLAIN (VERBOSE, COSTS OFF)
SELECT device, avg(temp)
FROM pg2dim
GROUP BY 1
ORDER BY 1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Sort
   Output: pg2dim_h1_t1.device, (avg(pg2dim_h1_t1.temp))
   Sort Key: pg2dim_h1_t1.device
   ->  Append
         ->  Finalize HashAggregate
               Output: pg2dim_h1_t1.device, avg(pg2dim_h1_t1.temp)
               Group Key: pg2dim_h1_t1.device
               ->  Append
                     ->  Partial HashAggregate
                           Output: pg2dim_h1_t1.device, PARTIAL avg(pg2dim_h1_t1.temp)
                           Group Key: pg2dim_h1_t1.device
                           ->  Foreign Scan on public.pg2dim_h1_t1
                                 Output: pg2dim_h1_t1.device, pg2dim_h1_t1.temp
                                 Remote SQL: SELECT device, temp FROM public.pg2dim_h1_t1
                     ->  Partial HashAggregate
                           Output: pg2dim_h1_t2.device, PARTIAL avg(pg2dim_h1_t2.temp)
                           Group Key: pg2dim_h1_t2.device
                           ->  Foreign Scan on public.pg2dim_h1_t2
                                 Output: pg2dim_h1_t2.device, pg2dim_h1_t2.temp
                                 Remote SQL: SELECT device, temp FROM public.pg2dim_h1_t2
         ->  Finalize HashAggregate
               Output: pg2dim_h2_t1.device, avg(pg2dim_h2_t1.temp)
               Group Key: pg2dim_h2_t1.device
               ->  Append
                     ->  Partial HashAggregate
                           Output: pg2dim_h2_t1.device, PARTIAL avg(pg2dim_h2_t1.temp)
                           Group Key: pg2dim_h2_t1.device
                           ->  Foreign Scan on public.pg2dim_h2_t1
                                 Output: pg2dim_h2_t1.device, pg2dim_h2_t1.temp
                                 Remote SQL: SELECT device, temp FROM public.pg2dim_h2_t1
                     ->  Partial HashAggregate
                           Output: pg2dim_h2_t2.device, PARTIAL avg(pg2dim_h2_t2.temp)
                           Group Key: pg2dim_h2_t2.device
                           ->  Foreign Scan on public.pg2dim_h2_t2
                                 Output: pg2dim_h2_t2.device, pg2dim_h2_t2.temp
                                 Remote SQL: SELECT device, temp FROM public.pg2dim_h2_t2
(36 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT device, avg(temp)
FROM hyper
GROUP BY 1
ORDER BY 1;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Output: hyper.device, avg(hyper.temp)
   Group Key: hyper.device
   ->  Merge Append
         Sort Key: hyper.device
         ->  Partial GroupAggregate
               Output: hyper.device, PARTIAL avg(hyper.temp)
               Group Key: hyper.device
               ->  Foreign Scan
                     Output: hyper.device, hyper.temp
                     Server: server_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
                     Remote SQL: SELECT device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY device ASC NULLS LAST
         ->  Partial GroupAggregate
               Output: hyper.device, PARTIAL avg(hyper.temp)
               Group Key: hyper.device
               ->  Foreign Scan
                     Output: hyper.device, hyper.temp
                     Server: server_2
                     Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY device ASC NULLS LAST
(21 rows)

-- Show result
SELECT device, avg(temp)
FROM hyper
GROUP BY 1
ORDER BY 1;
 device |       avg        
--------+------------------
      1 | 5.88333333333333
      3 |             5.74
(2 rows)

--------------------------------------------------------------
-- FULL partitionwise - All partition keys covered by GROUP BY
--------------------------------------------------------------
SET enable_partitionwise_aggregate = OFF;
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp)
FROM pg2dim
GROUP BY 1, 2
ORDER BY 1, 2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort
   Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, (avg(pg2dim_h1_t1.temp))
   Sort Key: pg2dim_h1_t1."time", pg2dim_h1_t1.device
   ->  HashAggregate
         Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, avg(pg2dim_h1_t1.temp)
         Group Key: pg2dim_h1_t1."time", pg2dim_h1_t1.device
         ->  Append
               ->  Foreign Scan on public.pg2dim_h1_t1
                     Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, pg2dim_h1_t1.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t1
               ->  Foreign Scan on public.pg2dim_h1_t2
                     Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, pg2dim_h1_t2.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t2
               ->  Foreign Scan on public.pg2dim_h2_t1
                     Output: pg2dim_h2_t1."time", pg2dim_h2_t1.device, pg2dim_h2_t1.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t1
               ->  Foreign Scan on public.pg2dim_h2_t2
                     Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, pg2dim_h2_t2.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t2
(19 rows)

SELECT time, device, avg(temp)
FROM pg2dim
GROUP BY 1, 2
ORDER BY 1, 2;
             time             | device | avg 
------------------------------+--------+-----
 Fri Jan 19 13:01:00 2018 PST |      1 | 2.3
 Sat Jan 20 15:05:00 2018 PST |      1 | 5.3
 Mon Feb 19 13:02:00 2018 PST |      3 | 4.9
 Wed Feb 21 13:01:00 2018 PST |      3 | 1.5
 Wed Feb 28 15:05:00 2018 PST |      1 | 5.6
 Thu Apr 19 13:01:00 2018 PDT |      1 | 7.6
 Fri Apr 20 15:08:00 2018 PDT |      3 | 8.4
 Sat May 19 13:01:00 2018 PDT |      1 | 5.1
 Sun May 20 15:08:00 2018 PDT |      1 | 9.4
 Wed May 30 13:02:00 2018 PDT |      3 |   9
(10 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: hyper."time", hyper.device, avg(hyper.temp)
   Group Key: hyper."time", hyper.device
   ->  Merge Append
         Sort Key: hyper."time", hyper.device
         ->  Foreign Scan
               Output: hyper."time", hyper.device, hyper.temp
               Server: server_1
               Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
               Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY "time" ASC NULLS LAST, device ASC NULLS LAST
         ->  Foreign Scan
               Output: hyper."time", hyper.device, hyper.temp
               Server: server_2
               Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
               Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY "time" ASC NULLS LAST, device ASC NULLS LAST
(15 rows)

-- Show result
SELECT time, device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
             time             | device | avg 
------------------------------+--------+-----
 Fri Jan 19 13:01:00 2018 PST |      1 | 2.3
 Sat Jan 20 15:05:00 2018 PST |      1 | 5.3
 Mon Feb 19 13:02:00 2018 PST |      3 | 4.9
 Wed Feb 21 13:01:00 2018 PST |      3 | 1.5
 Wed Feb 28 15:05:00 2018 PST |      1 | 5.6
 Thu Apr 19 13:01:00 2018 PDT |      1 | 7.6
 Fri Apr 20 15:08:00 2018 PDT |      3 | 8.4
 Sat May 19 13:01:00 2018 PDT |      1 | 5.1
 Sun May 20 15:08:00 2018 PDT |      1 | 9.4
 Wed May 30 13:02:00 2018 PDT |      3 |   9
(10 rows)

SET enable_partitionwise_aggregate = ON;
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp)
FROM pg2dim
GROUP BY 1, 2
ORDER BY 1, 2;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort
   Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, (avg(pg2dim_h1_t1.temp))
   Sort Key: pg2dim_h1_t1."time", pg2dim_h1_t1.device
   ->  Append
         ->  Foreign Scan
               Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, (avg(pg2dim_h1_t1.temp))
               Relations: Aggregate on (public.pg2dim_h1_t1 pg2dim)
               Remote SQL: SELECT "time", device, avg(temp) FROM public.pg2dim_h1_t1 GROUP BY 1, 2
         ->  Foreign Scan
               Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, (avg(pg2dim_h1_t2.temp))
               Relations: Aggregate on (public.pg2dim_h1_t2 pg2dim)
               Remote SQL: SELECT "time", device, avg(temp) FROM public.pg2dim_h1_t2 GROUP BY 1, 2
         ->  Foreign Scan
               Output: pg2dim_h2_t1."time", pg2dim_h2_t1.device, (avg(pg2dim_h2_t1.temp))
               Relations: Aggregate on (public.pg2dim_h2_t1 pg2dim)
               Remote SQL: SELECT "time", device, avg(temp) FROM public.pg2dim_h2_t1 GROUP BY 1, 2
         ->  Foreign Scan
               Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, (avg(pg2dim_h2_t2.temp))
               Relations: Aggregate on (public.pg2dim_h2_t2 pg2dim)
               Remote SQL: SELECT "time", device, avg(temp) FROM public.pg2dim_h2_t2 GROUP BY 1, 2
(20 rows)

-- On hypertable, first show partitionwise aggs without per-server queries
SET timescaledb.enable_per_server_queries = OFF;
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: _hyper_1_1_dist_chunk."time", _hyper_1_1_dist_chunk.device, (avg(_hyper_1_1_dist_chunk.temp))
   Sort Key: _hyper_1_1_dist_chunk."time", _hyper_1_1_dist_chunk.device
   ->  Append
         ->  Foreign Scan
               Output: _hyper_1_1_dist_chunk."time", _hyper_1_1_dist_chunk.device, (avg(_hyper_1_1_dist_chunk.temp))
               Relations: Aggregate on (_timescaledb_internal._hyper_1_1_dist_chunk hyper)
               Server: server_1
               Remote SQL: SELECT "time", device, avg(temp) FROM _timescaledb_internal._hyper_1_1_dist_chunk GROUP BY 1, 2
         ->  Foreign Scan
               Output: _hyper_1_2_dist_chunk."time", _hyper_1_2_dist_chunk.device, (avg(_hyper_1_2_dist_chunk.temp))
               Relations: Aggregate on (_timescaledb_internal._hyper_1_2_dist_chunk hyper)
               Server: server_2
               Remote SQL: SELECT "time", device, avg(temp) FROM _timescaledb_internal._hyper_1_2_dist_chunk GROUP BY 1, 2
         ->  Foreign Scan
               Output: _hyper_1_3_dist_chunk."time", _hyper_1_3_dist_chunk.device, (avg(_hyper_1_3_dist_chunk.temp))
               Relations: Aggregate on (_timescaledb_internal._hyper_1_3_dist_chunk hyper)
               Server: server_1
               Remote SQL: SELECT "time", device, avg(temp) FROM _timescaledb_internal._hyper_1_3_dist_chunk GROUP BY 1, 2
         ->  Foreign Scan
               Output: _hyper_1_4_dist_chunk."time", _hyper_1_4_dist_chunk.device, (avg(_hyper_1_4_dist_chunk.temp))
               Relations: Aggregate on (_timescaledb_internal._hyper_1_4_dist_chunk hyper)
               Server: server_2
               Remote SQL: SELECT "time", device, avg(temp) FROM _timescaledb_internal._hyper_1_4_dist_chunk GROUP BY 1, 2
(24 rows)

SELECT time, device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
             time             | device | avg 
------------------------------+--------+-----
 Fri Jan 19 13:01:00 2018 PST |      1 | 2.3
 Sat Jan 20 15:05:00 2018 PST |      1 | 5.3
 Mon Feb 19 13:02:00 2018 PST |      3 | 4.9
 Wed Feb 21 13:01:00 2018 PST |      3 | 1.5
 Wed Feb 28 15:05:00 2018 PST |      1 | 5.6
 Thu Apr 19 13:01:00 2018 PDT |      1 | 7.6
 Fri Apr 20 15:08:00 2018 PDT |      3 | 8.4
 Sat May 19 13:01:00 2018 PDT |      1 | 5.1
 Sun May 20 15:08:00 2018 PDT |      1 | 9.4
 Wed May 30 13:02:00 2018 PDT |      3 |   9
(10 rows)

-- Enable per-server queries. Aggregate should be pushed down per
-- server instead of per chunk.
SET timescaledb.enable_per_server_queries = ON;
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: hyper."time", hyper.device, (avg(hyper.temp))
   Sort Key: hyper."time", hyper.device
   ->  Append
         ->  Foreign Scan
               Output: hyper."time", hyper.device, (avg(hyper.temp))
               Relations: Aggregate on (public.hyper)
               Server: server_1
               Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
               Remote SQL: SELECT "time", device, avg(temp) FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) GROUP BY 1, 2
         ->  Foreign Scan
               Output: hyper."time", hyper.device, (avg(hyper.temp))
               Relations: Aggregate on (public.hyper)
               Server: server_2
               Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
               Remote SQL: SELECT "time", device, avg(temp) FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) GROUP BY 1, 2
(16 rows)

-- Show result
SELECT time, device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
             time             | device | avg 
------------------------------+--------+-----
 Fri Jan 19 13:01:00 2018 PST |      1 | 2.3
 Sat Jan 20 15:05:00 2018 PST |      1 | 5.3
 Mon Feb 19 13:02:00 2018 PST |      3 | 4.9
 Wed Feb 21 13:01:00 2018 PST |      3 | 1.5
 Wed Feb 28 15:05:00 2018 PST |      1 | 5.6
 Thu Apr 19 13:01:00 2018 PDT |      1 | 7.6
 Fri Apr 20 15:08:00 2018 PDT |      3 | 8.4
 Sat May 19 13:01:00 2018 PDT |      1 | 5.1
 Sun May 20 15:08:00 2018 PDT |      1 | 9.4
 Wed May 30 13:02:00 2018 PDT |      3 |   9
(10 rows)

-- Only one chunk per server, still uses per-server plan.  Not
-- choosing pushed down aggregate plan here, probably due to costing.
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp)
FROM hyper
WHERE time > '2018-04-19 00:01'
GROUP BY 1, 2
ORDER BY 1, 2;
                                                                                                QUERY PLAN                                                                                                
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: hyper."time", hyper.device, (avg(hyper.temp))
   Sort Key: hyper."time", hyper.device
   ->  Append
         ->  HashAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp)
               Group Key: hyper."time", hyper.device
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Server: server_1
                     Chunks: _hyper_1_3_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[2]) AND (("time" > '2018-04-19 00:01:00-07'::timestamp with time zone))
         ->  HashAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp)
               Group Key: hyper."time", hyper.device
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Server: server_2
                     Chunks: _hyper_1_4_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[2]) AND (("time" > '2018-04-19 00:01:00-07'::timestamp with time zone))
(20 rows)

-- Test HAVING qual
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp) AS temp
FROM pg2dim
WHERE time > '2018-04-19 00:01'
GROUP BY 1, 2
HAVING avg(temp) > 4
ORDER BY 1, 2;
                                                                                                     QUERY PLAN                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, (avg(pg2dim_h1_t2.temp))
   Sort Key: pg2dim_h1_t2."time", pg2dim_h1_t2.device
   ->  Append
         ->  Foreign Scan
               Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, (avg(pg2dim_h1_t2.temp))
               Relations: Aggregate on (public.pg2dim_h1_t2 pg2dim)
               Remote SQL: SELECT "time", device, avg(temp) FROM public.pg2dim_h1_t2 WHERE (("time" > '2018-04-19 00:01:00-07'::timestamp with time zone)) GROUP BY 1, 2 HAVING ((avg(temp) > 4::double precision))
         ->  Foreign Scan
               Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, (avg(pg2dim_h2_t2.temp))
               Relations: Aggregate on (public.pg2dim_h2_t2 pg2dim)
               Remote SQL: SELECT "time", device, avg(temp) FROM public.pg2dim_h2_t2 WHERE (("time" > '2018-04-19 00:01:00-07'::timestamp with time zone)) GROUP BY 1, 2 HAVING ((avg(temp) > 4::double precision))
(12 rows)

SELECT time, device, avg(temp) AS temp
FROM pg2dim
WHERE time > '2018-04-19 00:01'
GROUP BY 1, 2
HAVING avg(temp) > 4
ORDER BY 1, 2;
             time             | device | temp 
------------------------------+--------+------
 Thu Apr 19 13:01:00 2018 PDT |      1 |  7.6
 Fri Apr 20 15:08:00 2018 PDT |      3 |  8.4
 Sat May 19 13:01:00 2018 PDT |      1 |  5.1
 Sun May 20 15:08:00 2018 PDT |      1 |  9.4
 Wed May 30 13:02:00 2018 PDT |      3 |    9
(5 rows)

-- Test HAVING qual. Not choosing pushed down aggregate plan here,
-- probably due to costing.
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp) AS temp
FROM hyper
WHERE time > '2018-04-19 00:01'
GROUP BY 1, 2
HAVING avg(temp) > 4
ORDER BY 1, 2;
                                                                                                QUERY PLAN                                                                                                
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: hyper."time", hyper.device, (avg(hyper.temp))
   Sort Key: hyper."time", hyper.device
   ->  Append
         ->  HashAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp)
               Group Key: hyper."time", hyper.device
               Filter: (avg(hyper.temp) > '4'::double precision)
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Server: server_1
                     Chunks: _hyper_1_3_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[2]) AND (("time" > '2018-04-19 00:01:00-07'::timestamp with time zone))
         ->  HashAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp)
               Group Key: hyper."time", hyper.device
               Filter: (avg(hyper.temp) > '4'::double precision)
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Server: server_2
                     Chunks: _hyper_1_4_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[2]) AND (("time" > '2018-04-19 00:01:00-07'::timestamp with time zone))
(22 rows)

SELECT time, device, avg(temp) AS temp
FROM hyper
WHERE time > '2018-04-19 00:01'
GROUP BY 1, 2
HAVING avg(temp) > 4
ORDER BY 1, 2;
             time             | device | temp 
------------------------------+--------+------
 Thu Apr 19 13:01:00 2018 PDT |      1 |  7.6
 Fri Apr 20 15:08:00 2018 PDT |      3 |  8.4
 Sat May 19 13:01:00 2018 PDT |      1 |  5.1
 Sun May 20 15:08:00 2018 PDT |      1 |  9.4
 Wed May 30 13:02:00 2018 PDT |      3 |    9
(5 rows)

-------------------------------------------------------------------
-- All partition keys not covered by GROUP BY because of date_trunc
-- expression on time (partial partitionwise). This won't be pushed
-- down a.t.m., since no way to send partials
-------------------------------------------------------------------
SET enable_partitionwise_aggregate = OFF;
EXPLAIN (VERBOSE, COSTS OFF)
SELECT date_trunc('month', time), device, avg(temp)
FROM pg2dim
GROUP BY 1, 2
ORDER BY 1, 2;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (date_trunc('month'::text, pg2dim_h1_t1."time")), pg2dim_h1_t1.device, (avg(pg2dim_h1_t1.temp))
   Sort Key: (date_trunc('month'::text, pg2dim_h1_t1."time")), pg2dim_h1_t1.device
   ->  HashAggregate
         Output: (date_trunc('month'::text, pg2dim_h1_t1."time")), pg2dim_h1_t1.device, avg(pg2dim_h1_t1.temp)
         Group Key: (date_trunc('month'::text, pg2dim_h1_t1."time")), pg2dim_h1_t1.device
         ->  Append
               ->  Foreign Scan on public.pg2dim_h1_t1
                     Output: date_trunc('month'::text, pg2dim_h1_t1."time"), pg2dim_h1_t1.device, pg2dim_h1_t1.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t1
               ->  Foreign Scan on public.pg2dim_h1_t2
                     Output: date_trunc('month'::text, pg2dim_h1_t2."time"), pg2dim_h1_t2.device, pg2dim_h1_t2.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t2
               ->  Foreign Scan on public.pg2dim_h2_t1
                     Output: date_trunc('month'::text, pg2dim_h2_t1."time"), pg2dim_h2_t1.device, pg2dim_h2_t1.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t1
               ->  Foreign Scan on public.pg2dim_h2_t2
                     Output: date_trunc('month'::text, pg2dim_h2_t2."time"), pg2dim_h2_t2.device, pg2dim_h2_t2.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t2
(19 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT date_trunc('month', time), device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (date_trunc('month'::text, hyper."time")), hyper.device, (avg(hyper.temp))
   Sort Key: (date_trunc('month'::text, hyper."time")), hyper.device
   ->  HashAggregate
         Output: (date_trunc('month'::text, hyper."time")), hyper.device, avg(hyper.temp)
         Group Key: (date_trunc('month'::text, hyper."time")), hyper.device
         ->  Append
               ->  Foreign Scan
                     Output: date_trunc('month'::text, hyper."time"), hyper.device, hyper.temp
                     Server: server_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2])
               ->  Foreign Scan
                     Output: date_trunc('month'::text, hyper."time"), hyper.device, hyper.temp
                     Server: server_2
                     Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2])
(17 rows)

-- Show result
SELECT date_trunc('month', time), device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
          date_trunc          | device |       avg        
------------------------------+--------+------------------
 Mon Jan 01 00:00:00 2018 PST |      1 |              3.8
 Thu Feb 01 00:00:00 2018 PST |      1 |              5.6
 Thu Feb 01 00:00:00 2018 PST |      3 | 3.76666666666667
 Sun Apr 01 00:00:00 2018 PDT |      1 |              7.6
 Sun Apr 01 00:00:00 2018 PDT |      3 |              8.4
 Tue May 01 00:00:00 2018 PDT |      1 |             7.25
 Tue May 01 00:00:00 2018 PDT |      3 |                9
(7 rows)

SET enable_partitionwise_aggregate = ON;
EXPLAIN (VERBOSE, COSTS OFF)
SELECT date_trunc('month', time), device, avg(temp)
FROM pg2dim
GROUP BY 1, 2
ORDER BY 1, 2;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Merge Append
   Sort Key: (date_trunc('month'::text, pg2dim_h1_t1."time")), pg2dim_h1_t1.device
   ->  Finalize GroupAggregate
         Output: (date_trunc('month'::text, pg2dim_h1_t1."time")), pg2dim_h1_t1.device, avg(pg2dim_h1_t1.temp)
         Group Key: (date_trunc('month'::text, pg2dim_h1_t1."time")), pg2dim_h1_t1.device
         ->  Sort
               Output: (date_trunc('month'::text, pg2dim_h1_t1."time")), pg2dim_h1_t1.device, (PARTIAL avg(pg2dim_h1_t1.temp))
               Sort Key: (date_trunc('month'::text, pg2dim_h1_t1."time")), pg2dim_h1_t1.device
               ->  Append
                     ->  Partial HashAggregate
                           Output: (date_trunc('month'::text, pg2dim_h1_t1."time")), pg2dim_h1_t1.device, PARTIAL avg(pg2dim_h1_t1.temp)
                           Group Key: date_trunc('month'::text, pg2dim_h1_t1."time"), pg2dim_h1_t1.device
                           ->  Foreign Scan on public.pg2dim_h1_t1
                                 Output: date_trunc('month'::text, pg2dim_h1_t1."time"), pg2dim_h1_t1.device, pg2dim_h1_t1.temp
                                 Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t1
                     ->  Partial HashAggregate
                           Output: (date_trunc('month'::text, pg2dim_h1_t2."time")), pg2dim_h1_t2.device, PARTIAL avg(pg2dim_h1_t2.temp)
                           Group Key: date_trunc('month'::text, pg2dim_h1_t2."time"), pg2dim_h1_t2.device
                           ->  Foreign Scan on public.pg2dim_h1_t2
                                 Output: date_trunc('month'::text, pg2dim_h1_t2."time"), pg2dim_h1_t2.device, pg2dim_h1_t2.temp
                                 Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t2
   ->  Finalize GroupAggregate
         Output: (date_trunc('month'::text, pg2dim_h2_t1."time")), pg2dim_h2_t1.device, avg(pg2dim_h2_t1.temp)
         Group Key: (date_trunc('month'::text, pg2dim_h2_t1."time")), pg2dim_h2_t1.device
         ->  Sort
               Output: (date_trunc('month'::text, pg2dim_h2_t1."time")), pg2dim_h2_t1.device, (PARTIAL avg(pg2dim_h2_t1.temp))
               Sort Key: (date_trunc('month'::text, pg2dim_h2_t1."time")), pg2dim_h2_t1.device
               ->  Append
                     ->  Partial HashAggregate
                           Output: (date_trunc('month'::text, pg2dim_h2_t1."time")), pg2dim_h2_t1.device, PARTIAL avg(pg2dim_h2_t1.temp)
                           Group Key: date_trunc('month'::text, pg2dim_h2_t1."time"), pg2dim_h2_t1.device
                           ->  Foreign Scan on public.pg2dim_h2_t1
                                 Output: date_trunc('month'::text, pg2dim_h2_t1."time"), pg2dim_h2_t1.device, pg2dim_h2_t1.temp
                                 Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t1
                     ->  Partial HashAggregate
                           Output: (date_trunc('month'::text, pg2dim_h2_t2."time")), pg2dim_h2_t2.device, PARTIAL avg(pg2dim_h2_t2.temp)
                           Group Key: date_trunc('month'::text, pg2dim_h2_t2."time"), pg2dim_h2_t2.device
                           ->  Foreign Scan on public.pg2dim_h2_t2
                                 Output: date_trunc('month'::text, pg2dim_h2_t2."time"), pg2dim_h2_t2.device, pg2dim_h2_t2.temp
                                 Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t2
(40 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT date_trunc('month', time), device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (date_trunc('month'::text, hyper."time")), hyper.device, (avg(hyper.temp))
   Sort Key: (date_trunc('month'::text, hyper."time")), hyper.device
   ->  Finalize HashAggregate
         Output: (date_trunc('month'::text, hyper."time")), hyper.device, avg(hyper.temp)
         Group Key: (date_trunc('month'::text, hyper."time")), hyper.device
         ->  Append
               ->  Partial HashAggregate
                     Output: (date_trunc('month'::text, hyper."time")), hyper.device, PARTIAL avg(hyper.temp)
                     Group Key: date_trunc('month'::text, hyper."time"), hyper.device
                     ->  Foreign Scan
                           Output: date_trunc('month'::text, hyper."time"), hyper.device, hyper.temp
                           Server: server_1
                           Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
                           Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2])
               ->  Partial HashAggregate
                     Output: (date_trunc('month'::text, hyper."time")), hyper.device, PARTIAL avg(hyper.temp)
                     Group Key: date_trunc('month'::text, hyper."time"), hyper.device
                     ->  Foreign Scan
                           Output: date_trunc('month'::text, hyper."time"), hyper.device, hyper.temp
                           Server: server_2
                           Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
                           Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2])
(23 rows)

-- Show result by month
SELECT date_trunc('month', time), device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
          date_trunc          | device |       avg        
------------------------------+--------+------------------
 Mon Jan 01 00:00:00 2018 PST |      1 |              3.8
 Thu Feb 01 00:00:00 2018 PST |      1 |              5.6
 Thu Feb 01 00:00:00 2018 PST |      3 | 3.76666666666667
 Sun Apr 01 00:00:00 2018 PDT |      1 |              7.6
 Sun Apr 01 00:00:00 2018 PDT |      3 |              8.4
 Tue May 01 00:00:00 2018 PDT |      1 |             7.25
 Tue May 01 00:00:00 2018 PDT |      3 |                9
(7 rows)

-- Show result by year
SELECT date_trunc('year', time), device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
          date_trunc          | device |       avg        
------------------------------+--------+------------------
 Mon Jan 01 00:00:00 2018 PST |      1 | 5.88333333333333
 Mon Jan 01 00:00:00 2018 PST |      3 |             5.74
(2 rows)

-------------------------------------------------------
-- Test time_bucket (only supports up to days grouping)
-------------------------------------------------------
SET enable_partitionwise_aggregate = OFF;
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time_bucket('1 day', time), device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (time_bucket('@ 1 day'::interval, hyper."time")), hyper.device, (avg(hyper.temp))
   Sort Key: (time_bucket('@ 1 day'::interval, hyper."time")), hyper.device
   ->  HashAggregate
         Output: (time_bucket('@ 1 day'::interval, hyper."time")), hyper.device, avg(hyper.temp)
         Group Key: (time_bucket('@ 1 day'::interval, hyper."time")), hyper.device
         ->  Append
               ->  Foreign Scan
                     Output: time_bucket('@ 1 day'::interval, hyper."time"), hyper.device, hyper.temp
                     Server: server_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2])
               ->  Foreign Scan
                     Output: time_bucket('@ 1 day'::interval, hyper."time"), hyper.device, hyper.temp
                     Server: server_2
                     Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2])
(17 rows)

-- Show result
SELECT time_bucket('1 day', time), device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
         time_bucket          | device | avg 
------------------------------+--------+-----
 Thu Jan 18 16:00:00 2018 PST |      1 | 2.3
 Fri Jan 19 16:00:00 2018 PST |      1 | 5.3
 Sun Feb 18 16:00:00 2018 PST |      3 | 4.9
 Tue Feb 20 16:00:00 2018 PST |      3 | 1.5
 Tue Feb 27 16:00:00 2018 PST |      1 | 5.6
 Wed Apr 18 17:00:00 2018 PDT |      1 | 7.6
 Thu Apr 19 17:00:00 2018 PDT |      3 | 8.4
 Fri May 18 17:00:00 2018 PDT |      1 | 5.1
 Sat May 19 17:00:00 2018 PDT |      1 | 9.4
 Tue May 29 17:00:00 2018 PDT |      3 |   9
(10 rows)

SET enable_partitionwise_aggregate = ON;
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time_bucket('1 day', time), device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (time_bucket('@ 1 day'::interval, hyper."time")), hyper.device, (avg(hyper.temp))
   Sort Key: (time_bucket('@ 1 day'::interval, hyper."time")), hyper.device
   ->  Finalize HashAggregate
         Output: (time_bucket('@ 1 day'::interval, hyper."time")), hyper.device, avg(hyper.temp)
         Group Key: (time_bucket('@ 1 day'::interval, hyper."time")), hyper.device
         ->  Append
               ->  Partial HashAggregate
                     Output: (time_bucket('@ 1 day'::interval, hyper."time")), hyper.device, PARTIAL avg(hyper.temp)
                     Group Key: time_bucket('@ 1 day'::interval, hyper."time"), hyper.device
                     ->  Foreign Scan
                           Output: time_bucket('@ 1 day'::interval, hyper."time"), hyper.device, hyper.temp
                           Server: server_1
                           Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
                           Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2])
               ->  Partial HashAggregate
                     Output: (time_bucket('@ 1 day'::interval, hyper."time")), hyper.device, PARTIAL avg(hyper.temp)
                     Group Key: time_bucket('@ 1 day'::interval, hyper."time"), hyper.device
                     ->  Foreign Scan
                           Output: time_bucket('@ 1 day'::interval, hyper."time"), hyper.device, hyper.temp
                           Server: server_2
                           Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
                           Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2])
(23 rows)

-- Show result
SELECT time_bucket('1 day', time), device, avg(temp)
FROM hyper
GROUP BY 1, 2
ORDER BY 1, 2;
         time_bucket          | device | avg 
------------------------------+--------+-----
 Thu Jan 18 16:00:00 2018 PST |      1 | 2.3
 Fri Jan 19 16:00:00 2018 PST |      1 | 5.3
 Sun Feb 18 16:00:00 2018 PST |      3 | 4.9
 Tue Feb 20 16:00:00 2018 PST |      3 | 1.5
 Tue Feb 27 16:00:00 2018 PST |      1 | 5.6
 Wed Apr 18 17:00:00 2018 PDT |      1 | 7.6
 Thu Apr 19 17:00:00 2018 PDT |      3 | 8.4
 Fri May 18 17:00:00 2018 PDT |      1 | 5.1
 Sat May 19 17:00:00 2018 PDT |      1 | 9.4
 Tue May 29 17:00:00 2018 PDT |      3 |   9
(10 rows)

---------------------------------------------------------------------
-- Test expressions that either aren't pushed down or only pushed down
-- in parts
---------------------------------------------------------------------
-- Create a custom aggregate that does not exist on the data nodes
CREATE AGGREGATE custom_sum(int4) (
    SFUNC = int4_sum,
    STYPE = int8
);
-- sum contains random(), so not pushed down to servers
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp), sum(temp * (random() <= 1)::int) as sum
FROM pg2dim
GROUP BY 1, 2
LIMIT 1;
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, (avg(pg2dim_h1_t1.temp)), (sum((pg2dim_h1_t1.temp * (((random() <= '1'::double precision))::integer)::double precision)))
   ->  Append
         ->  HashAggregate
               Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, avg(pg2dim_h1_t1.temp), sum((pg2dim_h1_t1.temp * (((random() <= '1'::double precision))::integer)::double precision))
               Group Key: pg2dim_h1_t1."time", pg2dim_h1_t1.device
               ->  Foreign Scan on public.pg2dim_h1_t1
                     Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, pg2dim_h1_t1.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t1
         ->  HashAggregate
               Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, avg(pg2dim_h1_t2.temp), sum((pg2dim_h1_t2.temp * (((random() <= '1'::double precision))::integer)::double precision))
               Group Key: pg2dim_h1_t2."time", pg2dim_h1_t2.device
               ->  Foreign Scan on public.pg2dim_h1_t2
                     Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, pg2dim_h1_t2.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t2
         ->  HashAggregate
               Output: pg2dim_h2_t1."time", pg2dim_h2_t1.device, avg(pg2dim_h2_t1.temp), sum((pg2dim_h2_t1.temp * (((random() <= '1'::double precision))::integer)::double precision))
               Group Key: pg2dim_h2_t1."time", pg2dim_h2_t1.device
               ->  Foreign Scan on public.pg2dim_h2_t1
                     Output: pg2dim_h2_t1."time", pg2dim_h2_t1.device, pg2dim_h2_t1.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t1
         ->  HashAggregate
               Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, avg(pg2dim_h2_t2.temp), sum((pg2dim_h2_t2.temp * (((random() <= '1'::double precision))::integer)::double precision))
               Group Key: pg2dim_h2_t2."time", pg2dim_h2_t2.device
               ->  Foreign Scan on public.pg2dim_h2_t2
                     Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, pg2dim_h2_t2.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t2
(27 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp), sum(temp * (random() <= 1)::int) as sum
FROM hyper
GROUP BY 1, 2
LIMIT 1;
                                                                                          QUERY PLAN                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: hyper."time", hyper.device, (avg(hyper.temp)), (sum((hyper.temp * (((random() <= '1'::double precision))::integer)::double precision)))
   ->  Append
         ->  GroupAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp), sum((hyper.temp * (((random() <= '1'::double precision))::integer)::double precision))
               Group Key: hyper."time", hyper.device
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Server: server_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY "time" ASC NULLS LAST, device ASC NULLS LAST
         ->  GroupAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp), sum((hyper.temp * (((random() <= '1'::double precision))::integer)::double precision))
               Group Key: hyper."time", hyper.device
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Server: server_2
                     Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY "time" ASC NULLS LAST, device ASC NULLS LAST
(19 rows)

-- Pushed down with non-pushable expression taken out
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp), random() * device as rand_dev, custom_sum(device)
FROM pg2dim
GROUP BY 1, 2
LIMIT 1;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, (avg(pg2dim_h1_t1.temp)), ((random() * (pg2dim_h1_t1.device)::double precision)), (custom_sum(pg2dim_h1_t1.device))
   ->  Append
         ->  HashAggregate
               Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, avg(pg2dim_h1_t1.temp), (random() * (pg2dim_h1_t1.device)::double precision), custom_sum(pg2dim_h1_t1.device)
               Group Key: pg2dim_h1_t1."time", pg2dim_h1_t1.device
               ->  Foreign Scan on public.pg2dim_h1_t1
                     Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, pg2dim_h1_t1.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t1
         ->  HashAggregate
               Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, avg(pg2dim_h1_t2.temp), (random() * (pg2dim_h1_t2.device)::double precision), custom_sum(pg2dim_h1_t2.device)
               Group Key: pg2dim_h1_t2."time", pg2dim_h1_t2.device
               ->  Foreign Scan on public.pg2dim_h1_t2
                     Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, pg2dim_h1_t2.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t2
         ->  HashAggregate
               Output: pg2dim_h2_t1."time", pg2dim_h2_t1.device, avg(pg2dim_h2_t1.temp), (random() * (pg2dim_h2_t1.device)::double precision), custom_sum(pg2dim_h2_t1.device)
               Group Key: pg2dim_h2_t1."time", pg2dim_h2_t1.device
               ->  Foreign Scan on public.pg2dim_h2_t1
                     Output: pg2dim_h2_t1."time", pg2dim_h2_t1.device, pg2dim_h2_t1.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t1
         ->  HashAggregate
               Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, avg(pg2dim_h2_t2.temp), (random() * (pg2dim_h2_t2.device)::double precision), custom_sum(pg2dim_h2_t2.device)
               Group Key: pg2dim_h2_t2."time", pg2dim_h2_t2.device
               ->  Foreign Scan on public.pg2dim_h2_t2
                     Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, pg2dim_h2_t2.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t2
(27 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp), random() * device as rand_dev, custom_sum(device)
FROM hyper
GROUP BY 1, 2
LIMIT 1;
                                                                                          QUERY PLAN                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: hyper."time", hyper.device, (avg(hyper.temp)), ((random() * (hyper.device)::double precision)), (custom_sum(hyper.device))
   ->  Append
         ->  GroupAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp), (random() * (hyper.device)::double precision), custom_sum(hyper.device)
               Group Key: hyper."time", hyper.device
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Server: server_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY "time" ASC NULLS LAST, device ASC NULLS LAST
         ->  GroupAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp), (random() * (hyper.device)::double precision), custom_sum(hyper.device)
               Group Key: hyper."time", hyper.device
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Server: server_2
                     Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY "time" ASC NULLS LAST, device ASC NULLS LAST
(19 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp), sum(temp) * random() * device as sum_temp
FROM pg2dim
GROUP BY 1, 2
HAVING avg(temp) * custom_sum(device) > 0.8
LIMIT 1;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, (avg(pg2dim_h1_t1.temp)), (((sum(pg2dim_h1_t1.temp) * random()) * (pg2dim_h1_t1.device)::double precision))
   ->  Append
         ->  HashAggregate
               Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, avg(pg2dim_h1_t1.temp), ((sum(pg2dim_h1_t1.temp) * random()) * (pg2dim_h1_t1.device)::double precision)
               Group Key: pg2dim_h1_t1."time", pg2dim_h1_t1.device
               Filter: ((avg(pg2dim_h1_t1.temp) * (custom_sum(pg2dim_h1_t1.device))::double precision) > '0.8'::double precision)
               ->  Foreign Scan on public.pg2dim_h1_t1
                     Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, pg2dim_h1_t1.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t1
         ->  HashAggregate
               Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, avg(pg2dim_h1_t2.temp), ((sum(pg2dim_h1_t2.temp) * random()) * (pg2dim_h1_t2.device)::double precision)
               Group Key: pg2dim_h1_t2."time", pg2dim_h1_t2.device
               Filter: ((avg(pg2dim_h1_t2.temp) * (custom_sum(pg2dim_h1_t2.device))::double precision) > '0.8'::double precision)
               ->  Foreign Scan on public.pg2dim_h1_t2
                     Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, pg2dim_h1_t2.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t2
         ->  HashAggregate
               Output: pg2dim_h2_t1."time", pg2dim_h2_t1.device, avg(pg2dim_h2_t1.temp), ((sum(pg2dim_h2_t1.temp) * random()) * (pg2dim_h2_t1.device)::double precision)
               Group Key: pg2dim_h2_t1."time", pg2dim_h2_t1.device
               Filter: ((avg(pg2dim_h2_t1.temp) * (custom_sum(pg2dim_h2_t1.device))::double precision) > '0.8'::double precision)
               ->  Foreign Scan on public.pg2dim_h2_t1
                     Output: pg2dim_h2_t1."time", pg2dim_h2_t1.device, pg2dim_h2_t1.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t1
         ->  HashAggregate
               Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, avg(pg2dim_h2_t2.temp), ((sum(pg2dim_h2_t2.temp) * random()) * (pg2dim_h2_t2.device)::double precision)
               Group Key: pg2dim_h2_t2."time", pg2dim_h2_t2.device
               Filter: ((avg(pg2dim_h2_t2.temp) * (custom_sum(pg2dim_h2_t2.device))::double precision) > '0.8'::double precision)
               ->  Foreign Scan on public.pg2dim_h2_t2
                     Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, pg2dim_h2_t2.temp
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t2
(31 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp), sum(temp) * random() * device as sum_temp
FROM hyper
GROUP BY 1, 2
HAVING avg(temp) * custom_sum(device) > 0.8
LIMIT 1;
                                                                                          QUERY PLAN                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: hyper."time", hyper.device, (avg(hyper.temp)), (((sum(hyper.temp) * random()) * (hyper.device)::double precision))
   ->  Append
         ->  GroupAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp), ((sum(hyper.temp) * random()) * (hyper.device)::double precision)
               Group Key: hyper."time", hyper.device
               Filter: ((avg(hyper.temp) * (custom_sum(hyper.device))::double precision) > '0.8'::double precision)
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Server: server_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY "time" ASC NULLS LAST, device ASC NULLS LAST
         ->  GroupAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp), ((sum(hyper.temp) * random()) * (hyper.device)::double precision)
               Group Key: hyper."time", hyper.device
               Filter: ((avg(hyper.temp) * (custom_sum(hyper.device))::double precision) > '0.8'::double precision)
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Server: server_2
                     Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY "time" ASC NULLS LAST, device ASC NULLS LAST
(21 rows)

-- not pushed down because of non-shippable expression on the
-- underlying rel
EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp)
FROM pg2dim
WHERE (pg2dim.temp * random() <= 20)
GROUP BY 1, 2
LIMIT 1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, (avg(pg2dim_h1_t1.temp))
   ->  Append
         ->  HashAggregate
               Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, avg(pg2dim_h1_t1.temp)
               Group Key: pg2dim_h1_t1."time", pg2dim_h1_t1.device
               ->  Foreign Scan on public.pg2dim_h1_t1
                     Output: pg2dim_h1_t1."time", pg2dim_h1_t1.device, pg2dim_h1_t1.temp
                     Filter: ((pg2dim_h1_t1.temp * random()) <= '20'::double precision)
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t1
         ->  HashAggregate
               Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, avg(pg2dim_h1_t2.temp)
               Group Key: pg2dim_h1_t2."time", pg2dim_h1_t2.device
               ->  Foreign Scan on public.pg2dim_h1_t2
                     Output: pg2dim_h1_t2."time", pg2dim_h1_t2.device, pg2dim_h1_t2.temp
                     Filter: ((pg2dim_h1_t2.temp * random()) <= '20'::double precision)
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h1_t2
         ->  HashAggregate
               Output: pg2dim_h2_t1."time", pg2dim_h2_t1.device, avg(pg2dim_h2_t1.temp)
               Group Key: pg2dim_h2_t1."time", pg2dim_h2_t1.device
               ->  Foreign Scan on public.pg2dim_h2_t1
                     Output: pg2dim_h2_t1."time", pg2dim_h2_t1.device, pg2dim_h2_t1.temp
                     Filter: ((pg2dim_h2_t1.temp * random()) <= '20'::double precision)
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t1
         ->  HashAggregate
               Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, avg(pg2dim_h2_t2.temp)
               Group Key: pg2dim_h2_t2."time", pg2dim_h2_t2.device
               ->  Foreign Scan on public.pg2dim_h2_t2
                     Output: pg2dim_h2_t2."time", pg2dim_h2_t2.device, pg2dim_h2_t2.temp
                     Filter: ((pg2dim_h2_t2.temp * random()) <= '20'::double precision)
                     Remote SQL: SELECT "time", device, temp FROM public.pg2dim_h2_t2
(31 rows)

EXPLAIN (VERBOSE, COSTS OFF)
SELECT time, device, avg(temp)
FROM hyper
WHERE (hyper.temp * random() <= 20)
GROUP BY 1, 2
LIMIT 1;
                                                                                          QUERY PLAN                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: hyper."time", hyper.device, (avg(hyper.temp))
   ->  Append
         ->  GroupAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp)
               Group Key: hyper."time", hyper.device
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Filter: ((hyper.temp * random()) <= '20'::double precision)
                     Server: server_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_3_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY "time" ASC NULLS LAST, device ASC NULLS LAST
         ->  GroupAggregate
               Output: hyper."time", hyper.device, avg(hyper.temp)
               Group Key: hyper."time", hyper.device
               ->  Foreign Scan
                     Output: hyper."time", hyper.device, hyper.temp
                     Filter: ((hyper.temp * random()) <= '20'::double precision)
                     Server: server_2
                     Chunks: _hyper_1_2_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT "time", device, temp FROM public.hyper WHERE _timescaledb_internal.chunks_in(hyper, ARRAY[1, 2]) ORDER BY "time" ASC NULLS LAST, device ASC NULLS LAST
(21 rows)

