-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Need to be super user to create extension and add servers
\c :TEST_DBNAME :ROLE_SUPERUSER;
-- Need explicit password for non-super users to connect
ALTER ROLE :ROLE_DEFAULT_CLUSTER_USER CREATEDB PASSWORD 'pass';
GRANT USAGE ON FOREIGN DATA WRAPPER timescaledb_fdw TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Cleanup from other potential tests that created these databases
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS server_1;
DROP DATABASE IF EXISTS server_2;
DROP DATABASE IF EXISTS server_3;
SET client_min_messages TO NOTICE;
CREATE DATABASE server_1;
CREATE DATABASE server_2;
CREATE DATABASE server_3;
\c server_1
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
\c server_2
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
\c server_3
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
\c :TEST_DBNAME :ROLE_SUPERUSER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Add servers using the TimescaleDB server management API
SELECT * FROM add_server('server_1', database => 'server_1', password => 'pass', if_not_exists => true);
NOTICE:  remote server database "server_1" already exists, skipping
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_1    | localhost | 15432 | server_1 | default_cluster_user | default_cluster_user | t
(1 row)

SELECT * FROM add_server('server_2', database => 'server_2', password => 'pass', if_not_exists => true);
NOTICE:  remote server database "server_2" already exists, skipping
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_2    | localhost | 15432 | server_2 | default_cluster_user | default_cluster_user | t
(1 row)

SELECT * FROM add_server('server_3', database => 'server_3', port => inet_server_port(), password => 'pass', if_not_exists => true);
NOTICE:  remote server database "server_3" already exists, skipping
 server_name |   host    | port  | database |       username       |   server_username    | created 
-------------+-----------+-------+----------+----------------------+----------------------+---------
 server_3    | localhost | 15432 | server_3 | default_cluster_user | default_cluster_user | t
(1 row)

-- Create distributed hypertables. Add a trigger and primary key
-- constraint to test how those work
CREATE TABLE disttable(time timestamptz PRIMARY KEY, device int CHECK (device > 0), color int, temp float);
SELECT * FROM create_hypertable('disttable', 'time', replication_factor => 1);
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             1 | public      | disttable  | t
(1 row)

-- An underreplicated table that will has a replication_factor > num_servers
CREATE TABLE underreplicated(time timestamptz, device int, temp float);
SELECT * FROM create_hypertable('underreplicated', 'time', replication_factor => 4);
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name |   table_name    | created 
---------------+-------------+-----------------+---------
             2 | public      | underreplicated | t
(1 row)

SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE OR REPLACE FUNCTION test_trigger()
    RETURNS TRIGGER LANGUAGE PLPGSQL AS
$BODY$
DECLARE
    cnt INTEGER;
BEGIN
    SELECT count(*) INTO cnt FROM hyper;
    RAISE WARNING 'FIRING trigger when: % level: % op: % cnt: % trigger_name %',
        tg_when, tg_level, tg_op, cnt, tg_name;

    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    END IF;
    RETURN NEW;
END
$BODY$;
CREATE TRIGGER _0_test_trigger_insert
    BEFORE INSERT ON disttable
    FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM _timescaledb_catalog.hypertable_server;
 hypertable_id | server_hypertable_id | server_name 
---------------+----------------------+-------------
             1 |                    1 | server_1
             1 |                    1 | server_2
             1 |                    1 | server_3
             2 |                    2 | server_1
             2 |                    2 | server_2
             2 |                    2 | server_3
(6 rows)

SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
(0 rows)

-- The constraints, indexes, and triggers on the hypertable
SELECT * FROM test.show_constraints('disttable');
       Constraint       | Type | Columns  |     Index      |     Expr     | Deferrable | Deferred | Validated 
------------------------+------+----------+----------------+--------------+------------+----------+-----------
 disttable_device_check | c    | {device} | -              | (device > 0) | f          | f        | t
 disttable_pkey         | p    | {time}   | disttable_pkey |              | f          | f        | t
(2 rows)

SELECT * FROM test.show_indexes('disttable');
     Index      | Columns | Expr | Unique | Primary | Exclusion | Tablespace 
----------------+---------+------+--------+---------+-----------+------------
 disttable_pkey | {time}  |      | t      | t       | f         | 
(1 row)

SELECT * FROM test.show_triggers('disttable');
        Trigger         | Type |               Function               
------------------------+------+--------------------------------------
 _0_test_trigger_insert |    7 | test_trigger
 ts_insert_blocker      |    7 | _timescaledb_internal.insert_blocker
(2 rows)

-- Drop a column. This will make the attribute numbers of the
-- hypertable's root relation differ from newly created chunks. It is
-- a way to test that we properly handle attributed conversion between
-- the root table and chunks
ALTER TABLE disttable DROP COLUMN color;
-- Currently no distributed DDL support, so need to manually drop
-- column on datanodes
\c server_1
ALTER TABLE disttable DROP COLUMN color;
\c server_2
ALTER TABLE disttable DROP COLUMN color;
\c server_3
ALTER TABLE disttable DROP COLUMN color;
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- EXPLAIN some inserts to see what plans and explain output for
-- remote inserts look like
EXPLAIN (COSTS FALSE)
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1);
                  QUERY PLAN                   
-----------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable disttable
   ->  Insert on disttable
         ->  Custom Scan (ServerDispatch)
               Batch size: 1000
               ->  Custom Scan (ChunkDispatch)
                     ->  Result
(7 rows)

EXPLAIN (VERBOSE, COSTS FALSE)
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1);
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable public.disttable
   Servers: server_1, server_2, server_3
   ->  Insert on public.disttable
         ->  Custom Scan (ServerDispatch)
               Output: 'Sun Jan 01 06:01:00 2017 PST'::timestamp with time zone, 1, NULL::integer, '1.1'::double precision
               Batch size: 1000
               Remote SQL: INSERT INTO public.disttable("time", device, temp) VALUES ($1, $2, $3), ..., ($2998, $2999, $3000)
               ->  Custom Scan (ChunkDispatch)
                     Output: 'Sun Jan 01 06:01:00 2017 PST'::timestamp with time zone, 1, NULL::integer, '1.1'::double precision
                     ->  Result
                           Output: 'Sun Jan 01 06:01:00 2017 PST'::timestamp with time zone, 1, NULL::integer, '1.1'::double precision
(12 rows)

-- Create some chunks through insertion
INSERT INTO disttable VALUES
       ('2017-01-01 06:01', 1, 1.1),
       ('2017-01-01 08:01', 1, 1.2),
       ('2018-01-02 08:01', 2, 1.3),
       ('2019-01-01 09:11', 3, 2.1);
-- Test prepared statement
PREPARE dist_insert (timestamptz, int, float) AS
INSERT INTO disttable VALUES ($1, $2, $3);
EXECUTE dist_insert ('2017-01-01 06:05', 1, 1.4);
-- Show chunks created
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_1_dist_chunk | f       | {"time": [1482969600000000, 1483574400000000]}
        2 |             1 | _timescaledb_internal | _hyper_1_2_dist_chunk | f       | {"time": [1514419200000000, 1515024000000000]}
        3 |             1 | _timescaledb_internal | _hyper_1_3_dist_chunk | f       | {"time": [1545868800000000, 1546473600000000]}
(3 rows)

-- Show that there are assigned server_chunk_id:s in chunk server mappings
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
(3 rows)

-- Show that chunks are created on remote servers
\c server_1
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_1_dist_chunk | r       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4
(3 rows)

\c server_2
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_2_dist_chunk | r       | {"time": [1514419200000000, 1515024000000000]}
(1 row)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3
(1 row)

\c server_3
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('disttable');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_3_dist_chunk | r       | {"time": [1545868800000000, 1546473600000000]}
(1 row)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Show what some queries would look like on the frontend
EXPLAIN (VERBOSE, COSTS FALSE)
SELECT * FROM disttable;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Append
   ->  Foreign Scan
         Output: "time", device, temp
         Server: server_1
         Chunks: _hyper_1_1_dist_chunk
         Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1])
   ->  Foreign Scan
         Output: "time", device, temp
         Server: server_2
         Chunks: _hyper_1_2_dist_chunk
         Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1])
   ->  Foreign Scan
         Output: "time", device, temp
         Server: server_3
         Chunks: _hyper_1_3_dist_chunk
         Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1])
(16 rows)

SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1
(5 rows)

EXPLAIN (VERBOSE, COSTS FALSE)
SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable GROUP BY 1, 2
ORDER BY 1;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (time_bucket('@ 3 hours'::interval, "time")), device, (avg(temp))
   Sort Key: (time_bucket('@ 3 hours'::interval, disttable."time"))
   ->  HashAggregate
         Output: (time_bucket('@ 3 hours'::interval, "time")), device, avg(temp)
         Group Key: time_bucket('@ 3 hours'::interval, disttable."time"), disttable.device
         ->  Result
               Output: time_bucket('@ 3 hours'::interval, "time"), device, temp
               ->  Append
                     ->  Foreign Scan
                           Output: "time", device, temp
                           Server: server_1
                           Chunks: _hyper_1_1_dist_chunk
                           Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1])
                     ->  Foreign Scan
                           Output: "time", device, temp
                           Server: server_2
                           Chunks: _hyper_1_2_dist_chunk
                           Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1])
                     ->  Foreign Scan
                           Output: "time", device, temp
                           Server: server_3
                           Chunks: _hyper_1_3_dist_chunk
                           Remote SQL: SELECT "time", device, temp FROM public.disttable WHERE _timescaledb_internal.chunks_in(disttable, ARRAY[1])
(24 rows)

-- Execute some queries on the frontend and return the results
SELECT * FROM disttable;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1
(5 rows)

SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable
GROUP BY 1, 2
ORDER BY 1;
             time             | device | avg_temp 
------------------------------+--------+----------
 Sun Jan 01 04:00:00 2017 PST |      1 |     1.25
 Sun Jan 01 07:00:00 2017 PST |      1 |      1.2
 Tue Jan 02 07:00:00 2018 PST |      2 |      1.3
 Tue Jan 01 07:00:00 2019 PST |      3 |      2.1
(4 rows)

SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable GROUP BY 1, 2
HAVING avg(temp) > 1.2
ORDER BY 1;
             time             | device | avg_temp 
------------------------------+--------+----------
 Sun Jan 01 04:00:00 2017 PST |      1 |     1.25
 Tue Jan 02 07:00:00 2018 PST |      2 |      1.3
 Tue Jan 01 07:00:00 2019 PST |      3 |      2.1
(3 rows)

SELECT time_bucket('3 hours', time) AS time, device, avg(temp) AS avg_temp
FROM disttable
WHERE temp > 2
GROUP BY 1, 2
HAVING avg(temp) > 1.2
ORDER BY 1;
             time             | device | avg_temp 
------------------------------+--------+----------
 Tue Jan 01 07:00:00 2019 PST |      3 |      2.1
(1 row)

-- The constraints, indexes, and triggers on foreign chunks. Only
-- check constraints should recurse to foreign chunks (although they
-- aren't enforced on a foreign table)
SELECT st."Child" as chunk_relid, test.show_constraints((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |                                                                                   show_constraints                                                                                   
---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (constraint_2,c,{time},-,"((""time"" >= 'Wed Dec 27 16:00:00 2017 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 03 16:00:00 2018 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (constraint_3,c,{time},-,"((""time"" >= 'Wed Dec 26 16:00:00 2018 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 02 16:00:00 2019 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
(6 rows)

SELECT st."Child" as chunk_relid, test.show_indexes((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_indexes 
-------------+--------------
(0 rows)

SELECT st."Child" as chunk_relid, test.show_triggers((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_triggers 
-------------+---------------
(0 rows)

-- Check that the chunks are assigned servers
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
(3 rows)

-- Adding a new trigger should not recurse to foreign chunks
CREATE TRIGGER _1_test_trigger_insert
    AFTER INSERT ON disttable
    FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT st."Child" as chunk_relid, test.show_triggers((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_triggers 
-------------+---------------
(0 rows)

-- Check that we can create indexes on distributed hypertables and
-- that they don't recurse to foreign chunks
CREATE INDEX ON disttable (time, device);
SELECT * FROM test.show_indexes('disttable');
           Index           |    Columns    | Expr | Unique | Primary | Exclusion | Tablespace 
---------------------------+---------------+------+--------+---------+-----------+------------
 disttable_pkey            | {time}        |      | t      | t       | f         | 
 disttable_time_device_idx | {time,device} |      | f      | f       | f         | 
(2 rows)

SELECT st."Child" as chunk_relid, test.show_indexes((st)."Child")
FROM test.show_subtables('disttable') st;
 chunk_relid | show_indexes 
-------------+--------------
(0 rows)

-- No index mappings should exist either
SELECT * FROM _timescaledb_catalog.chunk_index;
 chunk_id | index_name | hypertable_id | hypertable_index_name 
----------+------------+---------------+-----------------------
(0 rows)

-- Check that creating columns work
ALTER TABLE disttable ADD COLUMN "Color" int;
-- Currently no distributed DDL support, so need to manually add
-- column on datanodes
\c server_1
ALTER TABLE disttable ADD COLUMN "Color" int;
\c server_2
ALTER TABLE disttable ADD COLUMN "Color" int;
\c server_3
ALTER TABLE disttable ADD COLUMN "Color" int;
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
SELECT * FROM test.show_columns('disttable');
 Column |           Type           | NotNull 
--------+--------------------------+---------
 time   | timestamp with time zone | t
 device | integer                  | f
 temp   | double precision         | f
 Color  | integer                  | f
(4 rows)

SELECT st."Child" as chunk_relid, test.show_columns((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |            show_columns             
---------------------------------------------+-------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (device,integer,f)
 _timescaledb_internal._hyper_1_1_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_1_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (device,integer,f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_2_dist_chunk | (Color,integer,f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (time,"timestamp with time zone",t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (device,integer,f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (temp,"double precision",f)
 _timescaledb_internal._hyper_1_3_dist_chunk | (Color,integer,f)
(12 rows)

-- Adding a new unique constraint should not recurse to foreign
-- chunks, but a check constraint should
ALTER TABLE disttable ADD CONSTRAINT disttable_color_unique UNIQUE (time, "Color");
ALTER TABLE disttable ADD CONSTRAINT disttable_temp_non_negative CHECK (temp > 0.0);
SELECT st."Child" as chunk_relid, test.show_constraints((st)."Child")
FROM test.show_subtables('disttable') st;
                 chunk_relid                 |                                                                                   show_constraints                                                                                   
---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 _timescaledb_internal._hyper_1_1_dist_chunk | (constraint_1,c,{time},-,"((""time"" >= 'Wed Dec 28 16:00:00 2016 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 04 16:00:00 2017 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_1_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (constraint_2,c,{time},-,"((""time"" >= 'Wed Dec 27 16:00:00 2017 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 03 16:00:00 2018 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_2_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (constraint_3,c,{time},-,"((""time"" >= 'Wed Dec 26 16:00:00 2018 PST'::timestamp with time zone) AND (""time"" < 'Wed Jan 02 16:00:00 2019 PST'::timestamp with time zone))",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_device_check,c,{device},-,"(device > 0)",f,f,t)
 _timescaledb_internal._hyper_1_3_dist_chunk | (disttable_temp_non_negative,c,{temp},-,"(temp > (0.0)::double precision)",f,f,t)
(9 rows)

SELECT cc.*
FROM (SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
      FROM show_chunks('disttable')) c,
      _timescaledb_catalog.chunk_constraint cc
WHERE c.chunk_id = cc.chunk_id;
 chunk_id | dimension_slice_id | constraint_name | hypertable_constraint_name 
----------+--------------------+-----------------+----------------------------
        1 |                  1 | constraint_1    | 
        2 |                  2 | constraint_2    | 
        3 |                  3 | constraint_3    | 
(3 rows)

-- Show contents after re-adding column
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4 |      
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |      
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1 |      
(5 rows)

-- Test INSERTS with RETURNING. Since we previously dropped a column
-- on the hypertable, this also tests that we handle conversion of the
-- attribute numbers in the RETURNING clause, since they now differ
-- between the hypertable root relation and the chunk currently
-- RETURNING from.
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-02 06:09', 4, 1, 9.8)
RETURNING time, "Color", temp;
             time             | Color | temp 
------------------------------+-------+------
 Sat Sep 02 06:09:00 2017 PDT |     1 |  9.8
(1 row)

INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-03 06:18', 9, 3, 8.7)
RETURNING 1;
 ?column? 
----------
        1
(1 row)

-- On conflict
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-02 06:09', 6, 2, 10.5)
ON CONFLICT DO NOTHING;
-- Show new row and that conflicting row is not inserted
\c server_1
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4 |      
(3 rows)

\c server_2
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |      
 Sat Sep 02 06:09:00 2017 PDT |      4 |  9.8 |     1
 Sun Sep 03 06:18:00 2017 PDT |      9 |  8.7 |     3
(3 rows)

\c server_3
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1 |      
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\set ON_ERROR_STOP 0
-- ON CONFLICT only works with DO NOTHING
INSERT INTO disttable (time, device, "Color", temp)
VALUES ('2017-09-09 08:13', 7, 3, 27.5)
ON CONFLICT (time) DO UPDATE SET temp = 3.2;
ERROR:  unexpected ON CONFLICT specification: 2
\set ON_ERROR_STOP 1
-- Test updates
UPDATE disttable SET device = 4 WHERE device = 3;
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      1 |  1.4 |      
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |      
 Sat Sep 02 06:09:00 2017 PDT |      4 |  9.8 |     1
 Sun Sep 03 06:18:00 2017 PDT |      9 |  8.7 |     3
 Tue Jan 01 09:11:00 2019 PST |      4 |  2.1 |      
(7 rows)

WITH devices AS (
     SELECT DISTINCT device FROM disttable ORDER BY device
)
UPDATE disttable SET device = 2 WHERE device = (SELECT device FROM devices LIMIT 1);
\set ON_ERROR_STOP 0
-- Updates referencing non-existing column
UPDATE disttable SET device = 4 WHERE no_such_column = 2;
ERROR:  column "no_such_column" does not exist at character 39
UPDATE disttable SET no_such_column = 4 WHERE device = 2;
ERROR:  column "no_such_column" of relation "disttable" does not exist at character 22
-- Update to system column
UPDATE disttable SET tableoid = 4 WHERE device = 2;
ERROR:  cannot assign to system column "tableoid" at character 22
\set ON_ERROR_STOP 1
-- Test deletes (no rows deleted)
DELETE FROM disttable WHERE device = 3
RETURNING *;
 time | device | temp | Color 
------+--------+------+-------
(0 rows)

-- Test deletes (rows deleted)
DELETE FROM disttable WHERE device = 4
RETURNING *;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Tue Jan 01 09:11:00 2019 PST |      4 |  2.1 |      
 Sat Sep 02 06:09:00 2017 PDT |      4 |  9.8 |     1
(2 rows)

-- Query to show that rows are deleted
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      2 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      2 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      2 |  1.4 |      
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |      
 Sun Sep 03 06:18:00 2017 PDT |      9 |  8.7 |     3
(5 rows)

-- Ensure rows are deleted on the servers
\c server_1
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      2 |  1.1 |      
 Sun Jan 01 08:01:00 2017 PST |      2 |  1.2 |      
 Sun Jan 01 06:05:00 2017 PST |      2 |  1.4 |      
(3 rows)

\c server_2
SELECT * FROM disttable;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |      
 Sun Sep 03 06:18:00 2017 PDT |      9 |  8.7 |     3
(2 rows)

\c server_3
SELECT * FROM disttable;
 time | device | temp | Color 
------+--------+------+-------
(0 rows)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Test underreplicated chunk warning
INSERT INTO underreplicated VALUES ('2017-01-01 06:01', 1, 1.1),
                                   ('2017-01-02 07:01', 2, 3.5);
WARNING:  under-replicated chunk 5, lacks 1 server(s)
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
        4 |               2 | server_2
        5 |               2 | server_1
        5 |               3 | server_2
        5 |               2 | server_3
(7 rows)

SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        5 |             2 | _timescaledb_internal | _hyper_2_5_dist_chunk | f       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

-- Show chunk server mappings
SELECT * FROM _timescaledb_catalog.chunk_server;
 chunk_id | server_chunk_id | server_name 
----------+-----------------+-------------
        1 |               1 | server_1
        2 |               1 | server_2
        3 |               1 | server_3
        4 |               2 | server_2
        5 |               2 | server_1
        5 |               3 | server_2
        5 |               2 | server_3
(7 rows)

-- Show that chunks are created on remote servers and that all
-- servers/chunks have the same data due to replication
\c server_1
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        2 |             2 | _timescaledb_internal | _hyper_2_5_dist_chunk | r       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |  3.5
(2 rows)

\c server_2
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        3 |             2 | _timescaledb_internal | _hyper_2_5_dist_chunk | r       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |  3.5
(2 rows)

\c server_3
SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('underreplicated');
 chunk_id | hypertable_id |      schema_name      |      table_name       | relkind |                     slices                     
----------+---------------+-----------------------+-----------------------+---------+------------------------------------------------
        2 |             2 | _timescaledb_internal | _hyper_2_5_dist_chunk | r       | {"time": [1482969600000000, 1483574400000000]}
(1 row)

SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |  3.5
(2 rows)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
UPDATE underreplicated SET temp = 2.0 WHERE device = 2
RETURNING time, temp, device;
             time             | temp | device 
------------------------------+------+--------
 Mon Jan 02 07:01:00 2017 PST |    2 |      2
(1 row)

SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(2 rows)

-- Show that all replica chunks are updated
\c server_1
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(2 rows)

\c server_2
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(2 rows)

\c server_3
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(2 rows)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
DELETE FROM underreplicated WHERE device = 2
RETURNING *;
             time             | device | temp 
------------------------------+--------+------
 Mon Jan 02 07:01:00 2017 PST |      2 |    2
(1 row)

-- Ensure deletes across all servers
\c server_1
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
(1 row)

\c server_2
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
(1 row)

\c server_3
SELECT * FROM underreplicated;
             time             | device | temp 
------------------------------+--------+------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Test hypertable creation fails on distributed error
\c server_3
CREATE TABLE remotetable(time timestamptz PRIMARY KEY, id int, cost float);
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\set ON_ERROR_STOP 0
CREATE TABLE remotetable(time timestamptz PRIMARY KEY, device int CHECK (device > 0), color int, temp float);
SELECT * FROM create_hypertable('remotetable', 'time', replication_factor => 1);
ERROR:  remote connection error: relation "remotetable" already exists
\set ON_ERROR_STOP 1
SELECT * FROM timescaledb_information.hypertable
ORDER BY table_schema, table_name;
 table_schema |   table_name    |     table_owner      | num_dimensions | num_chunks | table_size | index_size | toast_size | total_size 
--------------+-----------------+----------------------+----------------+------------+------------+------------+------------+------------
 public       | disttable       | default_cluster_user |              1 |          4 | 0 bytes    | 0 bytes    |            | 0 bytes
 public       | underreplicated | default_cluster_user |              1 |          1 | 0 bytes    | 0 bytes    |            | 0 bytes
(2 rows)

-- Test distributed hypertable creation with many parameters
\c server_1
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
\c server_2
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
\c server_3
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\c :TEST_DBNAME :ROLE_SUPERUSER
CREATE SCHEMA "T3sTSch";
CREATE SCHEMA "Table\\Schema";
GRANT ALL ON SCHEMA "T3sTSch" TO :ROLE_DEFAULT_CLUSTER_USER;
GRANT ALL ON SCHEMA "Table\\Schema" TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE TABLE "Table\\Schema"."Param_Table"("time Col %#^#@$#" timestamptz, __region text, reading float);
SELECT * FROM create_hypertable('"Table\\Schema"."Param_Table"', 'time Col %#^#@$#', partitioning_column => '__region', number_partitions  => 4,
associated_schema_name => 'T3sTSch', associated_table_prefix => 'test*pre_', chunk_time_interval => interval '1 week',
create_default_indexes => FALSE, if_not_exists => TRUE, migrate_data => TRUE, replication_factor => 2,
servers => '{ "server_2", "server_3" }');
NOTICE:  adding not-null constraint to column "time Col %#^#@$#"
 hypertable_id |  schema_name  | table_name  | created 
---------------+---------------+-------------+---------
             4 | Table\\Schema | Param_Table | t
(1 row)

-- Test attach_server
SELECT * FROM _timescaledb_catalog.hypertable_server;
 hypertable_id | server_hypertable_id | server_name 
---------------+----------------------+-------------
             1 |                    1 | server_1
             1 |                    1 | server_2
             1 |                    1 | server_3
             2 |                    2 | server_1
             2 |                    2 | server_2
             2 |                    2 | server_3
             4 |                    3 | server_2
             4 |                    3 | server_3
(8 rows)

SELECT * FROM attach_server('"Table\\Schema"."Param_Table"', 'server_1');
 hypertable_id | server_hypertable_id | server_name 
---------------+----------------------+-------------
             4 |                    3 | server_1
(1 row)

SELECT * FROM _timescaledb_catalog.hypertable_server;
 hypertable_id | server_hypertable_id | server_name 
---------------+----------------------+-------------
             1 |                    1 | server_1
             1 |                    1 | server_2
             1 |                    1 | server_3
             2 |                    2 | server_1
             2 |                    2 | server_2
             2 |                    2 | server_3
             4 |                    3 | server_2
             4 |                    3 | server_3
             4 |                    3 | server_1
(9 rows)

-- Verify hypertables on all servers
SELECT * FROM _timescaledb_catalog.hypertable;
 id |  schema_name  |   table_name    | associated_schema_name | associated_table_prefix | num_dimensions | chunk_sizing_func_schema |  chunk_sizing_func_name  | chunk_target_size | compressed | compressed_hypertable_id | replication_factor 
----+---------------+-----------------+------------------------+-------------------------+----------------+--------------------------+--------------------------+-------------------+------------+--------------------------+--------------------
  1 | public        | disttable       | _timescaledb_internal  | _hyper_1                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                  1
  2 | public        | underreplicated | _timescaledb_internal  | _hyper_2                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                  4
  4 | Table\\Schema | Param_Table     | T3sTSch                | test*pre_               |              2 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                  2
(3 rows)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  4 |             4 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  5 |             4 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(4 rows)

SELECT * FROM test.show_triggers('"Table\\Schema"."Param_Table"');
      Trigger      | Type |               Function               
-------------------+------+--------------------------------------
 ts_insert_blocker |    7 | _timescaledb_internal.insert_blocker
(1 row)

\c server_1
SELECT * FROM _timescaledb_catalog.hypertable;
 id |  schema_name  |   table_name    | associated_schema_name | associated_table_prefix | num_dimensions | chunk_sizing_func_schema |  chunk_sizing_func_name  | chunk_target_size | compressed | compressed_hypertable_id | replication_factor 
----+---------------+-----------------+------------------------+-------------------------+----------------+--------------------------+--------------------------+-------------------+------------+--------------------------+--------------------
  1 | public        | disttable       | _timescaledb_internal  | _hyper_1                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  2 | public        | underreplicated | _timescaledb_internal  | _hyper_2                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  3 | Table\\Schema | Param_Table     | T3sTSch                | test*pre_               |              2 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
(3 rows)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  3 |             3 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  4 |             3 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(4 rows)

SELECT t.tgname, t.tgtype, t.tgfoid::regproc
FROM pg_trigger t, pg_class c WHERE c.relname = 'Param_Table' AND t.tgrelid = c.oid;
      tgname       | tgtype |                tgfoid                
-------------------+--------+--------------------------------------
 ts_insert_blocker |      7 | _timescaledb_internal.insert_blocker
(1 row)

\c server_2
SELECT * FROM _timescaledb_catalog.hypertable;
 id |  schema_name  |   table_name    | associated_schema_name | associated_table_prefix | num_dimensions | chunk_sizing_func_schema |  chunk_sizing_func_name  | chunk_target_size | compressed | compressed_hypertable_id | replication_factor 
----+---------------+-----------------+------------------------+-------------------------+----------------+--------------------------+--------------------------+-------------------+------------+--------------------------+--------------------
  1 | public        | disttable       | _timescaledb_internal  | _hyper_1                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  2 | public        | underreplicated | _timescaledb_internal  | _hyper_2                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  3 | Table\\Schema | Param_Table     | T3sTSch                | test*pre_               |              2 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
(3 rows)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  3 |             3 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  4 |             3 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(4 rows)

SELECT t.tgname, t.tgtype, t.tgfoid::regproc
FROM pg_trigger t, pg_class c WHERE c.relname = 'Param_Table' AND t.tgrelid = c.oid;
      tgname       | tgtype |                tgfoid                
-------------------+--------+--------------------------------------
 ts_insert_blocker |      7 | _timescaledb_internal.insert_blocker
(1 row)

\c server_3
SELECT * FROM _timescaledb_catalog.hypertable;
 id |  schema_name  |   table_name    | associated_schema_name | associated_table_prefix | num_dimensions | chunk_sizing_func_schema |  chunk_sizing_func_name  | chunk_target_size | compressed | compressed_hypertable_id | replication_factor 
----+---------------+-----------------+------------------------+-------------------------+----------------+--------------------------+--------------------------+-------------------+------------+--------------------------+--------------------
  1 | public        | disttable       | _timescaledb_internal  | _hyper_1                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  2 | public        | underreplicated | _timescaledb_internal  | _hyper_2                |              1 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
  3 | Table\\Schema | Param_Table     | T3sTSch                | test*pre_               |              2 | _timescaledb_internal    | calculate_chunk_interval |                 0 | f          |                          |                   
(3 rows)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  3 |             3 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  4 |             3 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(4 rows)

SELECT t.tgname, t.tgtype, t.tgfoid::regproc
FROM pg_trigger t, pg_class c WHERE c.relname = 'Param_Table' AND t.tgrelid = c.oid;
      tgname       | tgtype |                tgfoid                
-------------------+--------+--------------------------------------
 ts_insert_blocker |      7 | _timescaledb_internal.insert_blocker
(1 row)

\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Test multi-dimensional hypertable (note that add_dimension is not currently propagated to backends)
CREATE TABLE dimented_table (time timestamptz, column1 int, column2 timestamptz, column3 int);
SELECT * FROM create_hypertable('dimented_table', 'time', partitioning_column => 'column1', number_partitions  => 4, replication_factor => 1, servers => '{ "server_1" }');
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name |   table_name   | created 
---------------+-------------+----------------+---------
             5 | public      | dimented_table | t
(1 row)

SELECT * FROM add_dimension('dimented_table', 'column2', chunk_time_interval => interval '1 week');
NOTICE:  adding not-null constraint to column "column2"
 dimension_id | schema_name |   table_name   | column_name | created 
--------------+-------------+----------------+-------------+---------
            8 | public      | dimented_table | column2     | t
(1 row)

SELECT * FROM add_dimension('dimented_table', 'column3', 4, partitioning_func => '_timescaledb_internal.get_partition_for_key');
 dimension_id | schema_name |   table_name   | column_name | created 
--------------+-------------+----------------+-------------+---------
            9 | public      | dimented_table | column3     | t
(1 row)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema |   partitioning_func   | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+-----------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  4 |             4 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  5 |             4 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  6 |             5 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  7 |             5 | column1          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  8 |             5 | column2          | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  9 |             5 | column3          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_for_key |                 |                         | 
(8 rows)

SELECT * FROM attach_server('dimented_table', 'server_2');
 hypertable_id | server_hypertable_id | server_name 
---------------+----------------------+-------------
             5 |                    4 | server_2
(1 row)

SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema |   partitioning_func   | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+-----------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  4 |             4 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  5 |             4 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  6 |             5 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  7 |             5 | column1          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  8 |             5 | column2          | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  9 |             5 | column3          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_for_key |                 |                         | 
(8 rows)

\c server_1
-- Note that this didn't get the add_dimension
SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema | partitioning_func  | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+--------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  3 |             3 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  4 |             3 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
  5 |             4 | time             | timestamp with time zone | t       |            |                          |                    |    604800000000 |                         | 
  6 |             4 | column1          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_hash |                 |                         | 
(6 rows)

\c server_2
SELECT * FROM _timescaledb_catalog.dimension;
 id | hypertable_id |   column_name    |       column_type        | aligned | num_slices | partitioning_func_schema |   partitioning_func   | interval_length | integer_now_func_schema | integer_now_func 
----+---------------+------------------+--------------------------+---------+------------+--------------------------+-----------------------+-----------------+-------------------------+------------------
  1 |             1 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  2 |             2 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  3 |             3 | time Col %#^#@$# | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  4 |             3 | __region         | text                     | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  5 |             4 | time             | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  6 |             4 | column1          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_hash    |                 |                         | 
  7 |             4 | column2          | timestamp with time zone | t       |            |                          |                       |    604800000000 |                         | 
  8 |             4 | column3          | integer                  | f       |          4 | _timescaledb_internal    | get_partition_for_key |                 |                         | 
(8 rows)

--test per-server queries
\c :TEST_DBNAME :ROLE_SUPERUSER
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Create some chunks through insertion
CREATE TABLE disttable_replicated(time timestamptz PRIMARY KEY, device int CHECK (device > 0), temp float, "Color" int);
SELECT * FROM create_hypertable('disttable_replicated', 'time', replication_factor => 2);
 hypertable_id | schema_name |      table_name      | created 
---------------+-------------+----------------------+---------
             6 | public      | disttable_replicated | t
(1 row)

INSERT INTO disttable_replicated VALUES
       ('2017-01-01 06:01', 1, 1.1, 1),
       ('2017-01-01 08:01', 1, 1.2, 2),
       ('2018-01-02 08:01', 2, 1.3, 3),
       ('2019-01-01 09:11', 3, 2.1, 4),
       ('2020-01-01 06:01', 5, 1.1, 10),
       ('2020-01-01 08:01', 6, 1.2, 11),
       ('2021-01-02 08:01', 7, 1.3, 12),
       ('2022-01-01 09:11', 8, 2.1, 13);
SELECT * FROM disttable_replicated;
             time             | device | temp | Color 
------------------------------+--------+------+-------
 Sun Jan 01 06:01:00 2017 PST |      1 |  1.1 |     1
 Sun Jan 01 08:01:00 2017 PST |      1 |  1.2 |     2
 Wed Jan 01 06:01:00 2020 PST |      5 |  1.1 |    10
 Wed Jan 01 08:01:00 2020 PST |      6 |  1.2 |    11
 Tue Jan 02 08:01:00 2018 PST |      2 |  1.3 |     3
 Sat Jan 02 08:01:00 2021 PST |      7 |  1.3 |    12
 Tue Jan 01 09:11:00 2019 PST |      3 |  2.1 |     4
 Sat Jan 01 09:11:00 2022 PST |      8 |  2.1 |    13
(8 rows)

EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE, TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated;
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=8 loops=1)
   ->  Foreign Scan (actual rows=4 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_1
         Chunks: _hyper_6_6_dist_chunk, _hyper_6_9_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[3, 5])
   ->  Foreign Scan (actual rows=2 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_2
         Chunks: _hyper_6_7_dist_chunk, _hyper_6_10_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[5, 7])
   ->  Foreign Scan (actual rows=2 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_3
         Chunks: _hyper_6_8_dist_chunk, _hyper_6_11_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[4, 6])
(16 rows)

--guc disables the optimization
SET timescaledb.enable_per_server_queries = FALSE;
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE, TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=8 loops=1)
   ->  Foreign Scan on _timescaledb_internal._hyper_6_6_dist_chunk (actual rows=2 loops=1)
         Output: _hyper_6_6_dist_chunk."time", _hyper_6_6_dist_chunk.device, _hyper_6_6_dist_chunk.temp, _hyper_6_6_dist_chunk."Color"
         Server: server_1
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_6_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_6_7_dist_chunk (actual rows=1 loops=1)
         Output: _hyper_6_7_dist_chunk."time", _hyper_6_7_dist_chunk.device, _hyper_6_7_dist_chunk.temp, _hyper_6_7_dist_chunk."Color"
         Server: server_2
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_7_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_6_8_dist_chunk (actual rows=1 loops=1)
         Output: _hyper_6_8_dist_chunk."time", _hyper_6_8_dist_chunk.device, _hyper_6_8_dist_chunk.temp, _hyper_6_8_dist_chunk."Color"
         Server: server_3
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_8_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_6_9_dist_chunk (actual rows=2 loops=1)
         Output: _hyper_6_9_dist_chunk."time", _hyper_6_9_dist_chunk.device, _hyper_6_9_dist_chunk.temp, _hyper_6_9_dist_chunk."Color"
         Server: server_1
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_9_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_6_10_dist_chunk (actual rows=1 loops=1)
         Output: _hyper_6_10_dist_chunk."time", _hyper_6_10_dist_chunk.device, _hyper_6_10_dist_chunk.temp, _hyper_6_10_dist_chunk."Color"
         Server: server_2
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_10_dist_chunk
   ->  Foreign Scan on _timescaledb_internal._hyper_6_11_dist_chunk (actual rows=1 loops=1)
         Output: _hyper_6_11_dist_chunk."time", _hyper_6_11_dist_chunk.device, _hyper_6_11_dist_chunk.temp, _hyper_6_11_dist_chunk."Color"
         Server: server_3
         Remote SQL: SELECT "time", device, temp, "Color" FROM _timescaledb_internal._hyper_6_11_dist_chunk
(25 rows)

SET timescaledb.enable_per_server_queries = TRUE;
--test WHERE clause
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE, TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated WHERE temp > 2.0;
                                                                                              QUERY PLAN                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=2 loops=1)
   ->  Foreign Scan (actual rows=0 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_1
         Chunks: _hyper_6_6_dist_chunk, _hyper_6_9_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[3, 5]) AND ((temp > 2::double precision))
   ->  Foreign Scan (actual rows=0 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_2
         Chunks: _hyper_6_7_dist_chunk, _hyper_6_10_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[5, 7]) AND ((temp > 2::double precision))
   ->  Foreign Scan (actual rows=2 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_3
         Chunks: _hyper_6_8_dist_chunk, _hyper_6_11_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[4, 6]) AND ((temp > 2::double precision))
(16 rows)

--test OR
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE, TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated WHERE temp > 2.0 or "Color" = 11;
                                                                                                        QUERY PLAN                                                                                                         
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=3 loops=1)
   ->  Foreign Scan (actual rows=1 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_1
         Chunks: _hyper_6_6_dist_chunk, _hyper_6_9_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[3, 5]) AND (((temp > 2::double precision) OR ("Color" = 11)))
   ->  Foreign Scan (actual rows=0 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_2
         Chunks: _hyper_6_7_dist_chunk, _hyper_6_10_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[5, 7]) AND (((temp > 2::double precision) OR ("Color" = 11)))
   ->  Foreign Scan (actual rows=2 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_3
         Chunks: _hyper_6_8_dist_chunk, _hyper_6_11_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[4, 6]) AND (((temp > 2::double precision) OR ("Color" = 11)))
(16 rows)

--test some chunks excluded
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE,  TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated WHERE time < '2018-01-01 09:11';
                                                                                                             QUERY PLAN                                                                                                              
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=2 loops=1)
   ->  Foreign Scan (actual rows=2 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_1
         Chunks: _hyper_6_6_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[3]) AND (("time" < '2018-01-01 09:11:00-08'::timestamp with time zone))
   ->  Foreign Scan (actual rows=0 loops=1)
         Output: "time", device, temp, "Color"
         Server: server_2
         Chunks: _hyper_6_7_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[5]) AND (("time" < '2018-01-01 09:11:00-08'::timestamp with time zone))
(11 rows)

--test all chunks excluded
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE,  TIMING FALSE, SUMMARY FALSE)
SELECT * FROM disttable_replicated WHERE time < '2002-01-01 09:11';
               QUERY PLAN                
-----------------------------------------
 Result (actual rows=0 loops=1)
   Output: "time", device, temp, "Color"
   One-Time Filter: false
(3 rows)

--test cte
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE,  TIMING FALSE, SUMMARY FALSE)
WITH cte AS (
    SELECT * FROM disttable_replicated
)
SELECT * FROM cte;
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Append (actual rows=8 loops=1)
   ->  Foreign Scan (actual rows=4 loops=1)
         Output: disttable_replicated."time", disttable_replicated.device, disttable_replicated.temp, disttable_replicated."Color"
         Server: server_1
         Chunks: _hyper_6_6_dist_chunk, _hyper_6_9_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[3, 5])
   ->  Foreign Scan (actual rows=2 loops=1)
         Output: disttable_replicated."time", disttable_replicated.device, disttable_replicated.temp, disttable_replicated."Color"
         Server: server_2
         Chunks: _hyper_6_7_dist_chunk, _hyper_6_10_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[5, 7])
   ->  Foreign Scan (actual rows=2 loops=1)
         Output: disttable_replicated."time", disttable_replicated.device, disttable_replicated.temp, disttable_replicated."Color"
         Server: server_3
         Chunks: _hyper_6_8_dist_chunk, _hyper_6_11_dist_chunk
         Remote SQL: SELECT "time", device, temp, "Color" FROM public.disttable_replicated WHERE _timescaledb_internal.chunks_in(disttable_replicated, ARRAY[4, 6])
(16 rows)

--queries that involve updates/inserts are not optimized
EXPLAIN (VERBOSE, ANALYZE, COSTS FALSE,  TIMING FALSE, SUMMARY FALSE)
WITH devices AS (
     SELECT DISTINCT device FROM disttable_replicated ORDER BY device
)
UPDATE disttable_replicated SET device = 2 WHERE device = (SELECT device FROM devices LIMIT 1);
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Update on public.disttable_replicated (actual rows=0 loops=1)
   Update on public.disttable_replicated
   Foreign Update on _timescaledb_internal._hyper_6_6_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_6_dist_chunk SET device = $2 WHERE ctid = $1
   Foreign Update on _timescaledb_internal._hyper_6_7_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_7_dist_chunk SET device = $2 WHERE ctid = $1
   Foreign Update on _timescaledb_internal._hyper_6_8_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_8_dist_chunk SET device = $2 WHERE ctid = $1
   Foreign Update on _timescaledb_internal._hyper_6_9_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_9_dist_chunk SET device = $2 WHERE ctid = $1
   Foreign Update on _timescaledb_internal._hyper_6_10_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_10_dist_chunk SET device = $2 WHERE ctid = $1
   Foreign Update on _timescaledb_internal._hyper_6_11_dist_chunk
     Remote SQL: UPDATE _timescaledb_internal._hyper_6_11_dist_chunk SET device = $2 WHERE ctid = $1
   InitPlan 1 (returns $0)
     ->  Limit (actual rows=1 loops=1)
           Output: disttable_replicated_1.device
           ->  Unique (actual rows=1 loops=1)
                 Output: disttable_replicated_1.device
                 ->  Merge Append (actual rows=1 loops=1)
                       Sort Key: disttable_replicated_1.device
                       ->  Sort (actual rows=0 loops=1)
                             Output: disttable_replicated_1.device
                             Sort Key: disttable_replicated_1.device
                             Sort Method: quicksort 
                             ->  Seq Scan on public.disttable_replicated disttable_replicated_1 (actual rows=0 loops=1)
                                   Output: disttable_replicated_1.device
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_6_dist_chunk _hyper_6_6_dist_chunk_1 (actual rows=1 loops=1)
                             Output: _hyper_6_6_dist_chunk_1.device
                             Server: server_1
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_6_dist_chunk ORDER BY device ASC NULLS LAST
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_7_dist_chunk _hyper_6_7_dist_chunk_1 (actual rows=1 loops=1)
                             Output: _hyper_6_7_dist_chunk_1.device
                             Server: server_2
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_7_dist_chunk ORDER BY device ASC NULLS LAST
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_8_dist_chunk _hyper_6_8_dist_chunk_1 (actual rows=1 loops=1)
                             Output: _hyper_6_8_dist_chunk_1.device
                             Server: server_3
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_8_dist_chunk ORDER BY device ASC NULLS LAST
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_9_dist_chunk _hyper_6_9_dist_chunk_1 (actual rows=1 loops=1)
                             Output: _hyper_6_9_dist_chunk_1.device
                             Server: server_1
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_9_dist_chunk ORDER BY device ASC NULLS LAST
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_10_dist_chunk _hyper_6_10_dist_chunk_1 (actual rows=1 loops=1)
                             Output: _hyper_6_10_dist_chunk_1.device
                             Server: server_2
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_10_dist_chunk ORDER BY device ASC NULLS LAST
                       ->  Foreign Scan on _timescaledb_internal._hyper_6_11_dist_chunk _hyper_6_11_dist_chunk_1 (actual rows=1 loops=1)
                             Output: _hyper_6_11_dist_chunk_1.device
                             Server: server_3
                             Remote SQL: SELECT device FROM _timescaledb_internal._hyper_6_11_dist_chunk ORDER BY device ASC NULLS LAST
   ->  Seq Scan on public.disttable_replicated (actual rows=0 loops=1)
         Output: disttable_replicated."time", 2, disttable_replicated.temp, disttable_replicated."Color", disttable_replicated.ctid
         Filter: (disttable_replicated.device = $0)
   ->  Foreign Scan on _timescaledb_internal._hyper_6_6_dist_chunk (actual rows=2 loops=1)
         Output: _hyper_6_6_dist_chunk."time", 2, _hyper_6_6_dist_chunk.temp, _hyper_6_6_dist_chunk."Color", _hyper_6_6_dist_chunk.ctid
         Server: server_1
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_6_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
   ->  Foreign Scan on _timescaledb_internal._hyper_6_7_dist_chunk (actual rows=0 loops=1)
         Output: _hyper_6_7_dist_chunk."time", 2, _hyper_6_7_dist_chunk.temp, _hyper_6_7_dist_chunk."Color", _hyper_6_7_dist_chunk.ctid
         Server: server_2
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_7_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
   ->  Foreign Scan on _timescaledb_internal._hyper_6_8_dist_chunk (actual rows=0 loops=1)
         Output: _hyper_6_8_dist_chunk."time", 2, _hyper_6_8_dist_chunk.temp, _hyper_6_8_dist_chunk."Color", _hyper_6_8_dist_chunk.ctid
         Server: server_3
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_8_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
   ->  Foreign Scan on _timescaledb_internal._hyper_6_9_dist_chunk (actual rows=0 loops=1)
         Output: _hyper_6_9_dist_chunk."time", 2, _hyper_6_9_dist_chunk.temp, _hyper_6_9_dist_chunk."Color", _hyper_6_9_dist_chunk.ctid
         Server: server_1
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_9_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
   ->  Foreign Scan on _timescaledb_internal._hyper_6_10_dist_chunk (actual rows=0 loops=1)
         Output: _hyper_6_10_dist_chunk."time", 2, _hyper_6_10_dist_chunk.temp, _hyper_6_10_dist_chunk."Color", _hyper_6_10_dist_chunk.ctid
         Server: server_2
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_10_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
   ->  Foreign Scan on _timescaledb_internal._hyper_6_11_dist_chunk (actual rows=0 loops=1)
         Output: _hyper_6_11_dist_chunk."time", 2, _hyper_6_11_dist_chunk.temp, _hyper_6_11_dist_chunk."Color", _hyper_6_11_dist_chunk.ctid
         Server: server_3
         Remote SQL: SELECT "time", temp, "Color", ctid FROM _timescaledb_internal._hyper_6_11_dist_chunk WHERE ((device = $1::integer)) FOR UPDATE
(78 rows)

-- Test inserts with smaller batch size and more tuples to reach full
-- batch
SET timescaledb.max_insert_batch_size=4;
CREATE TABLE twodim (time timestamptz DEFAULT '2019-02-10 10:11', "Color" int DEFAULT 11 CHECK ("Color" > 0), temp float DEFAULT 22.1);
-- Create a replicated table to ensure we handle that case correctly
-- with batching
SELECT * FROM create_hypertable('twodim', 'time', 'Color', 3, replication_factor => 2, servers => '{ "server_1", "server_2", "server_3" }');
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             7 | public      | twodim     | t
(1 row)

SELECT * FROM twodim
ORDER BY time;
 time | Color | temp 
------+-------+------
(0 rows)

-- INSERT enough data to stretch across multiple batches per
-- server. Also return a system column. Although we write tuples to
-- multiple servers, the returned tuple should only be the ones in the
-- original insert statement (without the replica tuples).
WITH result AS (
     INSERT INTO twodim VALUES
       ('2017-02-01 06:01', 1, 1.1),
       ('2017-02-01 08:01', 1, 1.2),
       ('2018-02-02 08:01', 2, 1.3),
       ('2019-02-01 09:11', 3, 2.1),
       ('2019-02-02 09:11', 3, 2.1),
       ('2019-02-02 10:01', 5, 1.2),
       ('2019-02-03 11:11', 6, 3.5),
       ('2019-02-04 08:21', 4, 6.6),
       ('2019-02-04 10:11', 7, 7.4),
       ('2019-02-04 12:11', 8, 2.1),
       ('2019-02-05 13:31', 8, 6.3),
       ('2019-02-06 02:11', 5, 1.8),
       ('2019-02-06 01:13', 7, 7.9),
       ('2019-02-06 19:24', 9, 5.9),
       ('2019-02-07 18:44', 5, 9.7),
       ('2019-02-07 20:24', 6, NULL),
       ('2019-02-07 09:33', 7, 9.5),
       ('2019-02-08 08:54', 1, 7.3),
       ('2019-02-08 18:14', 4, 8.2),
       ('2019-02-09 19:23', 8, 9.1)
     RETURNING tableoid = 'twodim'::regclass AS is_tableoid, time, temp, "Color"
) SELECT * FROM result ORDER BY time;
 is_tableoid |             time             | temp | Color 
-------------+------------------------------+------+-------
 t           | Wed Feb 01 06:01:00 2017 PST |  1.1 |     1
 t           | Wed Feb 01 08:01:00 2017 PST |  1.2 |     1
 t           | Fri Feb 02 08:01:00 2018 PST |  1.3 |     2
 t           | Fri Feb 01 09:11:00 2019 PST |  2.1 |     3
 t           | Sat Feb 02 09:11:00 2019 PST |  2.1 |     3
 t           | Sat Feb 02 10:01:00 2019 PST |  1.2 |     5
 t           | Sun Feb 03 11:11:00 2019 PST |  3.5 |     6
 t           | Mon Feb 04 08:21:00 2019 PST |  6.6 |     4
 t           | Mon Feb 04 10:11:00 2019 PST |  7.4 |     7
 t           | Mon Feb 04 12:11:00 2019 PST |  2.1 |     8
 t           | Tue Feb 05 13:31:00 2019 PST |  6.3 |     8
 t           | Wed Feb 06 01:13:00 2019 PST |  7.9 |     7
 t           | Wed Feb 06 02:11:00 2019 PST |  1.8 |     5
 t           | Wed Feb 06 19:24:00 2019 PST |  5.9 |     9
 t           | Thu Feb 07 09:33:00 2019 PST |  9.5 |     7
 t           | Thu Feb 07 18:44:00 2019 PST |  9.7 |     5
 t           | Thu Feb 07 20:24:00 2019 PST |      |     6
 t           | Fri Feb 08 08:54:00 2019 PST |  7.3 |     1
 t           | Fri Feb 08 18:14:00 2019 PST |  8.2 |     4
 t           | Sat Feb 09 19:23:00 2019 PST |  9.1 |     8
(20 rows)

-- Test insert with default values and a batch size of 1.
SET timescaledb.max_insert_batch_size=1;
EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF)
INSERT INTO twodim DEFAULT VALUES;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable public.twodim
   Servers: server_1, server_2, server_3
   ->  Insert on public.twodim
         ->  Custom Scan (ServerDispatch)
               Output: 'Sun Feb 10 10:11:00 2019 PST'::timestamp with time zone, 11, '22.1'::double precision
               Batch size: 1
               Remote SQL: INSERT INTO public.twodim("time", "Color", temp) VALUES ($1, $2, $3)
               ->  Custom Scan (ChunkDispatch)
                     Output: 'Sun Feb 10 10:11:00 2019 PST'::timestamp with time zone, 11, '22.1'::double precision
                     ->  Result
                           Output: 'Sun Feb 10 10:11:00 2019 PST'::timestamp with time zone, 11, '22.1'::double precision
(12 rows)

INSERT INTO twodim DEFAULT VALUES;
-- Reset the batch size
SET timescaledb.max_insert_batch_size=4;
-- Constraint violation
\set ON_ERROR_STOP 0
INSERT INTO twodim VALUES ('2019-02-10 17:54', 0, 10.2);
ERROR:  remote connection error: new row for relation "_hyper_7_17_dist_chunk" violates check constraint "twodim_Color_check"
\set ON_ERROR_STOP 1
-- Disable batching, reverting to FDW tuple-by-tuple inserts.
-- First EXPLAIN with batching turned on.
EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF)
INSERT INTO twodim VALUES
       ('2019-02-10 16:23', 5, 7.1),
       ('2019-02-10 17:11', 7, 3.2);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable public.twodim
   Servers: server_1, server_2, server_3
   ->  Insert on public.twodim
         ->  Custom Scan (ServerDispatch)
               Output: "*VALUES*".column1, "*VALUES*".column2, "*VALUES*".column3
               Batch size: 4
               Remote SQL: INSERT INTO public.twodim("time", "Color", temp) VALUES ($1, $2, $3), ..., ($10, $11, $12)
               ->  Custom Scan (ChunkDispatch)
                     Output: "*VALUES*".column1, "*VALUES*".column2, "*VALUES*".column3
                     ->  Values Scan on "*VALUES*"
                           Output: "*VALUES*".column1, "*VALUES*".column2, "*VALUES*".column3
(12 rows)

SET timescaledb.max_insert_batch_size=0;
-- Compare without batching
EXPLAIN (VERBOSE, COSTS OFF, TIMING OFF, SUMMARY OFF)
INSERT INTO twodim VALUES
       ('2019-02-10 16:23', 5, 7.1),
       ('2019-02-10 17:11', 7, 3.2);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Custom Scan (HypertableInsert)
 Insert on distributed hypertable public.twodim
   Servers: server_1, server_2, server_3
   Remote SQL: INSERT INTO public.twodim("time", "Color", temp) VALUES ($1, $2, $3)
   ->  Insert on public.twodim
         ->  Custom Scan (ChunkDispatch)
               Output: "*VALUES*".column1, "*VALUES*".column2, "*VALUES*".column3
               ->  Values Scan on "*VALUES*"
                     Output: "*VALUES*".column1, "*VALUES*".column2, "*VALUES*".column3
(9 rows)

-- Insert without batching
INSERT INTO twodim VALUES
       ('2019-02-10 16:23', 5, 7.1),
       ('2019-02-10 17:11', 7, 3.2);
-- Check results
SELECT * FROM twodim
ORDER BY time;
             time             | Color | temp 
------------------------------+-------+------
 Wed Feb 01 06:01:00 2017 PST |     1 |  1.1
 Wed Feb 01 08:01:00 2017 PST |     1 |  1.2
 Fri Feb 02 08:01:00 2018 PST |     2 |  1.3
 Fri Feb 01 09:11:00 2019 PST |     3 |  2.1
 Sat Feb 02 09:11:00 2019 PST |     3 |  2.1
 Sat Feb 02 10:01:00 2019 PST |     5 |  1.2
 Sun Feb 03 11:11:00 2019 PST |     6 |  3.5
 Mon Feb 04 08:21:00 2019 PST |     4 |  6.6
 Mon Feb 04 10:11:00 2019 PST |     7 |  7.4
 Mon Feb 04 12:11:00 2019 PST |     8 |  2.1
 Tue Feb 05 13:31:00 2019 PST |     8 |  6.3
 Wed Feb 06 01:13:00 2019 PST |     7 |  7.9
 Wed Feb 06 02:11:00 2019 PST |     5 |  1.8
 Wed Feb 06 19:24:00 2019 PST |     9 |  5.9
 Thu Feb 07 09:33:00 2019 PST |     7 |  9.5
 Thu Feb 07 18:44:00 2019 PST |     5 |  9.7
 Thu Feb 07 20:24:00 2019 PST |     6 |     
 Fri Feb 08 08:54:00 2019 PST |     1 |  7.3
 Fri Feb 08 18:14:00 2019 PST |     4 |  8.2
 Sat Feb 09 19:23:00 2019 PST |     8 |  9.1
 Sun Feb 10 10:11:00 2019 PST |    11 | 22.1
 Sun Feb 10 16:23:00 2019 PST |     5 |  7.1
 Sun Feb 10 17:11:00 2019 PST |     7 |  3.2
(23 rows)

SELECT count(*) FROM twodim;
 count 
-------
    23
(1 row)

-- Show distribution across servers
\c server_1
SELECT * FROM twodim
ORDER BY time;
             time             | Color | temp 
------------------------------+-------+------
 Wed Feb 01 06:01:00 2017 PST |     1 |  1.1
 Wed Feb 01 08:01:00 2017 PST |     1 |  1.2
 Fri Feb 01 09:11:00 2019 PST |     3 |  2.1
 Sat Feb 02 09:11:00 2019 PST |     3 |  2.1
 Sun Feb 03 11:11:00 2019 PST |     6 |  3.5
 Mon Feb 04 12:11:00 2019 PST |     8 |  2.1
 Tue Feb 05 13:31:00 2019 PST |     8 |  6.3
 Wed Feb 06 19:24:00 2019 PST |     9 |  5.9
 Thu Feb 07 20:24:00 2019 PST |     6 |     
 Fri Feb 08 08:54:00 2019 PST |     1 |  7.3
 Sat Feb 09 19:23:00 2019 PST |     8 |  9.1
 Sun Feb 10 10:11:00 2019 PST |    11 | 22.1
(12 rows)

SELECT count(*) FROM twodim;
 count 
-------
    12
(1 row)

\c server_2
SELECT * FROM twodim
ORDER BY time;
             time             | Color | temp 
------------------------------+-------+------
 Wed Feb 01 06:01:00 2017 PST |     1 |  1.1
 Wed Feb 01 08:01:00 2017 PST |     1 |  1.2
 Fri Feb 02 08:01:00 2018 PST |     2 |  1.3
 Sat Feb 02 10:01:00 2019 PST |     5 |  1.2
 Sun Feb 03 11:11:00 2019 PST |     6 |  3.5
 Mon Feb 04 08:21:00 2019 PST |     4 |  6.6
 Mon Feb 04 10:11:00 2019 PST |     7 |  7.4
 Mon Feb 04 12:11:00 2019 PST |     8 |  2.1
 Tue Feb 05 13:31:00 2019 PST |     8 |  6.3
 Wed Feb 06 01:13:00 2019 PST |     7 |  7.9
 Wed Feb 06 02:11:00 2019 PST |     5 |  1.8
 Thu Feb 07 09:33:00 2019 PST |     7 |  9.5
 Thu Feb 07 18:44:00 2019 PST |     5 |  9.7
 Thu Feb 07 20:24:00 2019 PST |     6 |     
 Fri Feb 08 08:54:00 2019 PST |     1 |  7.3
 Fri Feb 08 18:14:00 2019 PST |     4 |  8.2
 Sat Feb 09 19:23:00 2019 PST |     8 |  9.1
 Sun Feb 10 16:23:00 2019 PST |     5 |  7.1
 Sun Feb 10 17:11:00 2019 PST |     7 |  3.2
(19 rows)

SELECT count(*) FROM twodim;
 count 
-------
    19
(1 row)

\c server_3
SELECT * FROM twodim
ORDER BY time;
             time             | Color | temp 
------------------------------+-------+------
 Fri Feb 02 08:01:00 2018 PST |     2 |  1.3
 Fri Feb 01 09:11:00 2019 PST |     3 |  2.1
 Sat Feb 02 09:11:00 2019 PST |     3 |  2.1
 Sat Feb 02 10:01:00 2019 PST |     5 |  1.2
 Mon Feb 04 08:21:00 2019 PST |     4 |  6.6
 Mon Feb 04 10:11:00 2019 PST |     7 |  7.4
 Wed Feb 06 01:13:00 2019 PST |     7 |  7.9
 Wed Feb 06 02:11:00 2019 PST |     5 |  1.8
 Wed Feb 06 19:24:00 2019 PST |     9 |  5.9
 Thu Feb 07 09:33:00 2019 PST |     7 |  9.5
 Thu Feb 07 18:44:00 2019 PST |     5 |  9.7
 Fri Feb 08 18:14:00 2019 PST |     4 |  8.2
 Sun Feb 10 10:11:00 2019 PST |    11 | 22.1
 Sun Feb 10 16:23:00 2019 PST |     5 |  7.1
 Sun Feb 10 17:11:00 2019 PST |     7 |  3.2
(15 rows)

SELECT count(*) FROM twodim;
 count 
-------
    15
(1 row)

