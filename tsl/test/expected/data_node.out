-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
\c :TEST_DBNAME :ROLE_SUPERUSER;
\unset ECHO
psql:include/remote_exec.sql:5: NOTICE:  schema "test" already exists, skipping
-- Cleanup from other potential tests that created these databases
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS data_node_1;
DROP DATABASE IF EXISTS data_node_2;
DROP DATABASE IF EXISTS data_node_3;
DROP DATABASE IF EXISTS data_node_4;
SET client_min_messages TO NOTICE;
-- Must use cluster user for password auth
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Add data nodes using TimescaleDB data_node management API. NOTE that the
-- extension won't be created since it is installed in the template1
-- database
SELECT * FROM add_data_node('data_node_1', database => 'data_node_1',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_1"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_1 | localhost | 15432 | data_node_1 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_2', database => 'data_node_2',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_2"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_2 | localhost | 15432 | data_node_2 | t            | t                | t
(1 row)

\set ON_ERROR_STOP 0
-- Add again
SELECT * FROM add_data_node('data_node_2', password => :'ROLE_DEFAULT_CLUSTER_USER_PASS');
ERROR:  server "data_node_2" already exists
-- Add without password
SELECT * FROM add_data_node('data_node_3');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_3"
ERROR:  no password specified for user "default_cluster_user"
-- Add NULL data_node
SELECT * FROM add_data_node(NULL);
ERROR:  invalid data node name
\set ON_ERROR_STOP 1
-- Should not generate error with if_not_exists option
SELECT * FROM add_data_node('data_node_2', database => 'data_node_2',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS',
                                     if_not_exists => true);
NOTICE:  data node "data_node_2" already exists, skipping
NOTICE:  database "data_node_2" already exists on data node, skipping
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_2 | localhost | 15432 | data_node_2 | f            | f                | f
(1 row)

SELECT * FROM add_data_node('data_node_3', database => 'data_node_3',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_3"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_3 | localhost | 15432 | data_node_3 | t            | t                | t
(1 row)

-- Data node exists, but no user mapping
CREATE SERVER data_node_4 FOREIGN DATA WRAPPER timescaledb_fdw
OPTIONS (host 'localhost', port '15432', dbname 'data_node_4');
-- User mapping should be added with NOTICE
SELECT * FROM add_data_node('data_node_4', database => 'data_node_4',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS',
                                     if_not_exists => true);
NOTICE:  data node "data_node_4" already exists, skipping
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_4"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_4 | localhost | 15432 | data_node_4 | f            | t                | t
(1 row)

-- List foreign data nodes
SELECT * FROM timescaledb_information.data_node;
  node_name  |        owner         |                    options                     | node_up | num_dist_tables | num_dist_chunks | total_dist_size 
-------------+----------------------+------------------------------------------------+---------+-----------------+-----------------+-----------------
 data_node_3 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_3} | t       |               1 |                 | 
 data_node_4 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_4} | t       |               1 |                 | 
 data_node_1 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_1} | t       |               1 |                 | 
 data_node_2 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_2} | t       |               1 |                 | 
(4 rows)

RESET ROLE;
SELECT rolname, srvname, umoptions
FROM pg_user_mapping um, pg_authid a, pg_foreign_server fs
WHERE a.oid = um.umuser AND fs.oid = um.umserver
ORDER BY srvname;
       rolname        |   srvname   |                 umoptions                 
----------------------+-------------+-------------------------------------------
 default_cluster_user | data_node_1 | {user=default_cluster_user,password=pass}
 default_cluster_user | data_node_2 | {user=default_cluster_user,password=pass}
 default_cluster_user | data_node_3 | {user=default_cluster_user,password=pass}
 default_cluster_user | data_node_4 | {user=default_cluster_user,password=pass}
(4 rows)

SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Delete a data node
\set ON_ERROR_STOP 0
-- Cannot delete if not owner
SELECT * FROM delete_data_node('data_node_3');
ERROR:  cannot drop server data_node_3 because other objects depend on it
-- Must use cascade because of user mappings
SELECT * FROM delete_data_node('data_node_3');
ERROR:  cannot drop server data_node_3 because other objects depend on it
\set ON_ERROR_STOP 1
-- Should work as superuser with cascade
SELECT * FROM delete_data_node('data_node_3', cascade => true);
NOTICE:  drop cascades to user mapping for default_cluster_user on server data_node_3
 delete_data_node 
------------------
 t
(1 row)

-- List data nodes
SELECT * FROM timescaledb_information.data_node;
  node_name  |        owner         |                    options                     | node_up | num_dist_tables | num_dist_chunks | total_dist_size 
-------------+----------------------+------------------------------------------------+---------+-----------------+-----------------+-----------------
 data_node_1 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_1} | t       |               1 |                 | 
 data_node_2 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_2} | t       |               1 |                 | 
 data_node_4 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_4} | t       |               1 |                 | 
(3 rows)

RESET ROLE;
SELECT rolname, srvname, umoptions
FROM pg_user_mapping um, pg_authid a, pg_foreign_server fs
WHERE a.oid = um.umuser AND fs.oid = um.umserver
ORDER BY srvname;
       rolname        |   srvname   |                 umoptions                 
----------------------+-------------+-------------------------------------------
 default_cluster_user | data_node_1 | {user=default_cluster_user,password=pass}
 default_cluster_user | data_node_2 | {user=default_cluster_user,password=pass}
 default_cluster_user | data_node_4 | {user=default_cluster_user,password=pass}
(3 rows)

SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\set ON_ERROR_STOP 0
-- Deleting a non-existing data node generates error
SELECT * FROM delete_data_node('data_node_3');
ERROR:  server "data_node_3" does not exist
\set ON_ERROR_STOP 1
-- Deleting non-existing data node with "if_exists" set does not generate error
SELECT * FROM delete_data_node('data_node_3', if_exists => true);
NOTICE:  data node "data_node_3" does not exist, skipping
 delete_data_node 
------------------
 f
(1 row)

SELECT * FROM timescaledb_information.data_node;
  node_name  |        owner         |                    options                     | node_up | num_dist_tables | num_dist_chunks | total_dist_size 
-------------+----------------------+------------------------------------------------+---------+-----------------+-----------------+-----------------
 data_node_1 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_1} | t       |               1 |                 | 
 data_node_2 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_2} | t       |               1 |                 | 
 data_node_4 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_4} | t       |               1 |                 | 
(3 rows)

DROP SERVER data_node_1 CASCADE;
NOTICE:  drop cascades to user mapping for default_cluster_user on server data_node_1
SELECT * FROM delete_data_node('data_node_2', cascade => true);
NOTICE:  drop cascades to user mapping for default_cluster_user on server data_node_2
 delete_data_node 
------------------
 t
(1 row)

SELECT * FROM delete_data_node('data_node_4', cascade => true);
NOTICE:  drop cascades to user mapping for default_cluster_user on server data_node_4
 delete_data_node 
------------------
 t
(1 row)

-- No data nodes left
SELECT * FROM timescaledb_information.data_node;
 node_name | owner | options | node_up | num_dist_tables | num_dist_chunks | total_dist_size 
-----------+-------+---------+---------+-----------------+-----------------+-----------------
(0 rows)

-- Cleanup databases
RESET ROLE;
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS data_node_1;
DROP DATABASE IF EXISTS data_node_2;
DROP DATABASE IF EXISTS data_node_4;
SET client_min_messages TO INFO;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
SELECT * FROM add_data_node('data_node_1', database => 'data_node_1',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_1"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_1 | localhost | 15432 | data_node_1 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_2', database => 'data_node_2',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_2"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_2 | localhost | 15432 | data_node_2 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_4', database => 'data_node_4',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_4"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_4 | localhost | 15432 | data_node_4 | t            | t                | t
(1 row)

SELECT * FROM timescaledb_information.data_node;
  node_name  |        owner         |                    options                     | node_up | num_dist_tables | num_dist_chunks | total_dist_size 
-------------+----------------------+------------------------------------------------+---------+-----------------+-----------------+-----------------
 data_node_1 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_1} | t       |               1 |                 | 
 data_node_2 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_2} | t       |               1 |                 | 
 data_node_4 | default_cluster_user | {host=localhost,port=15432,dbname=data_node_4} | t       |               1 |                 | 
(3 rows)

-- Switch to default user
SET ROLE :ROLE_DEFAULT_PERM_USER;
-- Now create a distributed hypertable using the data nodes
CREATE TABLE disttable(time timestamptz, device int, temp float);
-- Test that we can't create the distributed hypertable without USAGE
-- on data nodes.
\set ON_ERROR_STOP 0
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device', 2);
NOTICE:  adding not-null constraint to column "time"
ERROR:  permission denied for foreign server data_node_1
\set ON_ERROR_STOP 1
RESET ROLE;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Grant usage on data nodes and create user mappings
GRANT USAGE ON FOREIGN SERVER data_node_1, data_node_2, data_node_4 TO :ROLE_DEFAULT_PERM_USER;
CREATE USER MAPPING FOR :ROLE_DEFAULT_PERM_USER SERVER data_node_1
OPTIONS (user :'ROLE_DEFAULT_CLUSTER_USER', password :'ROLE_DEFAULT_CLUSTER_USER_PASS');
CREATE USER MAPPING FOR :ROLE_DEFAULT_PERM_USER SERVER data_node_2
OPTIONS (user :'ROLE_DEFAULT_CLUSTER_USER', password :'ROLE_DEFAULT_CLUSTER_USER_PASS');
CREATE USER MAPPING FOR :ROLE_DEFAULT_PERM_USER SERVER data_node_4
OPTIONS (user :'ROLE_DEFAULT_CLUSTER_USER', password :'ROLE_DEFAULT_CLUSTER_USER_PASS');
RESET ROLE;
SET ROLE :ROLE_DEFAULT_PERM_USER;
-- Test that all data nodes are added to a hypertable and that the
-- slices in the device dimension equals the number of data nodes.
BEGIN;
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device');
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             2 | public      | disttable  | t
(1 row)

SELECT column_name, num_slices
FROM _timescaledb_catalog.dimension
WHERE column_name = 'device';
 column_name | num_slices 
-------------+------------
 device      |          3
(1 row)

-- All data nodes should be added.
SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             2 |                  1 | data_node_1 | f
             2 |                  1 | data_node_2 | f
             2 |                  1 | data_node_4 | f
(3 rows)

ROLLBACK;
-- Now specify less slices than there are data nodes to generate a
-- warning
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device', 2);
NOTICE:  adding not-null constraint to column "time"
WARNING:  the number of partitions in dimension "device" is too low to make use of all attached data nodes
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             3 | public      | disttable  | t
(1 row)

-- All data nodes should be added.
SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             3 |                  2 | data_node_1 | f
             3 |                  2 | data_node_2 | f
             3 |                  2 | data_node_4 | f
(3 rows)

-- Ensure that replication factor allows to distinguish data node hypertables from regular hypertables
SELECT replication_factor FROM _timescaledb_catalog.hypertable WHERE table_name = 'disttable';
 replication_factor 
--------------------
                  1
(1 row)

SELECT * FROM test.remote_exec(NULL, $$ SELECT replication_factor
FROM _timescaledb_catalog.hypertable WHERE table_name = 'disttable'; $$);
NOTICE:  [data_node_1]:  SELECT replication_factor
FROM _timescaledb_catalog.hypertable WHERE table_name = 'disttable'
NOTICE:  [data_node_1]:
replication_factor
------------------
                -1
(1 row)


NOTICE:  [data_node_2]:  SELECT replication_factor
FROM _timescaledb_catalog.hypertable WHERE table_name = 'disttable'
NOTICE:  [data_node_2]:
replication_factor
------------------
                -1
(1 row)


NOTICE:  [data_node_4]:  SELECT replication_factor
FROM _timescaledb_catalog.hypertable WHERE table_name = 'disttable'
NOTICE:  [data_node_4]:
replication_factor
------------------
                -1
(1 row)


 remote_exec 
-------------
 
(1 row)

-- Create one chunk
INSERT INTO disttable VALUES ('2019-02-02 10:45', 1, 23.4);
-- Chunk mapping created
SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id |  node_name  
----------+---------------+-------------
        1 |             1 | data_node_1
(1 row)

DROP TABLE disttable;
-- data node mappings should be cleaned up
SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id | node_name | block_chunks 
---------------+--------------------+-----------+--------------
(0 rows)

SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id | node_name 
----------+---------------+-----------
(0 rows)

-- Now create tables as cluster user
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE TABLE disttable(time timestamptz, device int, temp float);
\set ON_ERROR_STOP 0
-- Attach data node should fail when called on a non-hypertable
SELECT * FROM attach_data_node('data_node_1', 'disttable');
ERROR:  table "disttable" is not a hypertable
-- Test some bad create_hypertable() parameter values for distributed hypertables
-- Bad replication factor
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device', replication_factor => 0, data_nodes => '{ "data_node_2", "data_node_4" }');
ERROR:  invalid replication_factor
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device', replication_factor => 32768);
ERROR:  invalid replication_factor
SELECT * FROM create_hypertable('disttable', 'time', replication_factor => -1);
ERROR:  invalid replication_factor
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device', replication_factor => -1);
ERROR:  invalid replication_factor
-- Non-existing data node
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device', replication_factor => 2, data_nodes => '{ "data_node_3" }');
NOTICE:  adding not-null constraint to column "time"
ERROR:  server "data_node_3" does not exist
\set ON_ERROR_STOP 1
-- Use a subset of data nodes and a replication factor of two so that
-- each chunk is associated with more than one data node. Set
-- number_partitions lower than number of servers to raise a warning
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device', number_partitions => 1, replication_factor => 2, data_nodes => '{ "data_node_2", "data_node_4" }');
NOTICE:  adding not-null constraint to column "time"
WARNING:  the number of partitions in dimension "device" is too low to make use of all attached data nodes
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             5 | public      | disttable  | t
(1 row)

-- Create some chunks
INSERT INTO disttable VALUES
       ('2019-02-02 10:45', 1, 23.4),
       ('2019-05-23 10:45', 4, 14.9),
       ('2019-07-23 10:45', 8, 7.6);
SELECT * FROM test.show_subtables('disttable');
                    Child                    | Tablespace 
---------------------------------------------+------------
 _timescaledb_internal._hyper_5_2_dist_chunk | 
 _timescaledb_internal._hyper_5_3_dist_chunk | 
 _timescaledb_internal._hyper_5_4_dist_chunk | 
(3 rows)

SELECT * FROM _timescaledb_catalog.chunk;
 id | hypertable_id |      schema_name      |      table_name       | compressed_chunk_id | dropped 
----+---------------+-----------------------+-----------------------+---------------------+---------
  2 |             5 | _timescaledb_internal | _hyper_5_2_dist_chunk |                     | f
  3 |             5 | _timescaledb_internal | _hyper_5_3_dist_chunk |                     | f
  4 |             5 | _timescaledb_internal | _hyper_5_4_dist_chunk |                     | f
(3 rows)

SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             5 |                  3 | data_node_2 | f
             5 |                  3 | data_node_4 | f
(2 rows)

SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id |  node_name  
----------+---------------+-------------
        2 |             1 | data_node_2
        2 |             1 | data_node_4
        3 |             2 | data_node_2
        3 |             2 | data_node_4
        4 |             3 | data_node_2
        4 |             3 | data_node_4
(6 rows)

-- Dropping a chunk should also clean up data node mappings
SELECT * FROM drop_chunks(older_than => '2019-05-22 17:18'::timestamptz);
                 drop_chunks                 
---------------------------------------------
 _timescaledb_internal._hyper_5_2_dist_chunk
(1 row)

SELECT * FROM test.show_subtables('disttable');
                    Child                    | Tablespace 
---------------------------------------------+------------
 _timescaledb_internal._hyper_5_3_dist_chunk | 
 _timescaledb_internal._hyper_5_4_dist_chunk | 
(2 rows)

SELECT foreign_table_name, foreign_server_name
FROM information_schema.foreign_tables
ORDER BY foreign_table_name;
  foreign_table_name   | foreign_server_name 
-----------------------+---------------------
 _hyper_5_3_dist_chunk | data_node_2
 _hyper_5_4_dist_chunk | data_node_2
(2 rows)

SELECT table_name, node_name
FROM _timescaledb_catalog.chunk c,
_timescaledb_catalog.chunk_data_node cdn
WHERE c.id = cdn.chunk_id;
      table_name       |  node_name  
-----------------------+-------------
 _hyper_5_3_dist_chunk | data_node_2
 _hyper_5_3_dist_chunk | data_node_4
 _hyper_5_4_dist_chunk | data_node_2
 _hyper_5_4_dist_chunk | data_node_4
(4 rows)

-- Setting the same data node should do nothing and return false
SELECT * FROM _timescaledb_internal.set_chunk_default_data_node('_timescaledb_internal._hyper_5_3_dist_chunk', 'data_node_4');
 set_chunk_default_data_node 
-----------------------------
 t
(1 row)

-- Should update the default data node and return true
SELECT * FROM _timescaledb_internal.set_chunk_default_data_node('_timescaledb_internal._hyper_5_3_dist_chunk', 'data_node_2');
 set_chunk_default_data_node 
-----------------------------
 t
(1 row)

SELECT foreign_table_name, foreign_server_name
FROM information_schema.foreign_tables
ORDER BY foreign_table_name;
  foreign_table_name   | foreign_server_name 
-----------------------+---------------------
 _hyper_5_3_dist_chunk | data_node_2
 _hyper_5_4_dist_chunk | data_node_2
(2 rows)

-- Reset the default data node
SELECT * FROM _timescaledb_internal.set_chunk_default_data_node('_timescaledb_internal._hyper_5_3_dist_chunk', 'data_node_4');
 set_chunk_default_data_node 
-----------------------------
 t
(1 row)

\set ON_ERROR_STOP 0
-- Will fail because data_node_2 contains chunks
SELECT * FROM delete_data_node('data_node_2', cascade => true);
ERROR:  deleting data node "data_node_2" failed because it contains chunks for hypertable "disttable"
-- non-existing chunk
SELECT * FROM _timescaledb_internal.set_chunk_default_data_node('x_chunk', 'data_node_4');
ERROR:  relation "x_chunk" does not exist at character 65
-- non-existing data node
SELECT * FROM _timescaledb_internal.set_chunk_default_data_node('_timescaledb_internal._hyper_5_3_dist_chunk', 'data_node_0000');
ERROR:  server "data_node_0000" does not exist
-- data node exists but does not store the chunk
SELECT * FROM _timescaledb_internal.set_chunk_default_data_node('_timescaledb_internal._hyper_5_3_dist_chunk', 'data_node_1');
ERROR:  chunk "_hyper_5_3_dist_chunk" does not exist on server "data_node_1"
-- NULL try
SELECT * FROM _timescaledb_internal.set_chunk_default_data_node(NULL, 'data_node_4');
ERROR:  invalid chunk: cannot be NULL
\set ON_ERROR_STOP 1
-- Deleting a data node removes the "foreign" chunk table(s) that
-- reference that data node as "primary" and should also remove the
-- hypertable_data_node and chunk_data_node mappings for that data node.  In
-- the future we might want to fallback to a replica data node for those
-- chunks that have multiple data nodes so that the chunk is not removed
-- unnecessarily. We use force => true b/c data_node_2 contains chunks.
SELECT * FROM delete_data_node('data_node_2', cascade => true, force => true);
WARNING:  hypertable "disttable" has under-replicated chunks due to deleting data node "data_node_2"
WARNING:  new data for hypertable "disttable" will be under-replicated due to deleting data node "data_node_2"
NOTICE:  drop cascades to 2 other objects
 delete_data_node 
------------------
 t
(1 row)

SELECT * FROM test.show_subtables('disttable');
                    Child                    | Tablespace 
---------------------------------------------+------------
 _timescaledb_internal._hyper_5_3_dist_chunk | 
 _timescaledb_internal._hyper_5_4_dist_chunk | 
(2 rows)

SELECT foreign_table_name, foreign_server_name
FROM information_schema.foreign_tables
ORDER BY foreign_table_name;
  foreign_table_name   | foreign_server_name 
-----------------------+---------------------
 _hyper_5_3_dist_chunk | data_node_4
 _hyper_5_4_dist_chunk | data_node_4
(2 rows)

SELECT * FROM _timescaledb_catalog.chunk;
 id | hypertable_id |      schema_name      |      table_name       | compressed_chunk_id | dropped 
----+---------------+-----------------------+-----------------------+---------------------+---------
  3 |             5 | _timescaledb_internal | _hyper_5_3_dist_chunk |                     | f
  4 |             5 | _timescaledb_internal | _hyper_5_4_dist_chunk |                     | f
(2 rows)

SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             5 |                  3 | data_node_4 | f
(1 row)

SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id |  node_name  
----------+---------------+-------------
        3 |             2 | data_node_4
        4 |             3 | data_node_4
(2 rows)

\set ON_ERROR_STOP 0
-- can't delete b/c it's last data replica
SELECT * FROM delete_data_node('data_node_4', cascade => true, force => true);
ERROR:  deleting data node "data_node_4" would mean a data-loss for hypertable "disttable" since data node has the only data replica
\set ON_ERROR_STOP 1
-- Should also clean up hypertable_data_node when using standard DDL commands
DROP SERVER data_node_4 CASCADE;
NOTICE:  drop cascades to 4 other objects
SELECT * FROM test.show_subtables('disttable');
 Child | Tablespace 
-------+------------
(0 rows)

SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id | node_name | block_chunks 
---------------+--------------------+-----------+--------------
(0 rows)

SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id | node_name 
----------+---------------+-----------
(0 rows)

SELECT * FROM _timescaledb_catalog.chunk;
 id | hypertable_id | schema_name | table_name | compressed_chunk_id | dropped 
----+---------------+-------------+------------+---------------------+---------
(0 rows)

-- Attach data node should now succeed
SET client_min_messages TO NOTICE;
SELECT * FROM attach_data_node('data_node_1', 'disttable');
 hypertable_id | node_hypertable_id |  node_name  
---------------+--------------------+-------------
             5 |                  3 | data_node_1
(1 row)

SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             5 |                  3 | data_node_1 | f
(1 row)

SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id | node_name 
----------+---------------+-----------
(0 rows)

SELECT * FROM _timescaledb_internal.ping_data_node('data_node_1');
 ping_data_node 
----------------
 t
(1 row)

-- Create data node referencing postgres_fdw
RESET ROLE;
CREATE EXTENSION postgres_fdw;
CREATE SERVER pg_server_1 FOREIGN DATA WRAPPER postgres_fdw;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\set ON_ERROR_STOP 0
-- Throw ERROR for non-existing data node
SELECT * FROM _timescaledb_internal.ping_data_node('data_node_123456789');
ERROR:  server "data_node_123456789" does not exist
-- ERROR on NULL
SELECT * FROM _timescaledb_internal.ping_data_node(NULL);
ERROR:  invalid node_name: cannot be NULL
-- ERROR when not passing TimescaleDB data node
SELECT * FROM _timescaledb_internal.ping_data_node('pg_data_node_1');
ERROR:  server "pg_data_node_1" does not exist
\set ON_ERROR_STOP 1
-- Some attach data node error cases
\set ON_ERROR_STOP 0
-- Invalid arguments
SELECT * FROM attach_data_node('data_node_1', NULL, true);
ERROR:  invalid hypertable: cannot be NULL
SELECT * FROM attach_data_node(NULL, 'disttable', true);
ERROR:  invalid node_name: cannot be NULL
-- Deleted data node
SELECT * FROM attach_data_node('data_node_2', 'disttable');
ERROR:  server "data_node_2" does not exist
-- Attaching to an already attached data node without 'if_not_exists'
SELECT * FROM attach_data_node('data_node_1', 'disttable', false);
ERROR:  data node "data_node_1" is already attached to hypertable "disttable"
\set ON_ERROR_STOP 1
-- Attach if not exists
SELECT * FROM attach_data_node('data_node_1', 'disttable', true);
NOTICE:  data node "data_node_1" is already attached to hypertable "disttable", skipping
 hypertable_id | node_hypertable_id |  node_name  
---------------+--------------------+-------------
             5 |                  3 | data_node_1
(1 row)

-- Should repartition too. First show existing number of slices in
-- 'device' dimension
SELECT column_name, num_slices
FROM _timescaledb_catalog.dimension
WHERE num_slices IS NOT NULL
AND column_name = 'device';
 column_name | num_slices 
-------------+------------
 device      |          1
(1 row)

SELECT * FROM add_data_node('data_node_3', database => 'data_node_3',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS',
                                     if_not_exists => true);
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_3"
NOTICE:  database "data_node_3" already exists on data node, skipping
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_3 | localhost | 15432 | data_node_3 | t            | f                | f
(1 row)

SELECT * FROM attach_data_node('data_node_3', 'disttable');
NOTICE:  the number of partitions in dimension "device" was increased to 2
 hypertable_id | node_hypertable_id |  node_name  
---------------+--------------------+-------------
             5 |                  1 | data_node_3
(1 row)

-- Show updated number of slices in 'device' dimension.
SELECT column_name, num_slices
FROM _timescaledb_catalog.dimension
WHERE num_slices IS NOT NULL
AND column_name = 'device';
 column_name | num_slices 
-------------+------------
 device      |          2
(1 row)

-- Clean up
DROP TABLE disttable;
SELECT * FROM delete_data_node('data_node_3', cascade => true);
NOTICE:  drop cascades to user mapping for default_cluster_user on server data_node_3
 delete_data_node 
------------------
 t
(1 row)

-- Creating a distributed hypertable without any servers should fail
CREATE TABLE disttable(time timestamptz, device int, temp float);
\set ON_ERROR_STOP 0
-- Creating a distributed hypertable without any data nodes should fail
SELECT * FROM create_distributed_hypertable('disttable', 'time', data_nodes => '{ }');
NOTICE:  adding not-null constraint to column "time"
ERROR:  no data nodes can be assigned to "disttable"
\set ON_ERROR_STOP 1
SELECT * FROM delete_data_node('data_node_1', cascade => true);
NOTICE:  drop cascades to 2 other objects
 delete_data_node 
------------------
 t
(1 row)

SELECT * FROM timescaledb_information.data_node;
 node_name | owner | options | node_up | num_dist_tables | num_dist_chunks | total_dist_size 
-----------+-------+---------+---------+-----------------+-----------------+-----------------
(0 rows)

SELECT * FROM test.show_subtables('disttable');
 Child | Tablespace 
-------+------------
(0 rows)

SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id | node_name | block_chunks 
---------------+--------------------+-----------+--------------
(0 rows)

SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id | node_name 
----------+---------------+-----------
(0 rows)

SELECT * FROM _timescaledb_catalog.chunk;
 id | hypertable_id | schema_name | table_name | compressed_chunk_id | dropped 
----+---------------+-------------+------------+---------------------+---------
(0 rows)

\set ON_ERROR_STOP 0
-- No data nodes remain, so should fail
SELECT * FROM create_distributed_hypertable('disttable', 'time');
NOTICE:  adding not-null constraint to column "time"
ERROR:  no data nodes can be assigned to "disttable"
\set ON_ERROR_STOP 1
DROP DATABASE IF EXISTS data_node_3;
SELECT * FROM add_data_node('data_node_3', database => 'data_node_3',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_3"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_3 | localhost | 15432 | data_node_3 | t            | t                | t
(1 row)

-- Bring down the database but UserMapping should still be there
DROP DATABASE IF EXISTS data_node_3;
-- Return false if data node is down
SELECT * FROM _timescaledb_internal.ping_data_node('data_node_3');
 ping_data_node 
----------------
 f
(1 row)

DROP DATABASE data_node_1;
DROP DATABASE data_node_2;
DROP DATABASE data_node_4;
DROP SERVER data_node_3 CASCADE;
NOTICE:  drop cascades to user mapping for default_cluster_user on server data_node_3
-- there should be no data nodes
SELECT * FROM timescaledb_information.data_node;
 node_name | owner | options | node_up | num_dist_tables | num_dist_chunks | total_dist_size 
-----------+-------+---------+---------+-----------------+-----------------+-----------------
(0 rows)

-- let's add some
SELECT * FROM add_data_node('data_node_1', database => 'data_node_1',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_1"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_1 | localhost | 15432 | data_node_1 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_2', database => 'data_node_2',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_2"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_2 | localhost | 15432 | data_node_2 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_3', database => 'data_node_3',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_3"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_3 | localhost | 15432 | data_node_3 | t            | t                | t
(1 row)

DROP TABLE disttable;
CREATE TABLE disttable(time timestamptz, device int, temp float);
SELECT * FROM create_distributed_hypertable('disttable', 'time', 'device', 2,
                                            replication_factor => 2,
                                            data_nodes => '{"data_node_1", "data_node_2", "data_node_3"}');
NOTICE:  adding not-null constraint to column "time"
WARNING:  the number of partitions in dimension "device" is too low to make use of all attached data nodes
 hypertable_id | schema_name | table_name | created 
---------------+-------------+------------+---------
             8 | public      | disttable  | t
(1 row)

-- Create some chunks on all the data_nodes
INSERT INTO disttable VALUES
       ('2019-02-02 10:45', 1, 23.4),
       ('2019-05-23 10:45', 4, 14.9),
       ('2019-07-23 10:45', 8, 7.6);
SELECT * FROM test.show_subtables('disttable');
                    Child                    | Tablespace 
---------------------------------------------+------------
 _timescaledb_internal._hyper_8_5_dist_chunk | 
 _timescaledb_internal._hyper_8_6_dist_chunk | 
 _timescaledb_internal._hyper_8_7_dist_chunk | 
(3 rows)

SELECT * FROM _timescaledb_catalog.chunk;
 id | hypertable_id |      schema_name      |      table_name       | compressed_chunk_id | dropped 
----+---------------+-----------------------+-----------------------+---------------------+---------
  5 |             8 | _timescaledb_internal | _hyper_8_5_dist_chunk |                     | f
  6 |             8 | _timescaledb_internal | _hyper_8_6_dist_chunk |                     | f
  7 |             8 | _timescaledb_internal | _hyper_8_7_dist_chunk |                     | f
(3 rows)

SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             8 |                  1 | data_node_1 | f
             8 |                  1 | data_node_2 | f
             8 |                  1 | data_node_3 | f
(3 rows)

SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id |  node_name  
----------+---------------+-------------
        5 |             1 | data_node_1
        5 |             1 | data_node_2
        6 |             2 | data_node_2
        6 |             1 | data_node_3
        7 |             2 | data_node_1
        7 |             3 | data_node_2
(6 rows)

-- Add additional hypertable
CREATE TABLE disttable_2(time timestamptz, device int, temp float);
SELECT * FROM create_distributed_hypertable('disttable_2', 'time', 'device', 2, replication_factor => 2, data_nodes => '{"data_node_1", "data_node_2", "data_node_3"}');
NOTICE:  adding not-null constraint to column "time"
WARNING:  the number of partitions in dimension "device" is too low to make use of all attached data nodes
 hypertable_id | schema_name | table_name  | created 
---------------+-------------+-------------+---------
             9 | public      | disttable_2 | t
(1 row)

CREATE TABLE devices(device int, name text);
SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             8 |                  1 | data_node_1 | f
             8 |                  1 | data_node_2 | f
             8 |                  1 | data_node_3 | f
             9 |                  2 | data_node_1 | f
             9 |                  2 | data_node_2 | f
             9 |                  2 | data_node_3 | f
(6 rows)

-- Block one data node for specific hypertable
SELECT * FROM block_new_chunks('data_node_1', 'disttable');
 block_new_chunks 
------------------
                1
(1 row)

-- Block one data node for all hypertables
SELECT * FROM block_new_chunks('data_node_1');
NOTICE:  new chunks already blocked on data node "data_node_1" for hypertable "disttable"
 block_new_chunks 
------------------
                1
(1 row)

SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             8 |                  1 | data_node_2 | f
             8 |                  1 | data_node_3 | f
             9 |                  2 | data_node_2 | f
             9 |                  2 | data_node_3 | f
             8 |                  1 | data_node_1 | t
             9 |                  2 | data_node_1 | t
(6 rows)

-- insert more data
INSERT INTO disttable VALUES
       ('2019-08-02 10:45', 1, 14.4),
       ('2019-08-15 10:45', 4, 14.9),
       ('2019-08-26 10:45', 8, 17.6);
-- no new chunks on data_node_1
SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id |  node_name  
----------+---------------+-------------
        5 |             1 | data_node_1
        5 |             1 | data_node_2
        6 |             2 | data_node_2
        6 |             1 | data_node_3
        7 |             2 | data_node_1
        7 |             3 | data_node_2
        8 |             4 | data_node_2
        8 |             2 | data_node_3
        9 |             3 | data_node_3
        9 |             5 | data_node_2
       10 |             6 | data_node_2
       10 |             4 | data_node_3
(12 rows)

-- some ERROR cases
\set ON_ERROR_STOP 0
-- Will error due to under-replication
SELECT * FROM block_new_chunks('data_node_2');
ERROR:  blocking new chunks on data node "data_node_2" risks making new data for hypertable "disttable" under-replicated
-- can't block/allow non-existing data node
SELECT * FROM block_new_chunks('data_node_12345', 'disttable');
ERROR:  server "data_node_12345" does not exist
SELECT * FROM allow_new_chunks('data_node_12345', 'disttable');
ERROR:  server "data_node_12345" does not exist
-- NULL data node
SELECT * FROM block_new_chunks(NULL, 'disttable');
ERROR:  invalid node_name: cannot be NULL
SELECT * FROM allow_new_chunks(NULL, 'disttable');
ERROR:  invalid node_name: cannot be NULL
-- can't block/allow on non hypertable
SELECT * FROM block_new_chunks('data_node_1', 'devices');
ERROR:  table "devices" is not a hypertable
SELECT * FROM allow_new_chunks('data_node_1', 'devices');
ERROR:  table "devices" is not a hypertable
\set ON_ERROR_STOP 1
-- Force block all data nodes
SELECT * FROM block_new_chunks('data_node_2', force => true);
WARNING:  new data for hypertable "disttable" will be under-replicated due to blocking new chunks on data node "data_node_2"
WARNING:  new data for hypertable "disttable_2" will be under-replicated due to blocking new chunks on data node "data_node_2"
 block_new_chunks 
------------------
                2
(1 row)

SELECT * FROM block_new_chunks('data_node_1', force => true);
NOTICE:  new chunks already blocked on data node "data_node_1" for hypertable "disttable"
NOTICE:  new chunks already blocked on data node "data_node_1" for hypertable "disttable_2"
 block_new_chunks 
------------------
                0
(1 row)

SELECT * FROM block_new_chunks('data_node_3', force => true);
WARNING:  new data for hypertable "disttable" will be under-replicated due to blocking new chunks on data node "data_node_3"
WARNING:  new data for hypertable "disttable_2" will be under-replicated due to blocking new chunks on data node "data_node_3"
 block_new_chunks 
------------------
                2
(1 row)

-- All data nodes are blocked
SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             8 |                  1 | data_node_1 | t
             9 |                  2 | data_node_1 | t
             8 |                  1 | data_node_2 | t
             9 |                  2 | data_node_2 | t
             8 |                  1 | data_node_3 | t
             9 |                  2 | data_node_3 | t
(6 rows)

\set ON_ERROR_STOP 0
-- insert should fail b/c all data nodes are blocked
INSERT INTO disttable VALUES ('2019-11-02 02:45', 1, 13.3);
ERROR:  no available data nodes (detached or blocked for new chunks) for hypertable "disttable"
\set ON_ERROR_STOP 1
-- unblock data nodes for all hypertables
SELECT * FROM allow_new_chunks('data_node_1');
 allow_new_chunks 
------------------
                2
(1 row)

SELECT * FROM allow_new_chunks('data_node_2');
 allow_new_chunks 
------------------
                2
(1 row)

SELECT * FROM allow_new_chunks('data_node_3');
 allow_new_chunks 
------------------
                2
(1 row)

SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             8 |                  1 | data_node_1 | f
             9 |                  2 | data_node_1 | f
             8 |                  1 | data_node_2 | f
             9 |                  2 | data_node_2 | f
             8 |                  1 | data_node_3 | f
             9 |                  2 | data_node_3 | f
(6 rows)

-- Detach should work b/c disttable_2 has no data
SELECT * FROM detach_data_node('data_node_2', 'disttable_2');
 detach_data_node 
------------------
                1
(1 row)

\set ON_ERROR_STOP 0
-- can't detach non-existing data node
SELECT * FROM detach_data_node('data_node_12345', 'disttable');
ERROR:  server "data_node_12345" does not exist
-- NULL data node
SELECT * FROM detach_data_node(NULL, 'disttable');
ERROR:  invalid node_name: cannot be NULL
-- Can't detach data node_1 b/c it contains data for disttable
SELECT * FROM detach_data_node('data_node_1');
ERROR:  detaching data node "data_node_1" failed because it contains chunks for hypertable "disttable"
-- can't detach already detached data node
SELECT * FROM detach_data_node('data_node_2', 'disttable_2');
ERROR:  data node "data_node_2" is not attached to hypertable "disttable_2"
-- can't detach b/c of replication factor for disttable_2
SELECT * FROM detach_data_node('data_node_3', 'disttable_2');
ERROR:  detaching data node "data_node_3" risks making new data for hypertable "disttable_2" under-replicated
-- can't detach non hypertable
SELECT * FROM detach_data_node('data_node_3', 'devices');
ERROR:  table "devices" is not a hypertable
\set ON_ERROR_STOP 1
-- force detach data node to become under-replicated for new data
SELECT * FROM detach_data_node('data_node_3', 'disttable_2', true);
WARNING:  new data for hypertable "disttable_2" will be under-replicated due to detaching data node "data_node_3"
 detach_data_node 
------------------
                1
(1 row)

SELECT foreign_table_name, foreign_server_name
FROM information_schema.foreign_tables
ORDER BY foreign_table_name;
   foreign_table_name   | foreign_server_name 
------------------------+---------------------
 _hyper_8_10_dist_chunk | data_node_2
 _hyper_8_5_dist_chunk  | data_node_1
 _hyper_8_6_dist_chunk  | data_node_2
 _hyper_8_7_dist_chunk  | data_node_1
 _hyper_8_8_dist_chunk  | data_node_2
 _hyper_8_9_dist_chunk  | data_node_3
(6 rows)

-- force detach data node with data
SELECT * FROM detach_data_node('data_node_3', 'disttable', true);
WARNING:  hypertable "disttable" has under-replicated chunks due to detaching data node "data_node_3"
 detach_data_node 
------------------
                1
(1 row)

-- chunk and hypertable metadata should be deleted as well
SELECT * FROM _timescaledb_catalog.chunk_data_node;
 chunk_id | node_chunk_id |  node_name  
----------+---------------+-------------
        5 |             1 | data_node_1
        5 |             1 | data_node_2
        6 |             2 | data_node_2
        7 |             2 | data_node_1
        7 |             3 | data_node_2
        8 |             4 | data_node_2
        9 |             5 | data_node_2
       10 |             6 | data_node_2
(8 rows)

SELECT * FROM _timescaledb_catalog.hypertable_data_node;
 hypertable_id | node_hypertable_id |  node_name  | block_chunks 
---------------+--------------------+-------------+--------------
             8 |                  1 | data_node_1 | f
             9 |                  2 | data_node_1 | f
             8 |                  1 | data_node_2 | f
(3 rows)

-- detached data_node_3 should not show up any more
SELECT foreign_table_name, foreign_server_name
FROM information_schema.foreign_tables
ORDER BY foreign_table_name;
   foreign_table_name   | foreign_server_name 
------------------------+---------------------
 _hyper_8_10_dist_chunk | data_node_2
 _hyper_8_5_dist_chunk  | data_node_1
 _hyper_8_6_dist_chunk  | data_node_2
 _hyper_8_7_dist_chunk  | data_node_1
 _hyper_8_8_dist_chunk  | data_node_2
 _hyper_8_9_dist_chunk  | data_node_2
(6 rows)

\set ON_ERROR_STOP 0
-- detaching data node with last data replica should ERROR even when forcing
SELECT * FROM detach_data_node('server_2', 'disttable', true);
ERROR:  server "server_2" does not exist
\set ON_ERROR_STOP 1
-- drop all chunks
SELECT * FROM drop_chunks(table_name => 'disttable', older_than => '2200-01-01 00:00'::timestamptz);
                 drop_chunks                  
----------------------------------------------
 _timescaledb_internal._hyper_8_5_dist_chunk
 _timescaledb_internal._hyper_8_6_dist_chunk
 _timescaledb_internal._hyper_8_7_dist_chunk
 _timescaledb_internal._hyper_8_8_dist_chunk
 _timescaledb_internal._hyper_8_9_dist_chunk
 _timescaledb_internal._hyper_8_10_dist_chunk
(6 rows)

SELECT foreign_table_name, foreign_server_name
FROM information_schema.foreign_tables
ORDER BY foreign_table_name;
 foreign_table_name | foreign_server_name 
--------------------+---------------------
(0 rows)

SELECT * FROM detach_data_node('data_node_2', 'disttable', true);
WARNING:  new data for hypertable "disttable" will be under-replicated due to detaching data node "data_node_2"
 detach_data_node 
------------------
                1
(1 row)

-- Let's add more data nodes
SELECT * FROM add_data_node('data_node_4', database => 'data_node_4',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_4"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_4 | localhost | 15432 | data_node_4 | t            | t                | t
(1 row)

SELECT * FROM add_data_node('data_node_5', database => 'data_node_5',
                                     password => :'ROLE_DEFAULT_CLUSTER_USER_PASS',
                                     bootstrap_user => :'ROLE_CLUSTER_SUPERUSER',
                                     bootstrap_password => :'ROLE_CLUSTER_SUPERUSER_PASS');
NOTICE:  adding user mapping for "default_cluster_user" to connect to "data_node_5"
  node_name  |   host    | port  |  database   | node_created | database_created | extension_created 
-------------+-----------+-------+-------------+--------------+------------------+-------------------
 data_node_5 | localhost | 15432 | data_node_5 | t            | t                | t
(1 row)

SET ROLE :ROLE_CLUSTER_SUPERUSER;
-- Create table as super user
CREATE TABLE disttable_3(time timestamptz, device int, temp float);
-- LIMITATION: currently, even superuser require user mappings
CREATE USER MAPPING FOR :ROLE_CLUSTER_SUPERUSER  SERVER data_node_4
OPTIONS (user :'ROLE_CLUSTER_SUPERUSER', password :'ROLE_CLUSTER_SUPERUSER_PASS');
CREATE USER MAPPING FOR :ROLE_CLUSTER_SUPERUSER  SERVER data_node_5
OPTIONS (user :'ROLE_CLUSTER_SUPERUSER', password :'ROLE_CLUSTER_SUPERUSER_PASS');
SELECT * FROM create_distributed_hypertable('disttable_3', 'time', replication_factor => 1, data_nodes => '{"data_node_4", "data_node_5"}');
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name | table_name  | created 
---------------+-------------+-------------+---------
            10 | public      | disttable_3 | t
(1 row)

SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
CREATE TABLE disttable_4(time timestamptz, device int, temp float);
SELECT * FROM create_distributed_hypertable('disttable_4', 'time', replication_factor => 1, data_nodes => '{"data_node_4", "data_node_5"}');
NOTICE:  adding not-null constraint to column "time"
 hypertable_id | schema_name | table_name  | created 
---------------+-------------+-------------+---------
            11 | public      | disttable_4 | t
(1 row)

\set ON_ERROR_STOP 0
-- error due to missing permissions
SELECT * FROM detach_data_node('data_node_4', 'disttable_3');
ERROR:  must be owner of hypertable "disttable_3"
SELECT * FROM block_new_chunks('data_node_4', 'disttable_3');
ERROR:  must be owner of hypertable "disttable_3"
SELECT * FROM allow_new_chunks('data_node_4', 'disttable_3');
ERROR:  must be owner of hypertable "disttable_3"
\set ON_ERROR_STOP 1
-- detach table(s) where user has permissions, otherwise show NOTICE
SELECT * FROM detach_data_node('data_node_4');
NOTICE:  skipping hypertable "disttable_3" due to missing permissions
 detach_data_node 
------------------
                1
(1 row)

-- Cleanup
SELECT * FROM delete_data_node('data_node_1', cascade => true, force =>true);
WARNING:  new data for hypertable "disttable" will be under-replicated due to deleting data node "data_node_1"
WARNING:  new data for hypertable "disttable_2" will be under-replicated due to deleting data node "data_node_1"
NOTICE:  drop cascades to user mapping for default_cluster_user on server data_node_1
 delete_data_node 
------------------
 t
(1 row)

SELECT * FROM delete_data_node('data_node_2', cascade => true, force =>true);
NOTICE:  drop cascades to user mapping for default_cluster_user on server data_node_2
 delete_data_node 
------------------
 t
(1 row)

SELECT * FROM delete_data_node('data_node_3', cascade => true, force =>true);
NOTICE:  drop cascades to user mapping for default_cluster_user on server data_node_3
 delete_data_node 
------------------
 t
(1 row)

\set ON_ERROR_STOP 0
-- Cannot delete a data node which is attached to a table that we don't
-- have owner permissions on
SELECT * FROM delete_data_node('data_node_4', cascade => true, force =>true);
ERROR:  permission denied for hypertable "disttable_3"
SELECT * FROM delete_data_node('data_node_5', cascade => true, force =>true);
ERROR:  permission denied for hypertable "disttable_3"
\set ON_ERROR_STOP 1
SET ROLE :ROLE_CLUSTER_SUPERUSER;
DROP TABLE disttable_3;
-- Now we should be able to delete the data nodes
SELECT * FROM delete_data_node('data_node_4', cascade => true, force =>true);
NOTICE:  drop cascades to 2 other objects
 delete_data_node 
------------------
 t
(1 row)

SELECT * FROM delete_data_node('data_node_5', cascade => true, force =>true);
WARNING:  new data for hypertable "disttable_4" will be under-replicated due to deleting data node "data_node_5"
NOTICE:  drop cascades to 2 other objects
 delete_data_node 
------------------
 t
(1 row)

DROP DATABASE data_node_1;
DROP DATABASE data_node_2;
DROP DATABASE data_node_3;
DROP DATABASE data_node_4;
DROP DATABASE data_node_5;
