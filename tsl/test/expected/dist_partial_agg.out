-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- Need to be super user to create extension and add data nodes
\c :TEST_DBNAME :ROLE_SUPERUSER;
-- Need explicit password for non-super users to connect
ALTER ROLE :ROLE_DEFAULT_CLUSTER_USER CREATEDB PASSWORD 'pass';
GRANT USAGE ON FOREIGN DATA WRAPPER timescaledb_fdw TO :ROLE_DEFAULT_CLUSTER_USER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
-- Cleanup from other potential tests that created these databases
SET client_min_messages TO ERROR;
DROP DATABASE IF EXISTS data_node_1;
DROP DATABASE IF EXISTS data_node_2;
DROP DATABASE IF EXISTS data_node_3;
SET client_min_messages TO NOTICE;
CREATE DATABASE data_node_1;
CREATE DATABASE data_node_2;
CREATE DATABASE data_node_3;
\c data_node_1
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
CREATE TYPE custom_type AS (high int, low int);
\c data_node_2
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
CREATE TYPE custom_type AS (high int, low int);
\c data_node_3
SET client_min_messages TO ERROR;
CREATE EXTENSION timescaledb;
CREATE TYPE custom_type AS (high int, low int);
\c :TEST_DBNAME :ROLE_SUPERUSER;
SET ROLE :ROLE_DEFAULT_CLUSTER_USER;
\set TEST_TABLE 'conditions'
\ir 'include/aggregate_table_create.sql'
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- This file creates a table with a lot of different types to allow a range of aggregate functions.
-- This does not include the creation of a corresponding hypertable, as we may want to vary how that is done.
CREATE TYPE custom_type AS (high int, low int);
CREATE TABLE :TEST_TABLE (
      timec       TIMESTAMPTZ       NOT NULL,
      location    TEXT              NOT NULL,
      region      TEXT              NOT NULL,
      temperature DOUBLE PRECISION  NULL,
      humidity    DOUBLE PRECISION  NULL,
      lowp        double precision NULL,
      highp       double precision null,
      allnull     double precision null,
      highlow     custom_type null,
      bit_int     smallint,
      good_life   boolean
    );
-- Add data nodes using the TimescaleDB data node management API
SELECT * FROM add_data_node('data_node_1', database => 'data_node_1', password => 'pass', if_not_exists => true);
NOTICE:  remote node database "data_node_1" already exists, skipping
  node_name  |   host    | port  |  database   |       username       |    node_username     | created 
-------------+-----------+-------+-------------+----------------------+----------------------+---------
 data_node_1 | localhost | 15432 | data_node_1 | default_cluster_user | default_cluster_user | t
(1 row)

SELECT * FROM add_data_node('data_node_2', database => 'data_node_2', password => 'pass', if_not_exists => true);
NOTICE:  remote node database "data_node_2" already exists, skipping
  node_name  |   host    | port  |  database   |       username       |    node_username     | created 
-------------+-----------+-------+-------------+----------------------+----------------------+---------
 data_node_2 | localhost | 15432 | data_node_2 | default_cluster_user | default_cluster_user | t
(1 row)

SELECT * FROM add_data_node('data_node_3', database => 'data_node_3', password => 'pass', if_not_exists => true);
NOTICE:  remote node database "data_node_3" already exists, skipping
  node_name  |   host    | port  |  database   |       username       |    node_username     | created 
-------------+-----------+-------+-------------+----------------------+----------------------+---------
 data_node_3 | localhost | 15432 | data_node_3 | default_cluster_user | default_cluster_user | t
(1 row)

SELECT table_name FROM create_distributed_hypertable( 'conditions', 'timec', 'location', 3, chunk_time_interval => INTERVAL '1 day');
 table_name 
------------
 conditions
(1 row)

-- We need a lot of data and a lot of chunks to make the planner push down all of the aggregates
\ir 'include/aggregate_table_populate.sql'
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- This files assumes the existence of some table with definition as seen in the aggregate_table.sql file.
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'POR', 'west', generate_series(25, 85, 0.0625), 75, 40, 70, NULL, (1,2)::custom_type, 2, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'SFO', 'west', generate_series(25, 85, 0.0625), 75, 40, 70, NULL, (1,2)::custom_type, 2, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'SAC', 'west', generate_series(25, 85, 0.0625), 75, 40, 70, NULL, (1,2)::custom_type, 2, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'SEA', 'west', generate_series(25, 85, 0.0625), 75, 40, 70, NULL, (1,2)::custom_type, 2, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'TAC', 'west', generate_series(25, 85, 0.0625), 75, 40, 70, NULL, (1,2)::custom_type, 2, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'NYC', 'north-east', generate_series(29, 41, 0.0125), 45, 50, 40, NULL, (3,4)::custom_type, 4, false;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'BOS', 'north-east', generate_series(29, 41, 0.0125), 45, 50, 40, NULL, (3,4)::custom_type, 4, false;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'CHI', 'midwest', generate_series(29, 41, 0.0125), 45, 50, 40, NULL, (3,4)::custom_type, 4, false;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'MIN', 'midwest', generate_series(29, 41, 0.0125), 45, 50, 40, NULL, (3,4)::custom_type, 4, false;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'DET', 'midwest', generate_series(29, 41, 0.0125), 45, 50, 40, NULL, (3,4)::custom_type, 4, false;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'LA', 'west', generate_series(61, 85, 0.025), 55, NULL, 28, NULL, NULL, 8, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'SDG', 'west', generate_series(61, 85, 0.025), 55, NULL, 28, NULL, NULL, 8, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'PHX', 'west', generate_series(61, 85, 0.025), 55, NULL, 28, NULL, NULL, 8, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'DAL', 'south', generate_series(61, 85, 0.025), 55, NULL, 28, NULL, NULL, 8, true;
INSERT INTO :TEST_TABLE
SELECT generate_series('2018-12-01 00:00'::timestamp, '2018-12-04 08:00'::timestamp, '5 minute'), 'AUS', 'south', generate_series(61, 85, 0.025), 55, NULL, 28, NULL, NULL, 8, true;
SET enable_partitionwise_aggregate = ON;
-- Run an explain on the aggregate queries to make sure expected aggregates are being pushed down.
-- Grouping by the paritioning column should result in full aggregate pushdown where possible,
-- while using a non-partitioning column should result in a partial pushdown
\set PREFIX 'EXPLAIN (VERBOSE, COSTS OFF)'
\set GROUPING 'location'
\ir 'include/aggregate_queries.sql'
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- This files assumes the existence of some table with definition as seen in the aggregate_table.sql file.
-- All of these should be able to be pushed down if enabled
:PREFIX SELECT :GROUPING,
   min(allnull) as min_allnull,
   max(temperature) as max_temp,
   sum(temperature)+sum(humidity) as agg_sum_expr,
   avg(humidity),
   ROUND( CAST(stddev(humidity) AS NUMERIC), 1),
   bit_and(bit_int),
   bit_or(bit_int),
   bool_and(good_life),
   every(temperature > 0),
   bool_or(good_life),
   count(*) as count_rows,
   count(temperature) as count_temp,
   count(allnull) as count_zero,
   ROUND( CAST(corr(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(covar_pop(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(covar_samp(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_avgx(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_avgy(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_count(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_intercept(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_r2(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_slope(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_sxx(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_sxy(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_syy(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(stddev(temperature) AS NUMERIC), 1) as stddev_temp,
   ROUND( CAST(stddev_pop(temperature) AS NUMERIC), 1),
   ROUND( CAST(stddev_samp(temperature) AS NUMERIC), 1),
   ROUND( CAST(variance(temperature) AS NUMERIC), 1),
   ROUND( CAST(var_pop(temperature) AS NUMERIC), 1),
   ROUND( CAST(var_samp(temperature) AS NUMERIC), 1),
   last(temperature, timec) as last_temp,
   histogram(temperature, 0, 100, 1)
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: conditions.location, (min(conditions.allnull)), (max(conditions.temperature)), ((sum(conditions.temperature) + sum(conditions.humidity))), (avg(conditions.humidity)), (round((stddev(conditions.humidity))::numeric, 1)), (bit_and(conditions.bit_int)), (bit_or(conditions.bit_int)), (bool_and(conditions.good_life)), (every((conditions.temperature > '0'::double precision))), (bool_or(conditions.good_life)), (count(*)), (count(conditions.temperature)), (count(conditions.allnull)), (round((corr(conditions.temperature, conditions.humidity))::numeric, 1)), (round((covar_pop(conditions.temperature, conditions.humidity))::numeric, 1)), (round((covar_samp(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_avgx(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_avgy(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_count(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_intercept(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_r2(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_slope(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_sxx(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_sxy(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_syy(conditions.temperature, conditions.humidity))::numeric, 1)), (round((stddev(conditions.temperature))::numeric, 1)), (round((stddev_pop(conditions.temperature))::numeric, 1)), (round((stddev_samp(conditions.temperature))::numeric, 1)), (round((variance(conditions.temperature))::numeric, 1)), (round((var_pop(conditions.temperature))::numeric, 1)), (round((var_samp(conditions.temperature))::numeric, 1)), (last(conditions.temperature, conditions.timec)), (histogram(conditions.temperature, '0'::double precision, '100'::double precision, 1))
   Sort Key: conditions.location
   ->  Append
         ->  Custom Scan (DataNodeScan)
               Output: conditions.location, (min(conditions.allnull)), (max(conditions.temperature)), ((sum(conditions.temperature) + sum(conditions.humidity))), (avg(conditions.humidity)), (round((stddev(conditions.humidity))::numeric, 1)), (bit_and(conditions.bit_int)), (bit_or(conditions.bit_int)), (bool_and(conditions.good_life)), (every((conditions.temperature > '0'::double precision))), (bool_or(conditions.good_life)), (count(*)), (count(conditions.temperature)), (count(conditions.allnull)), (round((corr(conditions.temperature, conditions.humidity))::numeric, 1)), (round((covar_pop(conditions.temperature, conditions.humidity))::numeric, 1)), (round((covar_samp(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_avgx(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_avgy(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_count(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_intercept(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_r2(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_slope(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_sxx(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_sxy(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_syy(conditions.temperature, conditions.humidity))::numeric, 1)), (round((stddev(conditions.temperature))::numeric, 1)), (round((stddev_pop(conditions.temperature))::numeric, 1)), (round((stddev_samp(conditions.temperature))::numeric, 1)), (round((variance(conditions.temperature))::numeric, 1)), (round((var_pop(conditions.temperature))::numeric, 1)), (round((var_samp(conditions.temperature))::numeric, 1)), (last(conditions.temperature, conditions.timec)), (histogram(conditions.temperature, '0'::double precision, '100'::double precision, 1))
               Relations: Aggregate on (public.conditions)
               Data node: data_node_1
               Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
               Remote SQL: SELECT location, min(allnull), max(temperature), (sum(temperature) + sum(humidity)), avg(humidity), round(stddev(humidity)::numeric, 1), bit_and(bit_int), bit_or(bit_int), bool_and(good_life), every((temperature > 0::double precision)), bool_or(good_life), count(*), count(temperature), count(allnull), round(corr(temperature, humidity)::numeric, 1), round(covar_pop(temperature, humidity)::numeric, 1), round(covar_samp(temperature, humidity)::numeric, 1), round(regr_avgx(temperature, humidity)::numeric, 1), round(regr_avgy(temperature, humidity)::numeric, 1), round(regr_count(temperature, humidity)::numeric, 1), round(regr_intercept(temperature, humidity)::numeric, 1), round(regr_r2(temperature, humidity)::numeric, 1), round(regr_slope(temperature, humidity)::numeric, 1), round(regr_sxx(temperature, humidity)::numeric, 1), round(regr_sxy(temperature, humidity)::numeric, 1), round(regr_syy(temperature, humidity)::numeric, 1), round(stddev(temperature)::numeric, 1), round(stddev_pop(temperature)::numeric, 1), round(stddev_samp(temperature)::numeric, 1), round(variance(temperature)::numeric, 1), round(var_pop(temperature)::numeric, 1), round(var_samp(temperature)::numeric, 1), public.last(temperature, timec), public.histogram(temperature, 0::double precision, 100::double precision, 1) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1
         ->  Custom Scan (DataNodeScan)
               Output: conditions_1.location, (min(conditions_1.allnull)), (max(conditions_1.temperature)), ((sum(conditions_1.temperature) + sum(conditions_1.humidity))), (avg(conditions_1.humidity)), (round((stddev(conditions_1.humidity))::numeric, 1)), (bit_and(conditions_1.bit_int)), (bit_or(conditions_1.bit_int)), (bool_and(conditions_1.good_life)), (every((conditions_1.temperature > '0'::double precision))), (bool_or(conditions_1.good_life)), (count(*)), (count(conditions_1.temperature)), (count(conditions_1.allnull)), (round((corr(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((covar_pop(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((covar_samp(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((regr_avgx(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((regr_avgy(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((regr_count(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((regr_intercept(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((regr_r2(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((regr_slope(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((regr_sxx(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((regr_sxy(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((regr_syy(conditions_1.temperature, conditions_1.humidity))::numeric, 1)), (round((stddev(conditions_1.temperature))::numeric, 1)), (round((stddev_pop(conditions_1.temperature))::numeric, 1)), (round((stddev_samp(conditions_1.temperature))::numeric, 1)), (round((variance(conditions_1.temperature))::numeric, 1)), (round((var_pop(conditions_1.temperature))::numeric, 1)), (round((var_samp(conditions_1.temperature))::numeric, 1)), (last(conditions_1.temperature, conditions_1.timec)), (histogram(conditions_1.temperature, '0'::double precision, '100'::double precision, 1))
               Relations: Aggregate on (public.conditions)
               Data node: data_node_2
               Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
               Remote SQL: SELECT location, min(allnull), max(temperature), (sum(temperature) + sum(humidity)), avg(humidity), round(stddev(humidity)::numeric, 1), bit_and(bit_int), bit_or(bit_int), bool_and(good_life), every((temperature > 0::double precision)), bool_or(good_life), count(*), count(temperature), count(allnull), round(corr(temperature, humidity)::numeric, 1), round(covar_pop(temperature, humidity)::numeric, 1), round(covar_samp(temperature, humidity)::numeric, 1), round(regr_avgx(temperature, humidity)::numeric, 1), round(regr_avgy(temperature, humidity)::numeric, 1), round(regr_count(temperature, humidity)::numeric, 1), round(regr_intercept(temperature, humidity)::numeric, 1), round(regr_r2(temperature, humidity)::numeric, 1), round(regr_slope(temperature, humidity)::numeric, 1), round(regr_sxx(temperature, humidity)::numeric, 1), round(regr_sxy(temperature, humidity)::numeric, 1), round(regr_syy(temperature, humidity)::numeric, 1), round(stddev(temperature)::numeric, 1), round(stddev_pop(temperature)::numeric, 1), round(stddev_samp(temperature)::numeric, 1), round(variance(temperature)::numeric, 1), round(var_pop(temperature)::numeric, 1), round(var_samp(temperature)::numeric, 1), public.last(temperature, timec), public.histogram(temperature, 0::double precision, 100::double precision, 1) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1
         ->  Custom Scan (DataNodeScan)
               Output: conditions_2.location, (min(conditions_2.allnull)), (max(conditions_2.temperature)), ((sum(conditions_2.temperature) + sum(conditions_2.humidity))), (avg(conditions_2.humidity)), (round((stddev(conditions_2.humidity))::numeric, 1)), (bit_and(conditions_2.bit_int)), (bit_or(conditions_2.bit_int)), (bool_and(conditions_2.good_life)), (every((conditions_2.temperature > '0'::double precision))), (bool_or(conditions_2.good_life)), (count(*)), (count(conditions_2.temperature)), (count(conditions_2.allnull)), (round((corr(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((covar_pop(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((covar_samp(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((regr_avgx(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((regr_avgy(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((regr_count(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((regr_intercept(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((regr_r2(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((regr_slope(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((regr_sxx(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((regr_sxy(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((regr_syy(conditions_2.temperature, conditions_2.humidity))::numeric, 1)), (round((stddev(conditions_2.temperature))::numeric, 1)), (round((stddev_pop(conditions_2.temperature))::numeric, 1)), (round((stddev_samp(conditions_2.temperature))::numeric, 1)), (round((variance(conditions_2.temperature))::numeric, 1)), (round((var_pop(conditions_2.temperature))::numeric, 1)), (round((var_samp(conditions_2.temperature))::numeric, 1)), (last(conditions_2.temperature, conditions_2.timec)), (histogram(conditions_2.temperature, '0'::double precision, '100'::double precision, 1))
               Relations: Aggregate on (public.conditions)
               Data node: data_node_3
               Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
               Remote SQL: SELECT location, min(allnull), max(temperature), (sum(temperature) + sum(humidity)), avg(humidity), round(stddev(humidity)::numeric, 1), bit_and(bit_int), bit_or(bit_int), bool_and(good_life), every((temperature > 0::double precision)), bool_or(good_life), count(*), count(temperature), count(allnull), round(corr(temperature, humidity)::numeric, 1), round(covar_pop(temperature, humidity)::numeric, 1), round(covar_samp(temperature, humidity)::numeric, 1), round(regr_avgx(temperature, humidity)::numeric, 1), round(regr_avgy(temperature, humidity)::numeric, 1), round(regr_count(temperature, humidity)::numeric, 1), round(regr_intercept(temperature, humidity)::numeric, 1), round(regr_r2(temperature, humidity)::numeric, 1), round(regr_slope(temperature, humidity)::numeric, 1), round(regr_sxx(temperature, humidity)::numeric, 1), round(regr_sxy(temperature, humidity)::numeric, 1), round(regr_syy(temperature, humidity)::numeric, 1), round(stddev(temperature)::numeric, 1), round(stddev_pop(temperature)::numeric, 1), round(stddev_samp(temperature)::numeric, 1), round(variance(temperature)::numeric, 1), round(var_pop(temperature)::numeric, 1), round(var_samp(temperature)::numeric, 1), public.last(temperature, timec), public.histogram(temperature, 0::double precision, 100::double precision, 1) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1
(22 rows)

-- Aggregates on custom types are not yet pushed down
:PREFIX SELECT :GROUPING,
   last(highlow, timec) as last_hl,
   first(highlow, timec) as first_hl
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Append
   Sort Key: conditions.location
   ->  GroupAggregate
         Output: conditions.location, last(conditions.highlow, conditions.timec), first(conditions.highlow, conditions.timec)
         Group Key: conditions.location
         ->  Custom Scan (DataNodeScan) on public.conditions
               Output: conditions.location, conditions.highlow, conditions.timec
               Data node: data_node_1
               Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
               Remote SQL: SELECT timec, location, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
   ->  GroupAggregate
         Output: conditions_1.location, last(conditions_1.highlow, conditions_1.timec), first(conditions_1.highlow, conditions_1.timec)
         Group Key: conditions_1.location
         ->  Custom Scan (DataNodeScan) on public.conditions conditions_1
               Output: conditions_1.location, conditions_1.highlow, conditions_1.timec
               Data node: data_node_2
               Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
               Remote SQL: SELECT timec, location, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
   ->  GroupAggregate
         Output: conditions_2.location, last(conditions_2.highlow, conditions_2.timec), first(conditions_2.highlow, conditions_2.timec)
         Group Key: conditions_2.location
         ->  Custom Scan (DataNodeScan) on public.conditions conditions_2
               Output: conditions_2.location, conditions_2.highlow, conditions_2.timec
               Data node: data_node_3
               Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
               Remote SQL: SELECT timec, location, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
(26 rows)

-- Mix of aggregates that push down and those that don't
:PREFIX SELECT :GROUPING,
   min(allnull) as min_allnull,
   max(temperature) as max_temp,
   sum(temperature)+sum(humidity) as agg_sum_expr,
   avg(humidity),
   ROUND( CAST(stddev(humidity) AS NUMERIC), 1),
   bit_and(bit_int),
   bit_or(bit_int),
   bool_and(good_life),
   every(temperature > 0),
   bool_or(good_life),
   first(highlow, timec) as first_hl
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                                                                                                                                                                        QUERY PLAN                                                                                                                                                                                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Append
   Sort Key: conditions.location
   ->  GroupAggregate
         Output: conditions.location, min(conditions.allnull), max(conditions.temperature), (sum(conditions.temperature) + sum(conditions.humidity)), avg(conditions.humidity), round((stddev(conditions.humidity))::numeric, 1), bit_and(conditions.bit_int), bit_or(conditions.bit_int), bool_and(conditions.good_life), every((conditions.temperature > '0'::double precision)), bool_or(conditions.good_life), first(conditions.highlow, conditions.timec)
         Group Key: conditions.location
         ->  Custom Scan (DataNodeScan) on public.conditions
               Output: conditions.location, conditions.allnull, conditions.temperature, conditions.humidity, conditions.bit_int, conditions.good_life, conditions.highlow, conditions.timec
               Data node: data_node_1
               Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
               Remote SQL: SELECT timec, location, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
   ->  GroupAggregate
         Output: conditions_1.location, min(conditions_1.allnull), max(conditions_1.temperature), (sum(conditions_1.temperature) + sum(conditions_1.humidity)), avg(conditions_1.humidity), round((stddev(conditions_1.humidity))::numeric, 1), bit_and(conditions_1.bit_int), bit_or(conditions_1.bit_int), bool_and(conditions_1.good_life), every((conditions_1.temperature > '0'::double precision)), bool_or(conditions_1.good_life), first(conditions_1.highlow, conditions_1.timec)
         Group Key: conditions_1.location
         ->  Custom Scan (DataNodeScan) on public.conditions conditions_1
               Output: conditions_1.location, conditions_1.allnull, conditions_1.temperature, conditions_1.humidity, conditions_1.bit_int, conditions_1.good_life, conditions_1.highlow, conditions_1.timec
               Data node: data_node_2
               Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
               Remote SQL: SELECT timec, location, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
   ->  GroupAggregate
         Output: conditions_2.location, min(conditions_2.allnull), max(conditions_2.temperature), (sum(conditions_2.temperature) + sum(conditions_2.humidity)), avg(conditions_2.humidity), round((stddev(conditions_2.humidity))::numeric, 1), bit_and(conditions_2.bit_int), bit_or(conditions_2.bit_int), bool_and(conditions_2.good_life), every((conditions_2.temperature > '0'::double precision)), bool_or(conditions_2.good_life), first(conditions_2.highlow, conditions_2.timec)
         Group Key: conditions_2.location
         ->  Custom Scan (DataNodeScan) on public.conditions conditions_2
               Output: conditions_2.location, conditions_2.allnull, conditions_2.temperature, conditions_2.humidity, conditions_2.bit_int, conditions_2.good_life, conditions_2.highlow, conditions_2.timec
               Data node: data_node_3
               Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
               Remote SQL: SELECT timec, location, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) ORDER BY location ASC NULLS LAST
(26 rows)

\set GROUPING 'region'
\ir 'include/aggregate_queries.sql'
-- This file and its contents are licensed under the Timescale License.
-- Please see the included NOTICE for copyright information and
-- LICENSE-TIMESCALE for a copy of the license.
-- This files assumes the existence of some table with definition as seen in the aggregate_table.sql file.
-- All of these should be able to be pushed down if enabled
:PREFIX SELECT :GROUPING,
   min(allnull) as min_allnull,
   max(temperature) as max_temp,
   sum(temperature)+sum(humidity) as agg_sum_expr,
   avg(humidity),
   ROUND( CAST(stddev(humidity) AS NUMERIC), 1),
   bit_and(bit_int),
   bit_or(bit_int),
   bool_and(good_life),
   every(temperature > 0),
   bool_or(good_life),
   count(*) as count_rows,
   count(temperature) as count_temp,
   count(allnull) as count_zero,
   ROUND( CAST(corr(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(covar_pop(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(covar_samp(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_avgx(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_avgy(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_count(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_intercept(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_r2(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_slope(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_sxx(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_sxy(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(regr_syy(temperature, humidity) AS NUMERIC), 1),
   ROUND( CAST(stddev(temperature) AS NUMERIC), 1) as stddev_temp,
   ROUND( CAST(stddev_pop(temperature) AS NUMERIC), 1),
   ROUND( CAST(stddev_samp(temperature) AS NUMERIC), 1),
   ROUND( CAST(variance(temperature) AS NUMERIC), 1),
   ROUND( CAST(var_pop(temperature) AS NUMERIC), 1),
   ROUND( CAST(var_samp(temperature) AS NUMERIC), 1),
   last(temperature, timec) as last_temp,
   histogram(temperature, 0, 100, 1)
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: conditions.region, (min(conditions.allnull)), (max(conditions.temperature)), ((sum(conditions.temperature) + sum(conditions.humidity))), (avg(conditions.humidity)), (round((stddev(conditions.humidity))::numeric, 1)), (bit_and(conditions.bit_int)), (bit_or(conditions.bit_int)), (bool_and(conditions.good_life)), (every((conditions.temperature > '0'::double precision))), (bool_or(conditions.good_life)), (count(*)), (count(conditions.temperature)), (count(conditions.allnull)), (round((corr(conditions.temperature, conditions.humidity))::numeric, 1)), (round((covar_pop(conditions.temperature, conditions.humidity))::numeric, 1)), (round((covar_samp(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_avgx(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_avgy(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_count(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_intercept(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_r2(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_slope(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_sxx(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_sxy(conditions.temperature, conditions.humidity))::numeric, 1)), (round((regr_syy(conditions.temperature, conditions.humidity))::numeric, 1)), (round((stddev(conditions.temperature))::numeric, 1)), (round((stddev_pop(conditions.temperature))::numeric, 1)), (round((stddev_samp(conditions.temperature))::numeric, 1)), (round((variance(conditions.temperature))::numeric, 1)), (round((var_pop(conditions.temperature))::numeric, 1)), (round((var_samp(conditions.temperature))::numeric, 1)), (last(conditions.temperature, conditions.timec)), (histogram(conditions.temperature, '0'::double precision, '100'::double precision, 1))
   Sort Key: conditions.region
   ->  Finalize HashAggregate
         Output: conditions.region, min(conditions.allnull), max(conditions.temperature), (sum(conditions.temperature) + sum(conditions.humidity)), avg(conditions.humidity), round((stddev(conditions.humidity))::numeric, 1), bit_and(conditions.bit_int), bit_or(conditions.bit_int), bool_and(conditions.good_life), every((conditions.temperature > '0'::double precision)), bool_or(conditions.good_life), count(*), count(conditions.temperature), count(conditions.allnull), round((corr(conditions.temperature, conditions.humidity))::numeric, 1), round((covar_pop(conditions.temperature, conditions.humidity))::numeric, 1), round((covar_samp(conditions.temperature, conditions.humidity))::numeric, 1), round((regr_avgx(conditions.temperature, conditions.humidity))::numeric, 1), round((regr_avgy(conditions.temperature, conditions.humidity))::numeric, 1), round((regr_count(conditions.temperature, conditions.humidity))::numeric, 1), round((regr_intercept(conditions.temperature, conditions.humidity))::numeric, 1), round((regr_r2(conditions.temperature, conditions.humidity))::numeric, 1), round((regr_slope(conditions.temperature, conditions.humidity))::numeric, 1), round((regr_sxx(conditions.temperature, conditions.humidity))::numeric, 1), round((regr_sxy(conditions.temperature, conditions.humidity))::numeric, 1), round((regr_syy(conditions.temperature, conditions.humidity))::numeric, 1), round((stddev(conditions.temperature))::numeric, 1), round((stddev_pop(conditions.temperature))::numeric, 1), round((stddev_samp(conditions.temperature))::numeric, 1), round((variance(conditions.temperature))::numeric, 1), round((var_pop(conditions.temperature))::numeric, 1), round((var_samp(conditions.temperature))::numeric, 1), last(conditions.temperature, conditions.timec), histogram(conditions.temperature, '0'::double precision, '100'::double precision, 1)
         Group Key: conditions.region
         ->  Append
               ->  Custom Scan (DataNodeScan)
                     Output: conditions.region, (PARTIAL min(conditions.allnull)), (PARTIAL max(conditions.temperature)), (PARTIAL sum(conditions.temperature)), (PARTIAL sum(conditions.humidity)), (PARTIAL avg(conditions.humidity)), (PARTIAL stddev(conditions.humidity)), (PARTIAL bit_and(conditions.bit_int)), (PARTIAL bit_or(conditions.bit_int)), (PARTIAL bool_and(conditions.good_life)), (PARTIAL every((conditions.temperature > '0'::double precision))), (PARTIAL bool_or(conditions.good_life)), (PARTIAL count(*)), (PARTIAL count(conditions.temperature)), (PARTIAL count(conditions.allnull)), (PARTIAL corr(conditions.temperature, conditions.humidity)), (PARTIAL covar_pop(conditions.temperature, conditions.humidity)), (PARTIAL covar_samp(conditions.temperature, conditions.humidity)), (PARTIAL regr_avgx(conditions.temperature, conditions.humidity)), (PARTIAL regr_avgy(conditions.temperature, conditions.humidity)), (PARTIAL regr_count(conditions.temperature, conditions.humidity)), (PARTIAL regr_intercept(conditions.temperature, conditions.humidity)), (PARTIAL regr_r2(conditions.temperature, conditions.humidity)), (PARTIAL regr_slope(conditions.temperature, conditions.humidity)), (PARTIAL regr_sxx(conditions.temperature, conditions.humidity)), (PARTIAL regr_sxy(conditions.temperature, conditions.humidity)), (PARTIAL regr_syy(conditions.temperature, conditions.humidity)), (PARTIAL stddev(conditions.temperature)), (PARTIAL stddev_pop(conditions.temperature)), (PARTIAL stddev_samp(conditions.temperature)), (PARTIAL variance(conditions.temperature)), (PARTIAL var_pop(conditions.temperature)), (PARTIAL var_samp(conditions.temperature)), (PARTIAL last(conditions.temperature, conditions.timec)), (PARTIAL histogram(conditions.temperature, '0'::double precision, '100'::double precision, 1))
                     Relations: Aggregate on (public.conditions)
                     Data node: data_node_1
                     Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
                     Remote SQL: SELECT region, _timescaledb_internal.partialize_agg(min(allnull)), _timescaledb_internal.partialize_agg(max(temperature)), _timescaledb_internal.partialize_agg(sum(temperature)), _timescaledb_internal.partialize_agg(sum(humidity)), _timescaledb_internal.partialize_agg(avg(humidity)), _timescaledb_internal.partialize_agg(stddev(humidity)), _timescaledb_internal.partialize_agg(bit_and(bit_int)), _timescaledb_internal.partialize_agg(bit_or(bit_int)), _timescaledb_internal.partialize_agg(bool_and(good_life)), _timescaledb_internal.partialize_agg(every((temperature > 0::double precision))), _timescaledb_internal.partialize_agg(bool_or(good_life)), _timescaledb_internal.partialize_agg(count(*)), _timescaledb_internal.partialize_agg(count(temperature)), _timescaledb_internal.partialize_agg(count(allnull)), _timescaledb_internal.partialize_agg(corr(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_pop(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_samp(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_count(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_intercept(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_r2(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_slope(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_syy(temperature, humidity)), _timescaledb_internal.partialize_agg(stddev(temperature)), _timescaledb_internal.partialize_agg(stddev_pop(temperature)), _timescaledb_internal.partialize_agg(stddev_samp(temperature)), _timescaledb_internal.partialize_agg(variance(temperature)), _timescaledb_internal.partialize_agg(var_pop(temperature)), _timescaledb_internal.partialize_agg(var_samp(temperature)), _timescaledb_internal.partialize_agg(public.last(temperature, timec)), _timescaledb_internal.partialize_agg(public.histogram(temperature, 0::double precision, 100::double precision, 1)) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1
               ->  Custom Scan (DataNodeScan)
                     Output: conditions_1.region, (PARTIAL min(conditions_1.allnull)), (PARTIAL max(conditions_1.temperature)), (PARTIAL sum(conditions_1.temperature)), (PARTIAL sum(conditions_1.humidity)), (PARTIAL avg(conditions_1.humidity)), (PARTIAL stddev(conditions_1.humidity)), (PARTIAL bit_and(conditions_1.bit_int)), (PARTIAL bit_or(conditions_1.bit_int)), (PARTIAL bool_and(conditions_1.good_life)), (PARTIAL every((conditions_1.temperature > '0'::double precision))), (PARTIAL bool_or(conditions_1.good_life)), (PARTIAL count(*)), (PARTIAL count(conditions_1.temperature)), (PARTIAL count(conditions_1.allnull)), (PARTIAL corr(conditions_1.temperature, conditions_1.humidity)), (PARTIAL covar_pop(conditions_1.temperature, conditions_1.humidity)), (PARTIAL covar_samp(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_avgx(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_avgy(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_count(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_intercept(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_r2(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_slope(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_sxx(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_sxy(conditions_1.temperature, conditions_1.humidity)), (PARTIAL regr_syy(conditions_1.temperature, conditions_1.humidity)), (PARTIAL stddev(conditions_1.temperature)), (PARTIAL stddev_pop(conditions_1.temperature)), (PARTIAL stddev_samp(conditions_1.temperature)), (PARTIAL variance(conditions_1.temperature)), (PARTIAL var_pop(conditions_1.temperature)), (PARTIAL var_samp(conditions_1.temperature)), (PARTIAL last(conditions_1.temperature, conditions_1.timec)), (PARTIAL histogram(conditions_1.temperature, '0'::double precision, '100'::double precision, 1))
                     Relations: Aggregate on (public.conditions)
                     Data node: data_node_2
                     Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
                     Remote SQL: SELECT region, _timescaledb_internal.partialize_agg(min(allnull)), _timescaledb_internal.partialize_agg(max(temperature)), _timescaledb_internal.partialize_agg(sum(temperature)), _timescaledb_internal.partialize_agg(sum(humidity)), _timescaledb_internal.partialize_agg(avg(humidity)), _timescaledb_internal.partialize_agg(stddev(humidity)), _timescaledb_internal.partialize_agg(bit_and(bit_int)), _timescaledb_internal.partialize_agg(bit_or(bit_int)), _timescaledb_internal.partialize_agg(bool_and(good_life)), _timescaledb_internal.partialize_agg(every((temperature > 0::double precision))), _timescaledb_internal.partialize_agg(bool_or(good_life)), _timescaledb_internal.partialize_agg(count(*)), _timescaledb_internal.partialize_agg(count(temperature)), _timescaledb_internal.partialize_agg(count(allnull)), _timescaledb_internal.partialize_agg(corr(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_pop(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_samp(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_count(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_intercept(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_r2(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_slope(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_syy(temperature, humidity)), _timescaledb_internal.partialize_agg(stddev(temperature)), _timescaledb_internal.partialize_agg(stddev_pop(temperature)), _timescaledb_internal.partialize_agg(stddev_samp(temperature)), _timescaledb_internal.partialize_agg(variance(temperature)), _timescaledb_internal.partialize_agg(var_pop(temperature)), _timescaledb_internal.partialize_agg(var_samp(temperature)), _timescaledb_internal.partialize_agg(public.last(temperature, timec)), _timescaledb_internal.partialize_agg(public.histogram(temperature, 0::double precision, 100::double precision, 1)) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1
               ->  Custom Scan (DataNodeScan)
                     Output: conditions_2.region, (PARTIAL min(conditions_2.allnull)), (PARTIAL max(conditions_2.temperature)), (PARTIAL sum(conditions_2.temperature)), (PARTIAL sum(conditions_2.humidity)), (PARTIAL avg(conditions_2.humidity)), (PARTIAL stddev(conditions_2.humidity)), (PARTIAL bit_and(conditions_2.bit_int)), (PARTIAL bit_or(conditions_2.bit_int)), (PARTIAL bool_and(conditions_2.good_life)), (PARTIAL every((conditions_2.temperature > '0'::double precision))), (PARTIAL bool_or(conditions_2.good_life)), (PARTIAL count(*)), (PARTIAL count(conditions_2.temperature)), (PARTIAL count(conditions_2.allnull)), (PARTIAL corr(conditions_2.temperature, conditions_2.humidity)), (PARTIAL covar_pop(conditions_2.temperature, conditions_2.humidity)), (PARTIAL covar_samp(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_avgx(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_avgy(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_count(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_intercept(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_r2(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_slope(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_sxx(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_sxy(conditions_2.temperature, conditions_2.humidity)), (PARTIAL regr_syy(conditions_2.temperature, conditions_2.humidity)), (PARTIAL stddev(conditions_2.temperature)), (PARTIAL stddev_pop(conditions_2.temperature)), (PARTIAL stddev_samp(conditions_2.temperature)), (PARTIAL variance(conditions_2.temperature)), (PARTIAL var_pop(conditions_2.temperature)), (PARTIAL var_samp(conditions_2.temperature)), (PARTIAL last(conditions_2.temperature, conditions_2.timec)), (PARTIAL histogram(conditions_2.temperature, '0'::double precision, '100'::double precision, 1))
                     Relations: Aggregate on (public.conditions)
                     Data node: data_node_3
                     Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
                     Remote SQL: SELECT region, _timescaledb_internal.partialize_agg(min(allnull)), _timescaledb_internal.partialize_agg(max(temperature)), _timescaledb_internal.partialize_agg(sum(temperature)), _timescaledb_internal.partialize_agg(sum(humidity)), _timescaledb_internal.partialize_agg(avg(humidity)), _timescaledb_internal.partialize_agg(stddev(humidity)), _timescaledb_internal.partialize_agg(bit_and(bit_int)), _timescaledb_internal.partialize_agg(bit_or(bit_int)), _timescaledb_internal.partialize_agg(bool_and(good_life)), _timescaledb_internal.partialize_agg(every((temperature > 0::double precision))), _timescaledb_internal.partialize_agg(bool_or(good_life)), _timescaledb_internal.partialize_agg(count(*)), _timescaledb_internal.partialize_agg(count(temperature)), _timescaledb_internal.partialize_agg(count(allnull)), _timescaledb_internal.partialize_agg(corr(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_pop(temperature, humidity)), _timescaledb_internal.partialize_agg(covar_samp(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_avgy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_count(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_intercept(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_r2(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_slope(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxx(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_sxy(temperature, humidity)), _timescaledb_internal.partialize_agg(regr_syy(temperature, humidity)), _timescaledb_internal.partialize_agg(stddev(temperature)), _timescaledb_internal.partialize_agg(stddev_pop(temperature)), _timescaledb_internal.partialize_agg(stddev_samp(temperature)), _timescaledb_internal.partialize_agg(variance(temperature)), _timescaledb_internal.partialize_agg(var_pop(temperature)), _timescaledb_internal.partialize_agg(var_samp(temperature)), _timescaledb_internal.partialize_agg(public.last(temperature, timec)), _timescaledb_internal.partialize_agg(public.histogram(temperature, 0::double precision, 100::double precision, 1)) FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4]) GROUP BY 1
(25 rows)

-- Aggregates on custom types are not yet pushed down
:PREFIX SELECT :GROUPING,
   last(highlow, timec) as last_hl,
   first(highlow, timec) as first_hl
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: conditions.region, (last(conditions.highlow, conditions.timec)), (first(conditions.highlow, conditions.timec))
   Sort Key: conditions.region
   ->  Finalize HashAggregate
         Output: conditions.region, last(conditions.highlow, conditions.timec), first(conditions.highlow, conditions.timec)
         Group Key: conditions.region
         ->  Append
               ->  Partial HashAggregate
                     Output: conditions.region, PARTIAL last(conditions.highlow, conditions.timec), PARTIAL first(conditions.highlow, conditions.timec)
                     Group Key: conditions.region
                     ->  Custom Scan (DataNodeScan) on public.conditions
                           Output: conditions.region, conditions.highlow, conditions.timec
                           Data node: data_node_1
                           Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
                           Remote SQL: SELECT timec, region, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4])
               ->  Partial HashAggregate
                     Output: conditions_1.region, PARTIAL last(conditions_1.highlow, conditions_1.timec), PARTIAL first(conditions_1.highlow, conditions_1.timec)
                     Group Key: conditions_1.region
                     ->  Custom Scan (DataNodeScan) on public.conditions conditions_1
                           Output: conditions_1.region, conditions_1.highlow, conditions_1.timec
                           Data node: data_node_2
                           Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
                           Remote SQL: SELECT timec, region, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4])
               ->  Partial HashAggregate
                     Output: conditions_2.region, PARTIAL last(conditions_2.highlow, conditions_2.timec), PARTIAL first(conditions_2.highlow, conditions_2.timec)
                     Group Key: conditions_2.region
                     ->  Custom Scan (DataNodeScan) on public.conditions conditions_2
                           Output: conditions_2.region, conditions_2.highlow, conditions_2.timec
                           Data node: data_node_3
                           Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
                           Remote SQL: SELECT timec, region, highlow FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4])
(31 rows)

-- Mix of aggregates that push down and those that don't
:PREFIX SELECT :GROUPING,
   min(allnull) as min_allnull,
   max(temperature) as max_temp,
   sum(temperature)+sum(humidity) as agg_sum_expr,
   avg(humidity),
   ROUND( CAST(stddev(humidity) AS NUMERIC), 1),
   bit_and(bit_int),
   bit_or(bit_int),
   bool_and(good_life),
   every(temperature > 0),
   bool_or(good_life),
   first(highlow, timec) as first_hl
  FROM :TEST_TABLE
  GROUP BY :GROUPING
  ORDER BY :GROUPING;
                                                                                                                                                                                                                                                                                 QUERY PLAN                                                                                                                                                                                                                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: conditions.region, (min(conditions.allnull)), (max(conditions.temperature)), ((sum(conditions.temperature) + sum(conditions.humidity))), (avg(conditions.humidity)), (round((stddev(conditions.humidity))::numeric, 1)), (bit_and(conditions.bit_int)), (bit_or(conditions.bit_int)), (bool_and(conditions.good_life)), (every((conditions.temperature > '0'::double precision))), (bool_or(conditions.good_life)), (first(conditions.highlow, conditions.timec))
   Sort Key: conditions.region
   ->  Finalize HashAggregate
         Output: conditions.region, min(conditions.allnull), max(conditions.temperature), (sum(conditions.temperature) + sum(conditions.humidity)), avg(conditions.humidity), round((stddev(conditions.humidity))::numeric, 1), bit_and(conditions.bit_int), bit_or(conditions.bit_int), bool_and(conditions.good_life), every((conditions.temperature > '0'::double precision)), bool_or(conditions.good_life), first(conditions.highlow, conditions.timec)
         Group Key: conditions.region
         ->  Append
               ->  Partial HashAggregate
                     Output: conditions.region, PARTIAL min(conditions.allnull), PARTIAL max(conditions.temperature), PARTIAL sum(conditions.temperature), PARTIAL sum(conditions.humidity), PARTIAL avg(conditions.humidity), PARTIAL stddev(conditions.humidity), PARTIAL bit_and(conditions.bit_int), PARTIAL bit_or(conditions.bit_int), PARTIAL bool_and(conditions.good_life), PARTIAL every((conditions.temperature > '0'::double precision)), PARTIAL bool_or(conditions.good_life), PARTIAL first(conditions.highlow, conditions.timec)
                     Group Key: conditions.region
                     ->  Custom Scan (DataNodeScan) on public.conditions
                           Output: conditions.region, conditions.allnull, conditions.temperature, conditions.humidity, conditions.bit_int, conditions.good_life, conditions.highlow, conditions.timec
                           Data node: data_node_1
                           Chunks: _hyper_1_1_dist_chunk, _hyper_1_2_dist_chunk, _hyper_1_3_dist_chunk, _hyper_1_4_dist_chunk
                           Remote SQL: SELECT timec, region, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4])
               ->  Partial HashAggregate
                     Output: conditions_1.region, PARTIAL min(conditions_1.allnull), PARTIAL max(conditions_1.temperature), PARTIAL sum(conditions_1.temperature), PARTIAL sum(conditions_1.humidity), PARTIAL avg(conditions_1.humidity), PARTIAL stddev(conditions_1.humidity), PARTIAL bit_and(conditions_1.bit_int), PARTIAL bit_or(conditions_1.bit_int), PARTIAL bool_and(conditions_1.good_life), PARTIAL every((conditions_1.temperature > '0'::double precision)), PARTIAL bool_or(conditions_1.good_life), PARTIAL first(conditions_1.highlow, conditions_1.timec)
                     Group Key: conditions_1.region
                     ->  Custom Scan (DataNodeScan) on public.conditions conditions_1
                           Output: conditions_1.region, conditions_1.allnull, conditions_1.temperature, conditions_1.humidity, conditions_1.bit_int, conditions_1.good_life, conditions_1.highlow, conditions_1.timec
                           Data node: data_node_2
                           Chunks: _hyper_1_9_dist_chunk, _hyper_1_10_dist_chunk, _hyper_1_11_dist_chunk, _hyper_1_12_dist_chunk
                           Remote SQL: SELECT timec, region, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4])
               ->  Partial HashAggregate
                     Output: conditions_2.region, PARTIAL min(conditions_2.allnull), PARTIAL max(conditions_2.temperature), PARTIAL sum(conditions_2.temperature), PARTIAL sum(conditions_2.humidity), PARTIAL avg(conditions_2.humidity), PARTIAL stddev(conditions_2.humidity), PARTIAL bit_and(conditions_2.bit_int), PARTIAL bit_or(conditions_2.bit_int), PARTIAL bool_and(conditions_2.good_life), PARTIAL every((conditions_2.temperature > '0'::double precision)), PARTIAL bool_or(conditions_2.good_life), PARTIAL first(conditions_2.highlow, conditions_2.timec)
                     Group Key: conditions_2.region
                     ->  Custom Scan (DataNodeScan) on public.conditions conditions_2
                           Output: conditions_2.region, conditions_2.allnull, conditions_2.temperature, conditions_2.humidity, conditions_2.bit_int, conditions_2.good_life, conditions_2.highlow, conditions_2.timec
                           Data node: data_node_3
                           Chunks: _hyper_1_5_dist_chunk, _hyper_1_6_dist_chunk, _hyper_1_7_dist_chunk, _hyper_1_8_dist_chunk
                           Remote SQL: SELECT timec, region, temperature, humidity, allnull, highlow, bit_int, good_life FROM public.conditions WHERE _timescaledb_internal.chunks_in(conditions, ARRAY[1, 2, 3, 4])
(31 rows)

-- Full aggregate pushdown correctness check, compare location grouped query results with partionwise aggregates on and off
\set GROUPING 'location'
SELECT format('%s/results/dist_agg_loc_results_test.out', :'TEST_OUTPUT_DIR') as "RESULTS_TEST1",
       format('%s/results/dist_agg_loc_results_control.out', :'TEST_OUTPUT_DIR') as "RESULTS_CONTROL1"
\gset
SELECT format('\! diff %s %s', :'RESULTS_CONTROL1', :'RESULTS_TEST1') as "DIFF_CMD1"
\gset
--generate the results into two different files
\set ECHO errors
:DIFF_CMD1
-- Partial aggregate pushdown correctness check, compare region grouped query results with partionwise aggregates on and off
\set GROUPING 'region'
SELECT format('%s/results/dist_agg_region_results_test.out', :'TEST_OUTPUT_DIR') as "RESULTS_TEST2",
       format('%s/results/dist_agg_region_results_control.out', :'TEST_OUTPUT_DIR') as "RESULTS_CONTROL2"
\gset
SELECT format('\! diff %s %s', :'RESULTS_CONTROL2', :'RESULTS_TEST2') as "DIFF_CMD2"
\gset
--generate the results into two different files
\set ECHO errors
:DIFF_CMD2
